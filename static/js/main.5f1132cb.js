/*! For license information please see main.5f1132cb.js.LICENSE.txt */
(()=>{var e={232:function(e,t,n){(function(){"use strict";var e;function t(e){var t=0;return function(){return t<e.length?{done:!1,value:e[t++]}:{done:!0}}}var a="function"==typeof Object.defineProperties?Object.defineProperty:function(e,t,n){return e==Array.prototype||e==Object.prototype||(e[t]=n.value),e};var r=function(e){e=["object"==typeof globalThis&&globalThis,e,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof n.g&&n.g];for(var t=0;t<e.length;++t){var a=e[t];if(a&&a.Math==Math)return a}throw Error("Cannot find global object")}(this);function s(e,t){if(t)e:{var n=r;e=e.split(".");for(var s=0;s<e.length-1;s++){var o=e[s];if(!(o in n))break e;n=n[o]}(t=t(s=n[e=e[e.length-1]]))!=s&&null!=t&&a(n,e,{configurable:!0,writable:!0,value:t})}}function o(e){return(e={next:e})[Symbol.iterator]=function(){return this},e}function i(e){var n="undefined"!=typeof Symbol&&Symbol.iterator&&e[Symbol.iterator];return n?n.call(e):{next:t(e)}}function c(e){if(!(e instanceof Array)){e=i(e);for(var t,n=[];!(t=e.next()).done;)n.push(t.value);e=n}return e}s("Symbol",(function(e){function t(e,t){this.g=e,a(this,"description",{configurable:!0,writable:!0,value:t})}if(e)return e;t.prototype.toString=function(){return this.g};var n="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",r=0;return function e(a){if(this instanceof e)throw new TypeError("Symbol is not a constructor");return new t(n+(a||"")+"_"+r++,a)}})),s("Symbol.iterator",(function(e){if(e)return e;e=Symbol("Symbol.iterator");for(var n="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),s=0;s<n.length;s++){var i=r[n[s]];"function"===typeof i&&"function"!=typeof i.prototype[e]&&a(i.prototype,e,{configurable:!0,writable:!0,value:function(){return o(t(this))}})}return e}));var l,u="function"==typeof Object.create?Object.create:function(e){function t(){}return t.prototype=e,new t};if("function"==typeof Object.setPrototypeOf)l=Object.setPrototypeOf;else{var h;e:{var d={};try{d.__proto__={a:!0},h=d.a;break e}catch(Je){}h=!1}l=h?function(e,t){if(e.__proto__=t,e.__proto__!==t)throw new TypeError(e+" is not extensible");return e}:null}var p=l;function f(e,t){if(e.prototype=u(t.prototype),e.prototype.constructor=e,p)p(e,t);else for(var n in t)if("prototype"!=n)if(Object.defineProperties){var a=Object.getOwnPropertyDescriptor(t,n);a&&Object.defineProperty(e,n,a)}else e[n]=t[n];e.ea=t.prototype}function m(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.s=this.m=0,this.j=null}function g(e){if(e.l)throw new TypeError("Generator is already running");e.l=!0}function y(e,t){e.j={U:t,V:!0},e.g=e.m||e.s}function b(e,t,n){return e.g=n,{value:t}}function v(e){this.g=new m,this.h=e}function x(e,t,n,a){try{var r=t.call(e.g.i,n);if(!(r instanceof Object))throw new TypeError("Iterator result "+r+" is not an object");if(!r.done)return e.g.l=!1,r;var s=r.value}catch(o){return e.g.i=null,y(e.g,o),w(e)}return e.g.i=null,a.call(e.g,s),w(e)}function w(e){for(;e.g.g;)try{var t=e.h(e.g);if(t)return e.g.l=!1,{value:t.value,done:!1}}catch(n){e.g.h=void 0,y(e.g,n)}if(e.g.l=!1,e.g.j){if(t=e.g.j,e.g.j=null,t.V)throw t.U;return{value:t.return,done:!0}}return{value:void 0,done:!0}}function k(e){this.next=function(t){return g(e.g),e.g.i?t=x(e,e.g.i.next,t,e.g.o):(e.g.o(t),t=w(e)),t},this.throw=function(t){return g(e.g),e.g.i?t=x(e,e.g.i.throw,t,e.g.o):(y(e.g,t),t=w(e)),t},this.return=function(t){return function(e,t){g(e.g);var n=e.g.i;return n?x(e,"return"in n?n.return:function(e){return{value:e,done:!0}},t,e.g.return):(e.g.return(t),w(e))}(e,t)},this[Symbol.iterator]=function(){return this}}function S(e,t){return t=new k(new v(t)),p&&e.prototype&&p(t,e.prototype),t}m.prototype.o=function(e){this.h=e},m.prototype.return=function(e){this.j={return:e},this.g=this.s};var I="function"==typeof Object.assign?Object.assign:function(e,t){for(var n=1;n<arguments.length;n++){var a=arguments[n];if(a)for(var r in a)Object.prototype.hasOwnProperty.call(a,r)&&(e[r]=a[r])}return e};s("Object.assign",(function(e){return e||I})),s("Promise",(function(e){function t(e){this.h=0,this.i=void 0,this.g=[],this.o=!1;var t=this.j();try{e(t.resolve,t.reject)}catch(n){t.reject(n)}}function n(){this.g=null}function a(e){return e instanceof t?e:new t((function(t){t(e)}))}if(e)return e;n.prototype.h=function(e){if(null==this.g){this.g=[];var t=this;this.i((function(){t.l()}))}this.g.push(e)};var s=r.setTimeout;n.prototype.i=function(e){s(e,0)},n.prototype.l=function(){for(;this.g&&this.g.length;){var e=this.g;this.g=[];for(var t=0;t<e.length;++t){var n=e[t];e[t]=null;try{n()}catch(a){this.j(a)}}}this.g=null},n.prototype.j=function(e){this.i((function(){throw e}))},t.prototype.j=function(){function e(e){return function(a){n||(n=!0,e.call(t,a))}}var t=this,n=!1;return{resolve:e(this.C),reject:e(this.l)}},t.prototype.C=function(e){if(e===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(e instanceof t)this.F(e);else{e:switch(typeof e){case"object":var n=null!=e;break e;case"function":n=!0;break e;default:n=!1}n?this.u(e):this.m(e)}},t.prototype.u=function(e){var t=void 0;try{t=e.then}catch(n){return void this.l(n)}"function"==typeof t?this.G(t,e):this.m(e)},t.prototype.l=function(e){this.s(2,e)},t.prototype.m=function(e){this.s(1,e)},t.prototype.s=function(e,t){if(0!=this.h)throw Error("Cannot settle("+e+", "+t+"): Promise already settled in state"+this.h);this.h=e,this.i=t,2===this.h&&this.D(),this.A()},t.prototype.D=function(){var e=this;s((function(){if(e.B()){var t=r.console;"undefined"!==typeof t&&t.error(e.i)}}),1)},t.prototype.B=function(){if(this.o)return!1;var e=r.CustomEvent,t=r.Event,n=r.dispatchEvent;return"undefined"===typeof n||("function"===typeof e?e=new e("unhandledrejection",{cancelable:!0}):"function"===typeof t?e=new t("unhandledrejection",{cancelable:!0}):(e=r.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection",!1,!0,e),e.promise=this,e.reason=this.i,n(e))},t.prototype.A=function(){if(null!=this.g){for(var e=0;e<this.g.length;++e)o.h(this.g[e]);this.g=null}};var o=new n;return t.prototype.F=function(e){var t=this.j();e.J(t.resolve,t.reject)},t.prototype.G=function(e,t){var n=this.j();try{e.call(t,n.resolve,n.reject)}catch(a){n.reject(a)}},t.prototype.then=function(e,n){function a(e,t){return"function"==typeof e?function(t){try{r(e(t))}catch(n){s(n)}}:t}var r,s,o=new t((function(e,t){r=e,s=t}));return this.J(a(e,r),a(n,s)),o},t.prototype.catch=function(e){return this.then(void 0,e)},t.prototype.J=function(e,t){function n(){switch(a.h){case 1:e(a.i);break;case 2:t(a.i);break;default:throw Error("Unexpected state: "+a.h)}}var a=this;null==this.g?o.h(n):this.g.push(n),this.o=!0},t.resolve=a,t.reject=function(e){return new t((function(t,n){n(e)}))},t.race=function(e){return new t((function(t,n){for(var r=i(e),s=r.next();!s.done;s=r.next())a(s.value).J(t,n)}))},t.all=function(e){var n=i(e),r=n.next();return r.done?a([]):new t((function(e,t){function s(t){return function(n){o[t]=n,0==--i&&e(o)}}var o=[],i=0;do{o.push(void 0),i++,a(r.value).J(s(o.length-1),t),r=n.next()}while(!r.done)}))},t})),s("Object.is",(function(e){return e||function(e,t){return e===t?0!==e||1/e===1/t:e!==e&&t!==t}})),s("Array.prototype.includes",(function(e){return e||function(e,t){var n=this;n instanceof String&&(n=String(n));var a=n.length;for(0>(t=t||0)&&(t=Math.max(t+a,0));t<a;t++){var r=n[t];if(r===e||Object.is(r,e))return!0}return!1}})),s("String.prototype.includes",(function(e){return e||function(e,t){if(null==this)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(e instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return-1!==this.indexOf(e,t||0)}})),s("Array.prototype.keys",(function(e){return e||function(){return function(e,t){e instanceof String&&(e+="");var n=0,a=!1,r={next:function(){if(!a&&n<e.length){var r=n++;return{value:t(r,e[r]),done:!1}}return a=!0,{done:!0,value:void 0}}};return r[Symbol.iterator]=function(){return r},r}(this,(function(e){return e}))}}));var N=this||self;function C(e,t){e=e.split(".");var n,a=N;e[0]in a||"undefined"==typeof a.execScript||a.execScript("var "+e[0]);for(;e.length&&(n=e.shift());)e.length||void 0===t?a=a[n]&&a[n]!==Object.prototype[n]?a[n]:a[n]={}:a[n]=t}function T(e,t){return t=String.fromCharCode.apply(null,t),null==e?t:e+t}var E,R,A="undefined"!==typeof TextDecoder,_="undefined"!==typeof TextEncoder;function F(e){if(_)e=(R||(R=new TextEncoder)).encode(e);else{var t=void 0;t=void 0!==t&&t;for(var n=0,a=new Uint8Array(3*e.length),r=0;r<e.length;r++){var s=e.charCodeAt(r);if(128>s)a[n++]=s;else{if(2048>s)a[n++]=s>>6|192;else{if(55296<=s&&57343>=s){if(56319>=s&&r<e.length){var o=e.charCodeAt(++r);if(56320<=o&&57343>=o){s=1024*(s-55296)+o-56320+65536,a[n++]=s>>18|240,a[n++]=s>>12&63|128,a[n++]=s>>6&63|128,a[n++]=63&s|128;continue}r--}if(t)throw Error("Found an unpaired surrogate");s=65533}a[n++]=s>>12|224,a[n++]=s>>6&63|128}a[n++]=63&s|128}}e=a.subarray(0,n)}return e}var O={},D=null;function M(e,t){void 0===t&&(t=0),P(),t=O[t];for(var n=Array(Math.floor(e.length/3)),a=t[64]||"",r=0,s=0;r<e.length-2;r+=3){var o=e[r],i=e[r+1],c=e[r+2],l=t[o>>2];o=t[(3&o)<<4|i>>4],i=t[(15&i)<<2|c>>6],c=t[63&c],n[s++]=l+o+i+c}switch(l=0,c=a,e.length-r){case 2:c=t[(15&(l=e[r+1]))<<2]||a;case 1:e=e[r],n[s]=t[e>>2]+t[(3&e)<<4|l>>4]+c+a}return n.join("")}function L(e){var t=e.length,n=3*t/4;n%3?n=Math.floor(n):-1!="=.".indexOf(e[t-1])&&(n=-1!="=.".indexOf(e[t-2])?n-2:n-1);var a=new Uint8Array(n),r=0;return function(e,t){function n(t){for(;a<e.length;){var n=e.charAt(a++),r=D[n];if(null!=r)return r;if(!/^[\s\xa0]*$/.test(n))throw Error("Unknown base64 encoding at char: "+n)}return t}P();for(var a=0;;){var r=n(-1),s=n(0),o=n(64),i=n(64);if(64===i&&-1===r)break;t(r<<2|s>>4),64!=o&&(t(s<<4&240|o>>2),64!=i&&t(o<<6&192|i))}}(e,(function(e){a[r++]=e})),a.subarray(0,r)}function P(){if(!D){D={};for(var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),t=["+/=","+/","-_=","-_.","-_"],n=0;5>n;n++){var a=e.concat(t[n].split(""));O[n]=a;for(var r=0;r<a.length;r++){var s=a[r];void 0===D[s]&&(D[s]=r)}}}}var z,B="function"===typeof Uint8Array.prototype.slice;function W(e,t,n){return t===n?z||(z=new Uint8Array(0)):B?e.slice(t,n):new Uint8Array(e.subarray(t,n))}var U=0;function V(e,t){t=void 0!==(t=void 0===t?{}:t).v&&t.v,this.h=null,this.g=this.i=this.j=0,this.l=!1,this.v=t,e&&G(this,e)}function G(e,t){t=t.constructor===Uint8Array?t:t.constructor===ArrayBuffer||t.constructor===Array?new Uint8Array(t):t.constructor===String?L(t):t instanceof Uint8Array?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):new Uint8Array(0),e.h=t,e.j=0,e.i=e.h.length,e.g=e.j}function j(e){var t=e.h,n=t[e.g],a=127&n;return 128>n?(e.g+=1,a):(a|=(127&(n=t[e.g+1]))<<7,128>n?(e.g+=2,a):(a|=(127&(n=t[e.g+2]))<<14,128>n?(e.g+=3,a):(a|=(127&(n=t[e.g+3]))<<21,128>n?(e.g+=4,a):(a|=(15&(n=t[e.g+4]))<<28,128>n?(e.g+=5,a>>>0):(e.g+=5,128<=t[e.g++]&&128<=t[e.g++]&&128<=t[e.g++]&&128<=t[e.g++]&&e.g++,a)))))}function H(e){var t=e.h[e.g],n=e.h[e.g+1],a=e.h[e.g+2],r=e.h[e.g+3];return e.g+=4,e=2*((n=(t<<0|n<<8|a<<16|r<<24)>>>0)>>31)+1,t=n>>>23&255,n&=8388607,255==t?n?NaN:1/0*e:0==t?e*Math.pow(2,-149)*n:e*Math.pow(2,t-150)*(n+Math.pow(2,23))}V.prototype.reset=function(){this.g=this.j};var K=[];function q(){this.g=new Uint8Array(64),this.h=0}function X(e,t){for(;127<t;)e.push(127&t|128),t>>>=7;e.push(t)}function Y(e){var t={},n=void 0!==t.N&&t.N;this.o={v:void 0!==t.v&&t.v},this.N=n,t=this.o,K.length?(n=K.pop(),t&&(n.v=t.v),e&&G(n,e),e=n):e=new V(e,t),this.g=e,this.m=this.g.g,this.h=this.i=this.l=-1,this.j=!1}function Z(e){var t=e.g;if((t=t.g==t.i)||(t=e.j)||(t=(t=e.g).l||0>t.g||t.g>t.i),t)return!1;e.m=e.g.g;var n=7&(t=j(e.g));return 0!=n&&5!=n&&1!=n&&2!=n&&3!=n&&4!=n?(e.j=!0,!1):(e.i=t,e.l=t>>>3,e.h=n,!0)}function Q(e){switch(e.h){case 0:if(0!=e.h)Q(e);else{for(e=e.g;128&e.h[e.g];)e.g++;e.g++}break;case 1:1!=e.h?Q(e):(e=e.g).g+=8;break;case 2:if(2!=e.h)Q(e);else{var t=j(e.g);(e=e.g).g+=t}break;case 5:5!=e.h?Q(e):(e=e.g).g+=4;break;case 3:for(t=e.l;;){if(!Z(e)){e.j=!0;break}if(4==e.h){e.l!=t&&(e.j=!0);break}Q(e)}break;default:e.j=!0}}function J(e,t,n){var a=e.g.i,r=j(e.g),s=e.g.g+r;if(e.g.i=s,n(t,e),0!==(n=s-e.g.g))throw Error("Message parsing ended unexpectedly. Expected to read "+r+" bytes, instead read "+(r-n)+" bytes, either the data ended unexpectedly or the message misreported its own length");return e.g.g=s,e.g.i=a,t}function $(e){var t,n=j(e.g),a=(e=e.g).g;if(e.g+=n,e=e.h,A)(t=E)||(t=E=new TextDecoder("utf-8",{fatal:!1})),t=t.decode(e.subarray(a,a+n));else{n=a+n;for(var r,s,o,i=[],c=null;a<n;)128>(r=e[a++])?i.push(r):224>r?a>=n?i.push(65533):(s=e[a++],194>r||128!==(192&s)?(a--,i.push(65533)):i.push((31&r)<<6|63&s)):240>r?a>=n-1?i.push(65533):128!==(192&(s=e[a++]))||224===r&&160>s||237===r&&160<=s||128!==(192&(t=e[a++]))?(a--,i.push(65533)):i.push((15&r)<<12|(63&s)<<6|63&t):244>=r?a>=n-2?i.push(65533):128!==(192&(s=e[a++]))||0!==s-144+(r<<28)>>30||128!==(192&(t=e[a++]))||128!==(192&(o=e[a++]))?(a--,i.push(65533)):(r=(7&r)<<18|(63&s)<<12|(63&t)<<6|63&o,r-=65536,i.push(55296+(r>>10&1023),56320+(1023&r))):i.push(65533),8192<=i.length&&(c=T(c,i),i.length=0);t=T(c,i)}return t}function ee(){this.h=[],this.i=0,this.g=new q}function te(e,t){0!==t.length&&(e.h.push(t),e.i+=t.length)}function ne(e){var t=e.i+e.g.length();if(0===t)return new Uint8Array(0);t=new Uint8Array(t);for(var n=e.h,a=n.length,r=0,s=0;s<a;s++){var o=n[s];0!==o.length&&(t.set(o,r),r+=o.length)}return 0!==(a=(n=e.g).h)&&(t.set(n.g.subarray(0,a),r),n.h=0),e.h=[t],t}function ae(e,t,n){if(null!=n){X(e.g,8*t+5),e=e.g;var a=n;0===(a=(n=0>a?1:0)?-a:a)?0<1/a?U=0:(0,U=2147483648):isNaN(a)?(0,U=2147483647):34028234663852886e22<a?(0,U=(n<<31|2139095040)>>>0):11754943508222875e-54>a?(a=Math.round(a/Math.pow(2,-149)),0,U=(n<<31|a)>>>0):(t=Math.floor(Math.log(a)/Math.LN2),a*=Math.pow(2,-t),16777216<=(a=Math.round(8388608*a))&&++t,0,U=(n<<31|t+127<<23|8388607&a)>>>0),n=U,e.push(n>>>0&255),e.push(n>>>8&255),e.push(n>>>16&255),e.push(n>>>24&255)}}q.prototype.push=function(e){if(!(this.h+1<this.g.length)){var t=this.g;this.g=new Uint8Array(Math.ceil(1+2*this.g.length)),this.g.set(t)}this.g[this.h++]=e},q.prototype.length=function(){return this.h},q.prototype.end=function(){var e=this.g,t=this.h;return this.h=0,W(e,0,t)},Y.prototype.reset=function(){this.g.reset(),this.h=this.l=-1};var re="function"===typeof Uint8Array;function se(e,t,n){if(null!=e)return"object"===typeof e?re&&e instanceof Uint8Array?n(e):oe(e,t,n):t(e)}function oe(e,t,n){if(Array.isArray(e)){for(var a=Array(e.length),r=0;r<e.length;r++)a[r]=se(e[r],t,n);return Array.isArray(e)&&e.W&&ue(a),a}for(r in a={},e)a[r]=se(e[r],t,n);return a}function ie(e){return"number"===typeof e?isFinite(e)?e:String(e):e}var ce,le={W:{value:!0,configurable:!0}};function ue(e){return Array.isArray(e)&&!Object.isFrozen(e)&&Object.defineProperties(e,le),e}function he(e,t,n){var a=ce;if(ce=null,e||(e=a),a=this.constructor.ca,e||(e=a?[a]:[]),this.j=a?0:-1,this.i=null,this.g=e,e=(a=this.g.length)-1,!a||(null===(a=this.g[e])||"object"!=typeof a||Array.isArray(a)||re&&a instanceof Uint8Array)?void 0!==t&&-1<t?(this.l=Math.max(t,e+1-this.j),this.h=null):this.l=Number.MAX_VALUE:(this.l=e-this.j,this.h=a),n)for(t=0;t<n.length;t++)(e=n[t])<this.l?(e+=this.j,(a=this.g[e])?ue(a):this.g[e]=de):(pe(this),(a=this.h[e])?ue(a):this.h[e]=de)}var de=Object.freeze(ue([]));function pe(e){var t=e.l+e.j;e.g[t]||(e.h=e.g[t]={})}function fe(e,t,n){return-1===t?null:void 0!==n&&n||t>=e.l?e.h?e.h[t]:void 0:e.g[t+e.j]}function me(e){var t=void 0!==t&&t,n=fe(e,1,t);return null==n&&(n=de),n===de&&ye(e,1,n=ue([]),t),n}function ge(e,t,n){return null==(e=null==(e=fe(e,t))?e:+e)?void 0===n?0:n:e}function ye(e,t,n,a){void 0!==a&&a||t>=e.l?(pe(e),e.h[t]=n):e.g[t+e.j]=n}function be(e,t){e.i||(e.i={});var n=e.i[1];if(!n){var a=me(e);n=[];for(var r=0;r<a.length;r++)n[r]=new t(a[r]);e.i[1]=n}return n}function ve(e,t,n,a){var r=be(e,n);t=t||new n,e=me(e),void 0!=a?(r.splice(a,0,t),e.splice(a,0,xe(t,!1))):(r.push(t),e.push(xe(t,!1)))}function xe(e,t){if(e.i)for(var n in e.i){var a=e.i[n];if(Array.isArray(a))for(var r=0;r<a.length;r++)a[r]&&xe(a[r],t);else a&&xe(a,t)}return e.g}function we(e,t){return null==(e=fe(e,t))?0:e}function ke(e,t){return null==(e=fe(e,t))?"":e}function Se(e,t){if(e=e.m){te(t,t.g.end());for(var n=0;n<e.length;n++)te(t,e[n])}}function Ie(e,t){if(4==t.h)return!1;var n=t.m;return Q(t),t.N||(t=W(t.g.h,n,t.g.g),(n=e.m)?n.push(t):e.m=[t]),!0}function Ne(e,t){var n=void 0;return new(n||(n=Promise))((function(a,r){function s(e){try{i(t.next(e))}catch(n){r(n)}}function o(e){try{i(t.throw(e))}catch(n){r(n)}}function i(e){e.done?a(e.value):new n((function(t){t(e.value)})).then(s,o)}i((t=t.apply(e,void 0)).next())}))}function Ce(e){he.call(this,e)}function Te(e,t){for(;Z(t);)switch(t.i){case 8:var n=j(t.g);ye(e,1,n);break;case 21:ye(e,2,n=H(t.g));break;case 26:ye(e,3,n=$(t));break;case 34:ye(e,4,n=$(t));break;default:if(!Ie(e,t))return e}return e}function Ee(e){he.call(this,e,-1,Re)}he.prototype.toJSON=function(){return oe(xe(this,!1),ie,M)},he.prototype.toString=function(){return xe(this,!1).toString()},f(Ce,he),f(Ee,he),Ee.prototype.addClassification=function(e,t){return ve(this,e,Ce,t),this};var Re=[1];function Ae(e){he.call(this,e)}function _e(e,t){for(;Z(t);)switch(t.i){case 13:var n=H(t.g);ye(e,1,n);break;case 21:ye(e,2,n=H(t.g));break;case 29:ye(e,3,n=H(t.g));break;case 37:ye(e,4,n=H(t.g));break;case 45:ye(e,5,n=H(t.g));break;default:if(!Ie(e,t))return e}return e}function Fe(e){he.call(this,e,-1,Oe)}f(Ae,he),f(Fe,he);var Oe=[1];function De(e){he.call(this,e)}function Me(e,t,n){if(n=e.createShader(0===n?e.VERTEX_SHADER:e.FRAGMENT_SHADER),e.shaderSource(n,t),e.compileShader(n),!e.getShaderParameter(n,e.COMPILE_STATUS))throw Error("Could not compile WebGL shader.\n\n"+e.getShaderInfoLog(n));return n}function Le(e){return be(e,Ce).map((function(e){return{index:we(e,1),Y:ge(e,2),label:null!=fe(e,3)?ke(e,3):void 0,displayName:null!=fe(e,4)?ke(e,4):void 0}}))}function Pe(e){return{x:ge(e,1),y:ge(e,2),z:ge(e,3),visibility:null!=fe(e,4)?ge(e,4):void 0}}function ze(e){e:{var t=new Fe;for(e=new Y(e);Z(e);)if(10===e.i){ve(t,J(e,new Ae,_e),Ae,void 0)}else if(!Ie(t,e))break e}return be(t,Ae).map(Pe)}function Be(e,t){this.h=e,this.g=t,this.l=0}function We(e,t,n){return function(e,t){var n=e.g;if(void 0===e.m){var a=Me(n,"\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }",0),r=Me(n,"\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }",1),s=n.createProgram();if(n.attachShader(s,a),n.attachShader(s,r),n.linkProgram(s),!n.getProgramParameter(s,n.LINK_STATUS))throw Error("Could not compile WebGL program.\n\n"+n.getProgramInfoLog(s));a=e.m=s,n.useProgram(a),r=n.getUniformLocation(a,"sampler0"),e.j={I:n.getAttribLocation(a,"aVertex"),H:n.getAttribLocation(a,"aTex"),da:r},e.s=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,e.s),n.enableVertexAttribArray(e.j.I),n.vertexAttribPointer(e.j.I,2,n.FLOAT,!1,0,0),n.bufferData(n.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,null),e.o=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,e.o),n.enableVertexAttribArray(e.j.H),n.vertexAttribPointer(e.j.H,2,n.FLOAT,!1,0,0),n.bufferData(n.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,null),n.uniform1i(r,0)}a=e.j,n.useProgram(e.m),n.canvas.width=t.width,n.canvas.height=t.height,n.viewport(0,0,t.width,t.height),n.activeTexture(n.TEXTURE0),e.h.bindTexture2d(t.glName),n.enableVertexAttribArray(a.I),n.bindBuffer(n.ARRAY_BUFFER,e.s),n.vertexAttribPointer(a.I,2,n.FLOAT,!1,0,0),n.enableVertexAttribArray(a.H),n.bindBuffer(n.ARRAY_BUFFER,e.o),n.vertexAttribPointer(a.H,2,n.FLOAT,!1,0,0),n.bindFramebuffer(n.DRAW_FRAMEBUFFER?n.DRAW_FRAMEBUFFER:n.FRAMEBUFFER,null),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),n.colorMask(!0,!0,!0,!0),n.drawArrays(n.TRIANGLE_FAN,0,4),n.disableVertexAttribArray(a.I),n.disableVertexAttribArray(a.H),n.bindBuffer(n.ARRAY_BUFFER,null),e.h.bindTexture2d(0)}(e,t),"function"===typeof e.g.canvas.transferToImageBitmap?Promise.resolve(e.g.canvas.transferToImageBitmap()):n?Promise.resolve(e.g.canvas):"function"===typeof createImageBitmap?createImageBitmap(e.g.canvas):(void 0===e.i&&(e.i=document.createElement("canvas")),new Promise((function(t){e.i.height=e.g.canvas.height,e.i.width=e.g.canvas.width,e.i.getContext("2d",{}).drawImage(e.g.canvas,0,0,e.g.canvas.width,e.g.canvas.height),t(e.i)})))}function Ue(e){this.g=e}f(De,he);var Ve=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function Ge(e,t){return t+e}function je(e,t){window[e]=t}function He(e){if(this.g=e,this.listeners={},this.j={},this.F={},this.m={},this.s={},this.G=this.o=this.R=!0,this.C=Promise.resolve(),this.P="",this.B={},this.locateFile=e&&e.locateFile||Ge,"object"===typeof window)var t=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else{if("undefined"===typeof location)throw Error("solutions can only be loaded on a web page or in a web worker");t=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/"}if(this.S=t,e.options)for(var n=(t=i(Object.keys(e.options))).next();!n.done;n=t.next()){n=n.value;var a=e.options[n].default;void 0!==a&&(this.j[n]="function"===typeof a?a():a)}}function Ke(e){return Ne(e,(function e(){var t,n,a,r,s,o,i,l,u,h,d,p=this;return S(e,(function(e){switch(e.g){case 1:return t=p,p.R?(n=function(e,t){return void 0===e.g.files?[]:"function"===typeof e.g.files?e.g.files(t):e.g.files}(p,p.j),b(e,function(){return Ne(this,(function e(){return S(e,(function(e){switch(e.g){case 1:return e.m=2,b(e,WebAssembly.instantiate(Ve),4);case 4:e.g=3,e.m=0;break;case 2:return e.m=0,e.j=null,e.return(!1);case 3:return e.return(!0)}}))}))}(),2)):e.return();case 2:if(a=e.h,"object"===typeof window)return je("createMediapipeSolutionsWasm",{locateFile:p.locateFile}),je("createMediapipeSolutionsPackedAssets",{locateFile:p.locateFile}),o=n.filter((function(e){return void 0!==e.data})),i=n.filter((function(e){return void 0===e.data})),l=Promise.all(o.map((function(e){var n=qe(t,e.url);if(void 0!==e.path){var a=e.path;n=n.then((function(e){return t.overrideFile(a,e),Promise.resolve(e)}))}return n}))),u=Promise.all(i.map((function(e){return void 0===e.simd||e.simd&&a||!e.simd&&!a?function(e){var t=document.createElement("script");return t.setAttribute("src",e),t.setAttribute("crossorigin","anonymous"),new Promise((function(e){t.addEventListener("load",(function(){e()}),!1),t.addEventListener("error",(function(){e()}),!1),document.body.appendChild(t)}))}(t.locateFile(e.url,t.S)):Promise.resolve()}))).then((function(){return Ne(t,(function e(){var t,n,a=this;return S(e,(function(e){if(1==e.g)return t=window.createMediapipeSolutionsWasm,n=window.createMediapipeSolutionsPackedAssets,b(e,t(n),2);a.h=e.h,e.g=0}))}))})),h=Ne(t,(function e(){var t=this;return S(e,(function(e){return t.g.graph&&t.g.graph.url?e=b(e,qe(t,t.g.graph.url),0):(e.g=0,e=void 0),e}))})),b(e,Promise.all([u,l,h]),7);if("function"!==typeof importScripts)throw Error("solutions can only be loaded on a web page or in a web worker");return r=n.filter((function(e){return void 0===e.simd||e.simd&&a||!e.simd&&!a})).map((function(e){return t.locateFile(e.url,t.S)})),importScripts.apply(null,c(r)),b(e,createMediapipeSolutionsWasm(Module),6);case 6:p.h=e.h,p.l=new OffscreenCanvas(1,1),p.h.canvas=p.l,s=p.h.GL.createContext(p.l,{antialias:!1,alpha:!1,ba:"undefined"!==typeof WebGL2RenderingContext?2:1}),p.h.GL.makeContextCurrent(s),e.g=4;break;case 7:if(p.l=document.createElement("canvas"),!(d=p.l.getContext("webgl2",{}))&&!(d=p.l.getContext("webgl",{})))return alert("Failed to create WebGL canvas context when passing video frame."),e.return();p.D=d,p.h.canvas=p.l,p.h.createContext(p.l,!0,!0,{});case 4:p.i=new p.h.SolutionWasm,p.R=!1,e.g=0}}))}))}function qe(e,t){return Ne(e,(function e(){var n,a,r=this;return S(e,(function(e){return t in r.F?e.return(r.F[t]):(n=r.locateFile(t,""),a=fetch(n).then((function(e){return e.arrayBuffer()})),r.F[t]=a,e.return(a))}))}))}function Xe(e,t,n){return Ne(e,(function e(){var a,r,s,o,c,l,u,h,d,p,f,m,g,y,v=this;return S(e,(function(e){switch(e.g){case 1:if(!n)return e.return(t);for(a={},r=0,s=i(Object.keys(n)),o=s.next();!o.done;o=s.next())c=o.value,"string"!==typeof(l=n[c])&&"texture"===l.type&&void 0!==t[l.stream]&&++r;1<r&&(v.G=!1),u=i(Object.keys(n)),o=u.next();case 2:if(o.done){e.g=4;break}if(h=o.value,"string"===typeof(d=n[h]))return g=a,y=h,b(e,function(e,t,n){return Ne(e,(function e(){var a,r=this;return S(e,(function(e){return"number"===typeof n||n instanceof Uint8Array||n instanceof r.h.Uint8BlobList?e.return(n):n instanceof r.h.Texture2dDataOut?((a=r.s[t])||(a=new Be(r.h,r.D),r.s[t]=a),e.return(We(a,n,r.G))):e.return(void 0)}))}))}(v,h,t[d]),14);if(p=t[d.stream],"detection_list"===d.type){if(p){for(var x=p.getRectList(),w=p.getLandmarksList(),k=p.getClassificationsList(),I=[],N=0;N<x.size();++N){var C=x.get(N);e:{var T=new De;for(C=new Y(C);Z(C);)switch(C.i){case 13:var E=H(C.g);ye(T,1,E);break;case 21:ye(T,2,E=H(C.g));break;case 29:ye(T,3,E=H(C.g));break;case 37:ye(T,4,E=H(C.g));break;case 45:ye(T,5,E=H(C.g));break;case 48:for(var R=C.g,A=128,_=0,F=E=0;4>F&&128<=A;F++)_|=(127&(A=R.h[R.g++]))<<7*F;if(128<=A&&(_|=(127&(A=R.h[R.g++]))<<28,E|=(127&A)>>4),128<=A)for(F=0;5>F&&128<=A;F++)E|=(127&(A=R.h[R.g++]))<<7*F+3;128>A?(R=_>>>0,(E=2147483648&(A=E>>>0))&&(A=~A>>>0,0==(R=1+~R>>>0)&&(A=A+1>>>0)),R=4294967296*A+(R>>>0),E=E?-R:R):(R.l=!0,E=void 0),ye(T,6,E);break;default:if(!Ie(T,C))break e}}T={Z:ge(T,1),$:ge(T,2),height:ge(T,3),width:ge(T,4),rotation:ge(T,5,0),X:we(T,6)},C=ze(w.get(N)),R=k.get(N);e:for(E=new Ee,R=new Y(R);Z(R);)if(10===R.i)E.addClassification(J(R,new Ce,Te));else if(!Ie(E,R))break e;T={T:T,O:C,M:Le(E)},I.push(T)}x=I}else x=[];a[h]=x,e.g=7;break}if("proto_list"===d.type){if(p){for(x=Array(p.size()),w=0;w<p.size();w++)x[w]=p.get(w);p.delete()}else x=[];a[h]=x,e.g=7;break}if(void 0===p){e.g=3;break}if("float_list"===d.type){a[h]=p,e.g=7;break}if("proto"===d.type){a[h]=p,e.g=7;break}if("texture"!==d.type)throw Error("Unknown output config type: '"+d.type+"'");return(f=v.s[h])||(f=new Be(v.h,v.D),v.s[h]=f),b(e,We(f,p,v.G),13);case 13:m=e.h,a[h]=m;case 7:d.transform&&a[h]&&(a[h]=d.transform(a[h])),e.g=3;break;case 14:g[y]=e.h;case 3:o=u.next(),e.g=2;break;case 4:return e.return(a)}}))}))}function Ye(e,t){for(var n=t.name||"$",a=[].concat(c(t.wants)),r=new e.h.StringList,s=i(t.wants),o=s.next();!o.done;o=s.next())r.push_back(o.value);s=e.h.PacketListener.implement({onResults:function(r){for(var s={},o=0;o<t.wants.length;++o)s[a[o]]=r.get(o);var i=e.listeners[n];i&&(e.C=Xe(e,s,t.outs).then((function(n){n=i(n);for(var r=0;r<t.wants.length;++r){var o=s[a[r]];"object"===typeof o&&o.hasOwnProperty&&o.hasOwnProperty("delete")&&o.delete()}n&&(e.C=n)})))}}),e.i.attachMultiListener(r,s),r.delete()}function Ze(e){switch(void 0===e&&(e=0),e){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function Qe(e){var t=this;e=e||{},this.g=new He({locateFile:e.locateFile,files:function(e){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:Ze(e.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:ze},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:ze},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(e){return Ne(t,(function t(){var n,a,r,s=this;return S(t,(function(t){return 1==t.g?(n=Ze(e),a="third_party/mediapipe/modules/pose_landmark/"+n,b(t,qe(s.g,n),2)):(r=t.h,s.g.overrideFile(a,r),t.return(!0))}))}))}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}(e=He.prototype).close=function(){return this.i&&this.i.delete(),Promise.resolve()},e.reset=function(){return Ne(this,(function e(){var t=this;return S(e,(function(e){t.i&&(t.i.reset(),t.m={},t.s={}),e.g=0}))}))},e.setOptions=function(e,t){var n=this;if(t=t||this.g.options){for(var a=[],r=[],s={},o=i(Object.keys(e)),c=o.next();!c.done;s={K:s.K,L:s.L},c=o.next()){var l=c.value;l in this.j&&this.j[l]===e[l]||(this.j[l]=e[l],void 0!==(c=t[l])&&(c.onChange&&(s.K=c.onChange,s.L=e[l],a.push(function(e){return function(){return Ne(n,(function t(){var n=this;return S(t,(function(t){if(1==t.g)return b(t,e.K(e.L),2);!0===t.h&&(n.o=!0),t.g=0}))}))}}(s))),c.graphOptionXref&&(l={valueNumber:1===c.type?e[l]:0,valueBoolean:0===c.type&&e[l],valueString:2===c.type?e[l]:""},c=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),c.graphOptionXref),l),r.push(c))))}0===a.length&&0===r.length||(this.o=!0,this.A=(void 0===this.A?[]:this.A).concat(r),this.u=(void 0===this.u?[]:this.u).concat(a))}},e.initialize=function(){return Ne(this,(function e(){var t=this;return S(e,(function(e){return 1==e.g?b(e,Ke(t),2):3!=e.g?b(e,Ne(t,(function e(){var t,n,a,r,s,o,c,l,u=this;return S(e,(function(e){if(1==e.g)return u.g.graph&&u.g.graph.url&&u.P===u.g.graph.url?e.return():(u.o=!0,u.g.graph&&u.g.graph.url?(u.P=u.g.graph.url,b(e,qe(u,u.g.graph.url),3)):void(e.g=2));for(2!=e.g&&(t=e.h,u.i.loadGraph(t)),n=i(Object.keys(u.B)),a=n.next();!a.done;a=n.next())r=a.value,u.i.overrideFile(r,u.B[r]);if(u.B={},u.g.listeners)for(s=i(u.g.listeners),o=s.next();!o.done;o=s.next())c=o.value,Ye(u,c);l=u.j,u.j={},u.setOptions(l),e.g=0}))})),3):b(e,function(e){return Ne(e,(function e(){var t,n,a,r,s,o,c=this;return S(e,(function(e){switch(e.g){case 1:if(!c.o)return e.return();if(!c.u){e.g=2;break}t=i(c.u),n=t.next();case 3:if(n.done){e.g=5;break}return b(e,(0,n.value)(),4);case 4:n=t.next(),e.g=3;break;case 5:c.u=void 0;case 2:if(c.A){for(a=new c.h.GraphOptionChangeRequestList,r=i(c.A),s=r.next();!s.done;s=r.next())o=s.value,a.push_back(o);c.i.changeOptions(a),a.delete(),c.A=void 0}c.o=!1,e.g=0}}))}))}(t),0)}))}))},e.overrideFile=function(e,t){this.i?this.i.overrideFile(e,t):this.B[e]=t},e.clearOverriddenFiles=function(){this.B={},this.i&&this.i.clearOverriddenFiles()},e.send=function(e,t){return Ne(this,(function n(){var a,r,s,o,c,l,u,h,d,p=this;return S(n,(function(n){switch(n.g){case 1:return p.g.inputs?(a=1e3*(void 0===t||null===t?performance.now():t),b(n,p.C,2)):n.return();case 2:return b(n,p.initialize(),3);case 3:for(r=new p.h.PacketDataList,s=i(Object.keys(e)),o=s.next();!o.done;o=s.next())if(c=o.value,l=p.g.inputs[c]){e:{var f=p,m=e[c];switch(l.type){case"video":var g=f.m[l.stream];if(g||(g=new Be(f.h,f.D),f.m[l.stream]=g),0===(f=g).l&&(f.l=f.h.createTexture()),"undefined"!==typeof HTMLVideoElement&&m instanceof HTMLVideoElement){var y=m.videoWidth;g=m.videoHeight}else"undefined"!==typeof HTMLImageElement&&m instanceof HTMLImageElement?(y=m.naturalWidth,g=m.naturalHeight):(y=m.width,g=m.height);g={glName:f.l,width:y,height:g},(y=f.g).canvas.width=g.width,y.canvas.height=g.height,y.activeTexture(y.TEXTURE0),f.h.bindTexture2d(f.l),y.texImage2D(y.TEXTURE_2D,0,y.RGBA,y.RGBA,y.UNSIGNED_BYTE,m),f.h.bindTexture2d(0),f=g;break e;case"detections":for((g=f.m[l.stream])||(g=new Ue(f.h),f.m[l.stream]=g),(f=g).data||(f.data=new f.g.DetectionListData),f.data.reset(m.length),g=0;g<m.length;++g){y=m[g];var v=f.data,x=v.setBoundingBox,w=g,k=y.T,S=new De;ye(S,1,k.Z),ye(S,2,k.$),ye(S,3,k.height),ye(S,4,k.width),ye(S,5,k.rotation),ye(S,6,k.X);var I=k=new ee;ae(I,1,fe(S,1)),ae(I,2,fe(S,2)),ae(I,3,fe(S,3)),ae(I,4,fe(S,4)),ae(I,5,fe(S,5));var N=fe(S,6);if(null!=N&&null!=N){X(I.g,48);var C=I.g,T=N;N=0>T;var E=(T=Math.abs(T))>>>0;for(T=Math.floor((T-E)/4294967296),T>>>=0,N&&(T=~T>>>0,4294967295<(E=1+(~E>>>0))&&(E=0,4294967295<++T&&(T=0))),N=U=E,E=T;0<E||127<N;)C.push(127&N|128),N=(N>>>7|E<<25)>>>0,E>>>=7;C.push(N)}if(Se(S,I),k=ne(k),x.call(v,w,k),y.O)for(v=0;v<y.O.length;++v)I=!!(S=y.O[v]).visibility,w=(x=f.data).addNormalizedLandmark,k=g,S=Object.assign(Object.assign({},S),{visibility:I?S.visibility:0}),ye(I=new Ae,1,S.x),ye(I,2,S.y),ye(I,3,S.z),S.visibility&&ye(I,4,S.visibility),ae(C=S=new ee,1,fe(I,1)),ae(C,2,fe(I,2)),ae(C,3,fe(I,3)),ae(C,4,fe(I,4)),ae(C,5,fe(I,5)),Se(I,C),S=ne(S),w.call(x,k,S);if(y.M)for(v=0;v<y.M.length;++v){if(w=(x=f.data).addClassification,k=g,S=y.M[v],ye(I=new Ce,2,S.Y),S.index&&ye(I,1,S.index),S.label&&ye(I,3,S.label),S.displayName&&ye(I,4,S.displayName),C=S=new ee,null!=(E=fe(I,1))&&null!=E)if(X(C.g,8),N=C.g,0<=E)X(N,E);else{for(T=0;9>T;T++)N.push(127&E|128),E>>=7;N.push(1)}ae(C,2,fe(I,2)),null!=(N=fe(I,3))&&(N=F(N),X(C.g,26),X(C.g,N.length),te(C,C.g.end()),te(C,N)),null!=(N=fe(I,4))&&(N=F(N),X(C.g,34),X(C.g,N.length),te(C,C.g.end()),te(C,N)),Se(I,C),S=ne(S),w.call(x,k,S)}}f=f.data;break e;default:f={}}}switch(u=f,h=l.stream,l.type){case"video":r.pushTexture2d(Object.assign(Object.assign({},u),{stream:h,timestamp:a}));break;case"detections":(d=u).stream=h,d.timestamp=a,r.pushDetectionList(d);break;default:throw Error("Unknown input config type: '"+l.type+"'")}}return p.i.send(r),b(n,p.C,4);case 4:r.delete(),n.g=0}}))}))},e.onResults=function(e,t){this.listeners[t||"$"]=e},C("Solution",He),C("OptionType",{BOOL:0,NUMBER:1,aa:2,0:"BOOL",1:"NUMBER",2:"STRING"}),(e=Qe.prototype).reset=function(){this.g.reset()},e.close=function(){return this.g.close(),Promise.resolve()},e.onResults=function(e){this.g.onResults(e)},e.initialize=function(){return Ne(this,(function e(){var t=this;return S(e,(function(e){return b(e,t.g.initialize(),0)}))}))},e.send=function(e,t){return Ne(this,(function n(){var a=this;return S(n,(function(n){return b(n,a.g.send(e,t),0)}))}))},e.setOptions=function(e){this.g.setOptions(e)},C("Pose",Qe),C("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),C("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),C("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),C("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),C("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),C("VERSION","0.4.1633558788")}).call(this)},16:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(N){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function a(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=a;var r={},s={};function o(e,t){var n,a,o;return t?(o=0<=(e>>>=0)&&e<256)&&(a=s[e])?a:(n=c(e,(0|e)<0?-1:0,!0),o&&(s[e]=n),n):(o=-128<=(e|=0)&&e<128)&&(a=r[e])?a:(n=c(e,e<0?-1:0,!1),o&&(r[e]=n),n)}function i(e,t){if(isNaN(e))return t?y:g;if(t){if(e<0)return y;if(e>=p)return k}else{if(e<=-f)return S;if(e+1>=f)return w}return e<0?i(-e,t).neg():c(e%d|0,e/d|0,t)}function c(e,t,a){return new n(e,t,a)}n.fromInt=o,n.fromNumber=i,n.fromBits=c;var l=Math.pow;function u(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"===typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var a;if((a=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===a)return u(e.substring(1),t,n).neg();for(var r=i(l(n,8)),s=g,o=0;o<e.length;o+=8){var c=Math.min(8,e.length-o),h=parseInt(e.substring(o,o+c),n);if(c<8){var d=i(l(n,c));s=s.mul(d).add(i(h))}else s=(s=s.mul(r)).add(i(h))}return s.unsigned=t,s}function h(e,t){return"number"===typeof e?i(e,t):"string"===typeof e?u(e,t):c(e.low,e.high,"boolean"===typeof t?t:e.unsigned)}n.fromString=u,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,m=o(1<<24),g=o(0);n.ZERO=g;var y=o(0,!0);n.UZERO=y;var b=o(1);n.ONE=b;var v=o(1,!0);n.UONE=v;var x=o(-1);n.NEG_ONE=x;var w=c(-1,2147483647,!1);n.MAX_VALUE=w;var k=c(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var S=c(0,-2147483648,!1);n.MIN_VALUE=S;var I=n.prototype;I.toInt=function(){return this.unsigned?this.low>>>0:this.low},I.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},I.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var t=i(e),n=this.div(t),a=n.mul(t).sub(this);return n.toString(e)+a.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var r=i(l(e,6),this.unsigned),s=this,o="";;){var c=s.div(r),u=(s.sub(c.mul(r)).toInt()>>>0).toString(e);if((s=c).isZero())return u+o;for(;u.length<6;)u="0"+u;o=""+u+o}},I.getHighBits=function(){return this.high},I.getHighBitsUnsigned=function(){return this.high>>>0},I.getLowBits=function(){return this.low},I.getLowBitsUnsigned=function(){return this.low>>>0},I.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},I.isZero=function(){return 0===this.high&&0===this.low},I.eqz=I.isZero,I.isNegative=function(){return!this.unsigned&&this.high<0},I.isPositive=function(){return this.unsigned||this.high>=0},I.isOdd=function(){return 1===(1&this.low)},I.isEven=function(){return 0===(1&this.low)},I.equals=function(e){return a(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},I.eq=I.equals,I.notEquals=function(e){return!this.eq(e)},I.neq=I.notEquals,I.ne=I.notEquals,I.lessThan=function(e){return this.comp(e)<0},I.lt=I.lessThan,I.lessThanOrEqual=function(e){return this.comp(e)<=0},I.lte=I.lessThanOrEqual,I.le=I.lessThanOrEqual,I.greaterThan=function(e){return this.comp(e)>0},I.gt=I.greaterThan,I.greaterThanOrEqual=function(e){return this.comp(e)>=0},I.gte=I.greaterThanOrEqual,I.ge=I.greaterThanOrEqual,I.compare=function(e){if(a(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},I.comp=I.compare,I.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(b)},I.neg=I.negate,I.add=function(e){a(e)||(e=h(e));var t=this.high>>>16,n=65535&this.high,r=this.low>>>16,s=65535&this.low,o=e.high>>>16,i=65535&e.high,l=e.low>>>16,u=0,d=0,p=0,f=0;return p+=(f+=s+(65535&e.low))>>>16,d+=(p+=r+l)>>>16,u+=(d+=n+i)>>>16,u+=t+o,c((p&=65535)<<16|(f&=65535),(u&=65535)<<16|(d&=65535),this.unsigned)},I.subtract=function(e){return a(e)||(e=h(e)),this.add(e.neg())},I.sub=I.subtract,I.multiply=function(e){if(this.isZero())return g;if(a(e)||(e=h(e)),t)return c(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(S))return e.isOdd()?S:g;if(e.eq(S))return this.isOdd()?S:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return i(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,r=65535&this.high,s=this.low>>>16,o=65535&this.low,l=e.high>>>16,u=65535&e.high,d=e.low>>>16,p=65535&e.low,f=0,y=0,b=0,v=0;return b+=(v+=o*p)>>>16,y+=(b+=s*p)>>>16,b&=65535,y+=(b+=o*d)>>>16,f+=(y+=r*p)>>>16,y&=65535,f+=(y+=s*d)>>>16,y&=65535,f+=(y+=o*u)>>>16,f+=n*p+r*d+s*u+o*l,c((b&=65535)<<16|(v&=65535),(f&=65535)<<16|(y&=65535),this.unsigned)},I.mul=I.multiply,I.divide=function(e){if(a(e)||(e=h(e)),e.isZero())throw Error("division by zero");var n,r,s;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?c((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return v;s=y}else{if(this.eq(S))return e.eq(b)||e.eq(x)?S:e.eq(S)?b:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?b:x:(r=this.sub(e.mul(n)),s=n.add(r.div(e)));if(e.eq(S))return this.unsigned?y:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=g}for(r=this;r.gte(e);){n=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var o=Math.ceil(Math.log(n)/Math.LN2),u=o<=48?1:l(2,o-48),d=i(n),p=d.mul(e);p.isNegative()||p.gt(r);)p=(d=i(n-=u,this.unsigned)).mul(e);d.isZero()&&(d=b),s=s.add(d),r=r.sub(p)}return s},I.div=I.divide,I.modulo=function(e){return a(e)||(e=h(e)),t?c((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},I.mod=I.modulo,I.rem=I.modulo,I.not=function(){return c(~this.low,~this.high,this.unsigned)},I.and=function(e){return a(e)||(e=h(e)),c(this.low&e.low,this.high&e.high,this.unsigned)},I.or=function(e){return a(e)||(e=h(e)),c(this.low|e.low,this.high|e.high,this.unsigned)},I.xor=function(e){return a(e)||(e=h(e)),c(this.low^e.low,this.high^e.high,this.unsigned)},I.shiftLeft=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?c(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):c(0,this.low<<e-32,this.unsigned)},I.shl=I.shiftLeft,I.shiftRight=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?c(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):c(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},I.shr=I.shiftRight,I.shiftRightUnsigned=function(e){if(a(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?c(this.low>>>e|t<<32-e,t>>>e,this.unsigned):c(32===e?t:t>>>e-32,0,this.unsigned)},I.shru=I.shiftRightUnsigned,I.shr_u=I.shiftRightUnsigned,I.toSigned=function(){return this.unsigned?c(this.low,this.high,!1):this},I.toUnsigned=function(){return this.unsigned?this:c(this.low,this.high,!0)},I.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},I.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},I.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,a){return a?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},528:e=>{"use strict";var t=Object.getOwnPropertySymbols,n=Object.prototype.hasOwnProperty,a=Object.prototype.propertyIsEnumerable;e.exports=function(){try{if(!Object.assign)return!1;var e=new String("abc");if(e[5]="de","5"===Object.getOwnPropertyNames(e)[0])return!1;for(var t={},n=0;n<10;n++)t["_"+String.fromCharCode(n)]=n;if("0123456789"!==Object.getOwnPropertyNames(t).map((function(e){return t[e]})).join(""))return!1;var a={};return"abcdefghijklmnopqrst".split("").forEach((function(e){a[e]=e})),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},a)).join("")}catch(r){return!1}}()?Object.assign:function(e,r){for(var s,o,i=function(e){if(null===e||void 0===e)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(e)}(e),c=1;c<arguments.length;c++){for(var l in s=Object(arguments[c]))n.call(s,l)&&(i[l]=s[l]);if(t){o=t(s);for(var u=0;u<o.length;u++)a.call(s,o[u])&&(i[o[u]]=s[o[u]])}}return i}},144:(e,t,n)=>{"use strict";var a=n(60),r=n(528),s=n(724);function o(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}if(!a)throw Error(o(227));var i=new Set,c={};function l(e,t){u(e,t),u(e+"Capture",t)}function u(e,t){for(c[e]=t,e=0;e<t.length;e++)i.add(t[e])}var h=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),d=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p=Object.prototype.hasOwnProperty,f={},m={};function g(e,t,n,a,r,s,o){this.acceptsBooleans=2===t||3===t||4===t,this.attributeName=a,this.attributeNamespace=r,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=s,this.removeEmptyString=o}var y={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e){y[e]=new g(e,0,!1,e,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(e){var t=e[0];y[t]=new g(t,1,!1,e[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(e){y[e]=new g(e,2,!1,e.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(e){y[e]=new g(e,2,!1,e,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e){y[e]=new g(e,3,!1,e.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(e){y[e]=new g(e,3,!0,e,null,!1,!1)})),["capture","download"].forEach((function(e){y[e]=new g(e,4,!1,e,null,!1,!1)})),["cols","rows","size","span"].forEach((function(e){y[e]=new g(e,6,!1,e,null,!1,!1)})),["rowSpan","start"].forEach((function(e){y[e]=new g(e,5,!1,e.toLowerCase(),null,!1,!1)}));var b=/[\-:]([a-z])/g;function v(e){return e[1].toUpperCase()}function x(e,t,n,a){var r=y.hasOwnProperty(t)?y[t]:null;(null!==r?0===r.type:!a&&(2<t.length&&("o"===t[0]||"O"===t[0])&&("n"===t[1]||"N"===t[1])))||(function(e,t,n,a){if(null===t||"undefined"===typeof t||function(e,t,n,a){if(null!==n&&0===n.type)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return!a&&(null!==n?!n.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,t,n,a))return!0;if(a)return!1;if(null!==n)switch(n.type){case 3:return!t;case 4:return!1===t;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}(t,n,r,a)&&(n=null),a||null===r?function(e){return!!p.call(m,e)||!p.call(f,e)&&(d.test(e)?m[e]=!0:(f[e]=!0,!1))}(t)&&(null===n?e.removeAttribute(t):e.setAttribute(t,""+n)):r.mustUseProperty?e[r.propertyName]=null===n?3!==r.type&&"":n:(t=r.attributeName,a=r.attributeNamespace,null===n?e.removeAttribute(t):(n=3===(r=r.type)||4===r&&!0===n?"":""+n,a?e.setAttributeNS(a,t,n):e.setAttribute(t,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e){var t=e.replace(b,v);y[t]=new g(t,1,!1,e,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e){var t=e.replace(b,v);y[t]=new g(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(e){var t=e.replace(b,v);y[t]=new g(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(e){y[e]=new g(e,1,!1,e.toLowerCase(),null,!1,!1)})),y.xlinkHref=new g("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(e){y[e]=new g(e,1,!1,e.toLowerCase(),null,!0,!0)}));var w=a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,k=60103,S=60106,I=60107,N=60108,C=60114,T=60109,E=60110,R=60112,A=60113,_=60120,F=60115,O=60116,D=60121,M=60128,L=60129,P=60130,z=60131;if("function"===typeof Symbol&&Symbol.for){var B=Symbol.for;k=B("react.element"),S=B("react.portal"),I=B("react.fragment"),N=B("react.strict_mode"),C=B("react.profiler"),T=B("react.provider"),E=B("react.context"),R=B("react.forward_ref"),A=B("react.suspense"),_=B("react.suspense_list"),F=B("react.memo"),O=B("react.lazy"),D=B("react.block"),B("react.scope"),M=B("react.opaque.id"),L=B("react.debug_trace_mode"),P=B("react.offscreen"),z=B("react.legacy_hidden")}var W,U="function"===typeof Symbol&&Symbol.iterator;function V(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=U&&e[U]||e["@@iterator"])?e:null}function G(e){if(void 0===W)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);W=t&&t[1]||""}return"\n"+W+e}var j=!1;function H(e,t){if(!e||j)return"";j=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(t,[])}catch(c){var a=c}Reflect.construct(e,[],t)}else{try{t.call()}catch(c){a=c}e.call(t.prototype)}else{try{throw Error()}catch(c){a=c}e()}}catch(c){if(c&&a&&"string"===typeof c.stack){for(var r=c.stack.split("\n"),s=a.stack.split("\n"),o=r.length-1,i=s.length-1;1<=o&&0<=i&&r[o]!==s[i];)i--;for(;1<=o&&0<=i;o--,i--)if(r[o]!==s[i]){if(1!==o||1!==i)do{if(o--,0>--i||r[o]!==s[i])return"\n"+r[o].replace(" at new "," at ")}while(1<=o&&0<=i);break}}}finally{j=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?G(e):""}function K(e){switch(e.tag){case 5:return G(e.type);case 16:return G("Lazy");case 13:return G("Suspense");case 19:return G("SuspenseList");case 0:case 2:case 15:return e=H(e.type,!1);case 11:return e=H(e.type.render,!1);case 22:return e=H(e.type._render,!1);case 1:return e=H(e.type,!0);default:return""}}function q(e){if(null==e)return null;if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e;switch(e){case I:return"Fragment";case S:return"Portal";case C:return"Profiler";case N:return"StrictMode";case A:return"Suspense";case _:return"SuspenseList"}if("object"===typeof e)switch(e.$$typeof){case E:return(e.displayName||"Context")+".Consumer";case T:return(e._context.displayName||"Context")+".Provider";case R:var t=e.render;return t=t.displayName||t.name||"",e.displayName||(""!==t?"ForwardRef("+t+")":"ForwardRef");case F:return q(e.type);case D:return q(e._render);case O:t=e._payload,e=e._init;try{return q(e(t))}catch(n){}}return null}function X(e){switch(typeof e){case"boolean":case"number":case"object":case"string":case"undefined":return e;default:return""}}function Y(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function Z(e){e._valueTracker||(e._valueTracker=function(e){var t=Y(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),a=""+e[t];if(!e.hasOwnProperty(t)&&"undefined"!==typeof n&&"function"===typeof n.get&&"function"===typeof n.set){var r=n.get,s=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return r.call(this)},set:function(e){a=""+e,s.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return a},setValue:function(e){a=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function Q(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),a="";return e&&(a=Y(e)?e.checked?"true":"false":e.value),(e=a)!==n&&(t.setValue(e),!0)}function J(e){if("undefined"===typeof(e=e||("undefined"!==typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}function $(e,t){var n=t.checked;return r({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:e._wrapperState.initialChecked})}function ee(e,t){var n=null==t.defaultValue?"":t.defaultValue,a=null!=t.checked?t.checked:t.defaultChecked;n=X(null!=t.value?t.value:n),e._wrapperState={initialChecked:a,initialValue:n,controlled:"checkbox"===t.type||"radio"===t.type?null!=t.checked:null!=t.value}}function te(e,t){null!=(t=t.checked)&&x(e,"checked",t,!1)}function ne(e,t){te(e,t);var n=X(t.value),a=t.type;if(null!=n)"number"===a?(0===n&&""===e.value||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if("submit"===a||"reset"===a)return void e.removeAttribute("value");t.hasOwnProperty("value")?re(e,t.type,n):t.hasOwnProperty("defaultValue")&&re(e,t.type,X(t.defaultValue)),null==t.checked&&null!=t.defaultChecked&&(e.defaultChecked=!!t.defaultChecked)}function ae(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var a=t.type;if(!("submit"!==a&&"reset"!==a||void 0!==t.value&&null!==t.value))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}""!==(n=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==n&&(e.name=n)}function re(e,t,n){"number"===t&&J(e.ownerDocument)===e||(null==n?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}function se(e,t){return e=r({children:void 0},t),(t=function(e){var t="";return a.Children.forEach(e,(function(e){null!=e&&(t+=e)})),t}(t.children))&&(e.children=t),e}function oe(e,t,n,a){if(e=e.options,t){t={};for(var r=0;r<n.length;r++)t["$"+n[r]]=!0;for(n=0;n<e.length;n++)r=t.hasOwnProperty("$"+e[n].value),e[n].selected!==r&&(e[n].selected=r),r&&a&&(e[n].defaultSelected=!0)}else{for(n=""+X(n),t=null,r=0;r<e.length;r++){if(e[r].value===n)return e[r].selected=!0,void(a&&(e[r].defaultSelected=!0));null!==t||e[r].disabled||(t=e[r])}null!==t&&(t.selected=!0)}}function ie(e,t){if(null!=t.dangerouslySetInnerHTML)throw Error(o(91));return r({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function ce(e,t){var n=t.value;if(null==n){if(n=t.children,t=t.defaultValue,null!=n){if(null!=t)throw Error(o(92));if(Array.isArray(n)){if(!(1>=n.length))throw Error(o(93));n=n[0]}t=n}null==t&&(t=""),n=t}e._wrapperState={initialValue:X(n)}}function le(e,t){var n=X(t.value),a=X(t.defaultValue);null!=n&&((n=""+n)!==e.value&&(e.value=n),null==t.defaultValue&&e.defaultValue!==n&&(e.defaultValue=n)),null!=a&&(e.defaultValue=""+a)}function ue(e){var t=e.textContent;t===e._wrapperState.initialValue&&""!==t&&null!==t&&(e.value=t)}var he={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};function de(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function pe(e,t){return null==e||"http://www.w3.org/1999/xhtml"===e?de(t):"http://www.w3.org/2000/svg"===e&&"foreignObject"===t?"http://www.w3.org/1999/xhtml":e}var fe,me,ge=(me=function(e,t){if(e.namespaceURI!==he.svg||"innerHTML"in e)e.innerHTML=t;else{for((fe=fe||document.createElement("div")).innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=fe.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}},"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,t,n,a){MSApp.execUnsafeLocalFunction((function(){return me(e,t)}))}:me);function ye(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var be={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},ve=["Webkit","ms","Moz","O"];function xe(e,t,n){return null==t||"boolean"===typeof t||""===t?"":n||"number"!==typeof t||0===t||be.hasOwnProperty(e)&&be[e]?(""+t).trim():t+"px"}function we(e,t){for(var n in e=e.style,t)if(t.hasOwnProperty(n)){var a=0===n.indexOf("--"),r=xe(n,t[n],a);"float"===n&&(n="cssFloat"),a?e.setProperty(n,r):e[n]=r}}Object.keys(be).forEach((function(e){ve.forEach((function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),be[t]=be[e]}))}));var ke=r({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function Se(e,t){if(t){if(ke[e]&&(null!=t.children||null!=t.dangerouslySetInnerHTML))throw Error(o(137,e));if(null!=t.dangerouslySetInnerHTML){if(null!=t.children)throw Error(o(60));if("object"!==typeof t.dangerouslySetInnerHTML||!("__html"in t.dangerouslySetInnerHTML))throw Error(o(61))}if(null!=t.style&&"object"!==typeof t.style)throw Error(o(62))}}function Ie(e,t){if(-1===e.indexOf("-"))return"string"===typeof t.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}function Ne(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var Ce=null,Te=null,Ee=null;function Re(e){if(e=nr(e)){if("function"!==typeof Ce)throw Error(o(280));var t=e.stateNode;t&&(t=rr(t),Ce(e.stateNode,e.type,t))}}function Ae(e){Te?Ee?Ee.push(e):Ee=[e]:Te=e}function _e(){if(Te){var e=Te,t=Ee;if(Ee=Te=null,Re(e),t)for(e=0;e<t.length;e++)Re(t[e])}}function Fe(e,t){return e(t)}function Oe(e,t,n,a,r){return e(t,n,a,r)}function De(){}var Me=Fe,Le=!1,Pe=!1;function ze(){null===Te&&null===Ee||(De(),_e())}function Be(e,t){var n=e.stateNode;if(null===n)return null;var a=rr(n);if(null===a)return null;n=a[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(a=!a.disabled)||(a=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!a;break e;default:e=!1}if(e)return null;if(n&&"function"!==typeof n)throw Error(o(231,t,typeof n));return n}var We=!1;if(h)try{var Ue={};Object.defineProperty(Ue,"passive",{get:function(){We=!0}}),window.addEventListener("test",Ue,Ue),window.removeEventListener("test",Ue,Ue)}catch(me){We=!1}function Ve(e,t,n,a,r,s,o,i,c){var l=Array.prototype.slice.call(arguments,3);try{t.apply(n,l)}catch(u){this.onError(u)}}var Ge=!1,je=null,He=!1,Ke=null,qe={onError:function(e){Ge=!0,je=e}};function Xe(e,t,n,a,r,s,o,i,c){Ge=!1,je=null,Ve.apply(qe,arguments)}function Ye(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!==(1026&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function Ze(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function Qe(e){if(Ye(e)!==e)throw Error(o(188))}function Je(e){if(e=function(e){var t=e.alternate;if(!t){if(null===(t=Ye(e)))throw Error(o(188));return t!==e?null:e}for(var n=e,a=t;;){var r=n.return;if(null===r)break;var s=r.alternate;if(null===s){if(null!==(a=r.return)){n=a;continue}break}if(r.child===s.child){for(s=r.child;s;){if(s===n)return Qe(r),e;if(s===a)return Qe(r),t;s=s.sibling}throw Error(o(188))}if(n.return!==a.return)n=r,a=s;else{for(var i=!1,c=r.child;c;){if(c===n){i=!0,n=r,a=s;break}if(c===a){i=!0,a=r,n=s;break}c=c.sibling}if(!i){for(c=s.child;c;){if(c===n){i=!0,n=s,a=r;break}if(c===a){i=!0,a=s,n=r;break}c=c.sibling}if(!i)throw Error(o(189))}}if(n.alternate!==a)throw Error(o(190))}if(3!==n.tag)throw Error(o(188));return n.stateNode.current===n?e:t}(e),!e)return null;for(var t=e;;){if(5===t.tag||6===t.tag)return t;if(t.child)t.child.return=t,t=t.child;else{if(t===e)break;for(;!t.sibling;){if(!t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}}return null}function $e(e,t){for(var n=e.alternate;null!==t;){if(t===e||t===n)return!0;t=t.return}return!1}var et,tt,nt,at,rt=!1,st=[],ot=null,it=null,ct=null,lt=new Map,ut=new Map,ht=[],dt="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function pt(e,t,n,a,r){return{blockedOn:e,domEventName:t,eventSystemFlags:16|n,nativeEvent:r,targetContainers:[a]}}function ft(e,t){switch(e){case"focusin":case"focusout":ot=null;break;case"dragenter":case"dragleave":it=null;break;case"mouseover":case"mouseout":ct=null;break;case"pointerover":case"pointerout":lt.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":ut.delete(t.pointerId)}}function mt(e,t,n,a,r,s){return null===e||e.nativeEvent!==s?(e=pt(t,n,a,r,s),null!==t&&(null!==(t=nr(t))&&tt(t)),e):(e.eventSystemFlags|=a,t=e.targetContainers,null!==r&&-1===t.indexOf(r)&&t.push(r),e)}function gt(e){var t=tr(e.target);if(null!==t){var n=Ye(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=Ze(n)))return e.blockedOn=t,void at(e.lanePriority,(function(){s.unstable_runWithPriority(e.priority,(function(){nt(n)}))}))}else if(3===t&&n.stateNode.hydrate)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function yt(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=Jt(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==n)return null!==(t=nr(n))&&tt(t),e.blockedOn=n,!1;t.shift()}return!0}function bt(e,t,n){yt(e)&&n.delete(t)}function vt(){for(rt=!1;0<st.length;){var e=st[0];if(null!==e.blockedOn){null!==(e=nr(e.blockedOn))&&et(e);break}for(var t=e.targetContainers;0<t.length;){var n=Jt(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==n){e.blockedOn=n;break}t.shift()}null===e.blockedOn&&st.shift()}null!==ot&&yt(ot)&&(ot=null),null!==it&&yt(it)&&(it=null),null!==ct&&yt(ct)&&(ct=null),lt.forEach(bt),ut.forEach(bt)}function xt(e,t){e.blockedOn===t&&(e.blockedOn=null,rt||(rt=!0,s.unstable_scheduleCallback(s.unstable_NormalPriority,vt)))}function wt(e){function t(t){return xt(t,e)}if(0<st.length){xt(st[0],e);for(var n=1;n<st.length;n++){var a=st[n];a.blockedOn===e&&(a.blockedOn=null)}}for(null!==ot&&xt(ot,e),null!==it&&xt(it,e),null!==ct&&xt(ct,e),lt.forEach(t),ut.forEach(t),n=0;n<ht.length;n++)(a=ht[n]).blockedOn===e&&(a.blockedOn=null);for(;0<ht.length&&null===(n=ht[0]).blockedOn;)gt(n),null===n.blockedOn&&ht.shift()}function kt(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var St={animationend:kt("Animation","AnimationEnd"),animationiteration:kt("Animation","AnimationIteration"),animationstart:kt("Animation","AnimationStart"),transitionend:kt("Transition","TransitionEnd")},It={},Nt={};function Ct(e){if(It[e])return It[e];if(!St[e])return e;var t,n=St[e];for(t in n)if(n.hasOwnProperty(t)&&t in Nt)return It[e]=n[t];return e}h&&(Nt=document.createElement("div").style,"AnimationEvent"in window||(delete St.animationend.animation,delete St.animationiteration.animation,delete St.animationstart.animation),"TransitionEvent"in window||delete St.transitionend.transition);var Tt=Ct("animationend"),Et=Ct("animationiteration"),Rt=Ct("animationstart"),At=Ct("transitionend"),_t=new Map,Ft=new Map,Ot=["abort","abort",Tt,"animationEnd",Et,"animationIteration",Rt,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata","loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",At,"transitionEnd","waiting","waiting"];function Dt(e,t){for(var n=0;n<e.length;n+=2){var a=e[n],r=e[n+1];r="on"+(r[0].toUpperCase()+r.slice(1)),Ft.set(a,t),_t.set(a,r),l(r,[a])}}(0,s.unstable_now)();var Mt=8;function Lt(e){if(0!==(1&e))return Mt=15,1;if(0!==(2&e))return Mt=14,2;if(0!==(4&e))return Mt=13,4;var t=24&e;return 0!==t?(Mt=12,t):0!==(32&e)?(Mt=11,32):0!==(t=192&e)?(Mt=10,t):0!==(256&e)?(Mt=9,256):0!==(t=3584&e)?(Mt=8,t):0!==(4096&e)?(Mt=7,4096):0!==(t=4186112&e)?(Mt=6,t):0!==(t=62914560&e)?(Mt=5,t):67108864&e?(Mt=4,67108864):0!==(134217728&e)?(Mt=3,134217728):0!==(t=805306368&e)?(Mt=2,t):0!==(1073741824&e)?(Mt=1,1073741824):(Mt=8,e)}function Pt(e,t){var n=e.pendingLanes;if(0===n)return Mt=0;var a=0,r=0,s=e.expiredLanes,o=e.suspendedLanes,i=e.pingedLanes;if(0!==s)a=s,r=Mt=15;else if(0!==(s=134217727&n)){var c=s&~o;0!==c?(a=Lt(c),r=Mt):0!==(i&=s)&&(a=Lt(i),r=Mt)}else 0!==(s=n&~o)?(a=Lt(s),r=Mt):0!==i&&(a=Lt(i),r=Mt);if(0===a)return 0;if(a=n&((0>(a=31-Gt(a))?0:1<<a)<<1)-1,0!==t&&t!==a&&0===(t&o)){if(Lt(t),r<=Mt)return t;Mt=r}if(0!==(t=e.entangledLanes))for(e=e.entanglements,t&=a;0<t;)r=1<<(n=31-Gt(t)),a|=e[n],t&=~r;return a}function zt(e){return 0!==(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function Bt(e,t){switch(e){case 15:return 1;case 14:return 2;case 12:return 0===(e=Wt(24&~t))?Bt(10,t):e;case 10:return 0===(e=Wt(192&~t))?Bt(8,t):e;case 8:return 0===(e=Wt(3584&~t))&&(0===(e=Wt(4186112&~t))&&(e=512)),e;case 2:return 0===(t=Wt(805306368&~t))&&(t=268435456),t}throw Error(o(358,e))}function Wt(e){return e&-e}function Ut(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function Vt(e,t,n){e.pendingLanes|=t;var a=t-1;e.suspendedLanes&=a,e.pingedLanes&=a,(e=e.eventTimes)[t=31-Gt(t)]=n}var Gt=Math.clz32?Math.clz32:function(e){return 0===e?32:31-(jt(e)/Ht|0)|0},jt=Math.log,Ht=Math.LN2;var Kt=s.unstable_UserBlockingPriority,qt=s.unstable_runWithPriority,Xt=!0;function Yt(e,t,n,a){Le||De();var r=Qt,s=Le;Le=!0;try{Oe(r,e,t,n,a)}finally{(Le=s)||ze()}}function Zt(e,t,n,a){qt(Kt,Qt.bind(null,e,t,n,a))}function Qt(e,t,n,a){var r;if(Xt)if((r=0===(4&t))&&0<st.length&&-1<dt.indexOf(e))e=pt(null,e,t,n,a),st.push(e);else{var s=Jt(e,t,n,a);if(null===s)r&&ft(e,a);else{if(r){if(-1<dt.indexOf(e))return e=pt(s,e,t,n,a),void st.push(e);if(function(e,t,n,a,r){switch(t){case"focusin":return ot=mt(ot,e,t,n,a,r),!0;case"dragenter":return it=mt(it,e,t,n,a,r),!0;case"mouseover":return ct=mt(ct,e,t,n,a,r),!0;case"pointerover":var s=r.pointerId;return lt.set(s,mt(lt.get(s)||null,e,t,n,a,r)),!0;case"gotpointercapture":return s=r.pointerId,ut.set(s,mt(ut.get(s)||null,e,t,n,a,r)),!0}return!1}(s,e,t,n,a))return;ft(e,a)}Da(e,t,a,null,n)}}}function Jt(e,t,n,a){var r=Ne(a);if(null!==(r=tr(r))){var s=Ye(r);if(null===s)r=null;else{var o=s.tag;if(13===o){if(null!==(r=Ze(s)))return r;r=null}else if(3===o){if(s.stateNode.hydrate)return 3===s.tag?s.stateNode.containerInfo:null;r=null}else s!==r&&(r=null)}}return Da(e,t,a,r,n),null}var $t=null,en=null,tn=null;function nn(){if(tn)return tn;var e,t,n=en,a=n.length,r="value"in $t?$t.value:$t.textContent,s=r.length;for(e=0;e<a&&n[e]===r[e];e++);var o=a-e;for(t=1;t<=o&&n[a-t]===r[s-t];t++);return tn=r.slice(e,1<t?1-t:void 0)}function an(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function rn(){return!0}function sn(){return!1}function on(e){function t(t,n,a,r,s){for(var o in this._reactName=t,this._targetInst=a,this.type=n,this.nativeEvent=r,this.target=s,this.currentTarget=null,e)e.hasOwnProperty(o)&&(t=e[o],this[o]=t?t(r):r[o]);return this.isDefaultPrevented=(null!=r.defaultPrevented?r.defaultPrevented:!1===r.returnValue)?rn:sn,this.isPropagationStopped=sn,this}return r(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!==typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=rn)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!==typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=rn)},persist:function(){},isPersistent:rn}),t}var cn,ln,un,hn={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},dn=on(hn),pn=r({},hn,{view:0,detail:0}),fn=on(pn),mn=r({},pn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Tn,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==un&&(un&&"mousemove"===e.type?(cn=e.screenX-un.screenX,ln=e.screenY-un.screenY):ln=cn=0,un=e),cn)},movementY:function(e){return"movementY"in e?e.movementY:ln}}),gn=on(mn),yn=on(r({},mn,{dataTransfer:0})),bn=on(r({},pn,{relatedTarget:0})),vn=on(r({},hn,{animationName:0,elapsedTime:0,pseudoElement:0})),xn=r({},hn,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),wn=on(xn),kn=on(r({},hn,{data:0})),Sn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},In={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Nn={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Cn(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=Nn[e])&&!!t[e]}function Tn(){return Cn}var En=r({},pn,{key:function(e){if(e.key){var t=Sn[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=an(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?In[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Tn,charCode:function(e){return"keypress"===e.type?an(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?an(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),Rn=on(En),An=on(r({},mn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),_n=on(r({},pn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Tn})),Fn=on(r({},hn,{propertyName:0,elapsedTime:0,pseudoElement:0})),On=r({},mn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Dn=on(On),Mn=[9,13,27,32],Ln=h&&"CompositionEvent"in window,Pn=null;h&&"documentMode"in document&&(Pn=document.documentMode);var zn=h&&"TextEvent"in window&&!Pn,Bn=h&&(!Ln||Pn&&8<Pn&&11>=Pn),Wn=String.fromCharCode(32),Un=!1;function Vn(e,t){switch(e){case"keyup":return-1!==Mn.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Gn(e){return"object"===typeof(e=e.detail)&&"data"in e?e.data:null}var jn=!1;var Hn={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Kn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!Hn[e.type]:"textarea"===t}function qn(e,t,n,a){Ae(a),0<(t=La(t,"onChange")).length&&(n=new dn("onChange","change",null,n,a),e.push({event:n,listeners:t}))}var Xn=null,Yn=null;function Zn(e){Ea(e,0)}function Qn(e){if(Q(ar(e)))return e}function Jn(e,t){if("change"===e)return t}var $n=!1;if(h){var ea;if(h){var ta="oninput"in document;if(!ta){var na=document.createElement("div");na.setAttribute("oninput","return;"),ta="function"===typeof na.oninput}ea=ta}else ea=!1;$n=ea&&(!document.documentMode||9<document.documentMode)}function aa(){Xn&&(Xn.detachEvent("onpropertychange",ra),Yn=Xn=null)}function ra(e){if("value"===e.propertyName&&Qn(Yn)){var t=[];if(qn(t,Yn,e,Ne(e)),e=Zn,Le)e(t);else{Le=!0;try{Fe(e,t)}finally{Le=!1,ze()}}}}function sa(e,t,n){"focusin"===e?(aa(),Yn=n,(Xn=t).attachEvent("onpropertychange",ra)):"focusout"===e&&aa()}function oa(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Qn(Yn)}function ia(e,t){if("click"===e)return Qn(t)}function ca(e,t){if("input"===e||"change"===e)return Qn(t)}var la="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t},ua=Object.prototype.hasOwnProperty;function ha(e,t){if(la(e,t))return!0;if("object"!==typeof e||null===e||"object"!==typeof t||null===t)return!1;var n=Object.keys(e),a=Object.keys(t);if(n.length!==a.length)return!1;for(a=0;a<n.length;a++)if(!ua.call(t,n[a])||!la(e[n[a]],t[n[a]]))return!1;return!0}function da(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function pa(e,t){var n,a=da(e);for(e=0;a;){if(3===a.nodeType){if(n=e+a.textContent.length,e<=t&&n>=t)return{node:a,offset:t-e};e=n}e:{for(;a;){if(a.nextSibling){a=a.nextSibling;break e}a=a.parentNode}a=void 0}a=da(a)}}function fa(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?fa(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function ma(){for(var e=window,t=J();t instanceof e.HTMLIFrameElement;){try{var n="string"===typeof t.contentWindow.location.href}catch(a){n=!1}if(!n)break;t=J((e=t.contentWindow).document)}return t}function ga(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}var ya=h&&"documentMode"in document&&11>=document.documentMode,ba=null,va=null,xa=null,wa=!1;function ka(e,t,n){var a=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;wa||null==ba||ba!==J(a)||("selectionStart"in(a=ba)&&ga(a)?a={start:a.selectionStart,end:a.selectionEnd}:a={anchorNode:(a=(a.ownerDocument&&a.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:a.anchorOffset,focusNode:a.focusNode,focusOffset:a.focusOffset},xa&&ha(xa,a)||(xa=a,0<(a=La(va,"onSelect")).length&&(t=new dn("onSelect","select",null,t,n),e.push({event:t,listeners:a}),t.target=ba)))}Dt("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),0),Dt("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1),Dt(Ot,2);for(var Sa="change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),Ia=0;Ia<Sa.length;Ia++)Ft.set(Sa[Ia],0);u("onMouseEnter",["mouseout","mouseover"]),u("onMouseLeave",["mouseout","mouseover"]),u("onPointerEnter",["pointerout","pointerover"]),u("onPointerLeave",["pointerout","pointerover"]),l("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),l("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),l("onBeforeInput",["compositionend","keypress","textInput","paste"]),l("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Na="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Ca=new Set("cancel close invalid load scroll toggle".split(" ").concat(Na));function Ta(e,t,n){var a=e.type||"unknown-event";e.currentTarget=n,function(e,t,n,a,r,s,i,c,l){if(Xe.apply(this,arguments),Ge){if(!Ge)throw Error(o(198));var u=je;Ge=!1,je=null,He||(He=!0,Ke=u)}}(a,t,void 0,e),e.currentTarget=null}function Ea(e,t){t=0!==(4&t);for(var n=0;n<e.length;n++){var a=e[n],r=a.event;a=a.listeners;e:{var s=void 0;if(t)for(var o=a.length-1;0<=o;o--){var i=a[o],c=i.instance,l=i.currentTarget;if(i=i.listener,c!==s&&r.isPropagationStopped())break e;Ta(r,i,l),s=c}else for(o=0;o<a.length;o++){if(c=(i=a[o]).instance,l=i.currentTarget,i=i.listener,c!==s&&r.isPropagationStopped())break e;Ta(r,i,l),s=c}}}if(He)throw e=Ke,He=!1,Ke=null,e}function Ra(e,t){var n=sr(t),a=e+"__bubble";n.has(a)||(Oa(t,e,2,!1),n.add(a))}var Aa="_reactListening"+Math.random().toString(36).slice(2);function _a(e){e[Aa]||(e[Aa]=!0,i.forEach((function(t){Ca.has(t)||Fa(t,!1,e,null),Fa(t,!0,e,null)})))}function Fa(e,t,n,a){var r=4<arguments.length&&void 0!==arguments[4]?arguments[4]:0,s=n;if("selectionchange"===e&&9!==n.nodeType&&(s=n.ownerDocument),null!==a&&!t&&Ca.has(e)){if("scroll"!==e)return;r|=2,s=a}var o=sr(s),i=e+"__"+(t?"capture":"bubble");o.has(i)||(t&&(r|=4),Oa(s,e,r,t),o.add(i))}function Oa(e,t,n,a){var r=Ft.get(t);switch(void 0===r?2:r){case 0:r=Yt;break;case 1:r=Zt;break;default:r=Qt}n=r.bind(null,t,n,e),r=void 0,!We||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(r=!0),a?void 0!==r?e.addEventListener(t,n,{capture:!0,passive:r}):e.addEventListener(t,n,!0):void 0!==r?e.addEventListener(t,n,{passive:r}):e.addEventListener(t,n,!1)}function Da(e,t,n,a,r){var s=a;if(0===(1&t)&&0===(2&t)&&null!==a)e:for(;;){if(null===a)return;var o=a.tag;if(3===o||4===o){var i=a.stateNode.containerInfo;if(i===r||8===i.nodeType&&i.parentNode===r)break;if(4===o)for(o=a.return;null!==o;){var c=o.tag;if((3===c||4===c)&&((c=o.stateNode.containerInfo)===r||8===c.nodeType&&c.parentNode===r))return;o=o.return}for(;null!==i;){if(null===(o=tr(i)))return;if(5===(c=o.tag)||6===c){a=s=o;continue e}i=i.parentNode}}a=a.return}!function(e,t,n){if(Pe)return e(t,n);Pe=!0;try{return Me(e,t,n)}finally{Pe=!1,ze()}}((function(){var a=s,r=Ne(n),o=[];e:{var i=_t.get(e);if(void 0!==i){var c=dn,l=e;switch(e){case"keypress":if(0===an(n))break e;case"keydown":case"keyup":c=Rn;break;case"focusin":l="focus",c=bn;break;case"focusout":l="blur",c=bn;break;case"beforeblur":case"afterblur":c=bn;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":c=gn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":c=yn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":c=_n;break;case Tt:case Et:case Rt:c=vn;break;case At:c=Fn;break;case"scroll":c=fn;break;case"wheel":c=Dn;break;case"copy":case"cut":case"paste":c=wn;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":c=An}var u=0!==(4&t),h=!u&&"scroll"===e,d=u?null!==i?i+"Capture":null:i;u=[];for(var p,f=a;null!==f;){var m=(p=f).stateNode;if(5===p.tag&&null!==m&&(p=m,null!==d&&(null!=(m=Be(f,d))&&u.push(Ma(f,m,p)))),h)break;f=f.return}0<u.length&&(i=new c(i,l,null,n,r),o.push({event:i,listeners:u}))}}if(0===(7&t)){if(c="mouseout"===e||"pointerout"===e,(!(i="mouseover"===e||"pointerover"===e)||0!==(16&t)||!(l=n.relatedTarget||n.fromElement)||!tr(l)&&!l[$a])&&(c||i)&&(i=r.window===r?r:(i=r.ownerDocument)?i.defaultView||i.parentWindow:window,c?(c=a,null!==(l=(l=n.relatedTarget||n.toElement)?tr(l):null)&&(l!==(h=Ye(l))||5!==l.tag&&6!==l.tag)&&(l=null)):(c=null,l=a),c!==l)){if(u=gn,m="onMouseLeave",d="onMouseEnter",f="mouse","pointerout"!==e&&"pointerover"!==e||(u=An,m="onPointerLeave",d="onPointerEnter",f="pointer"),h=null==c?i:ar(c),p=null==l?i:ar(l),(i=new u(m,f+"leave",c,n,r)).target=h,i.relatedTarget=p,m=null,tr(r)===a&&((u=new u(d,f+"enter",l,n,r)).target=p,u.relatedTarget=h,m=u),h=m,c&&l)e:{for(d=l,f=0,p=u=c;p;p=Pa(p))f++;for(p=0,m=d;m;m=Pa(m))p++;for(;0<f-p;)u=Pa(u),f--;for(;0<p-f;)d=Pa(d),p--;for(;f--;){if(u===d||null!==d&&u===d.alternate)break e;u=Pa(u),d=Pa(d)}u=null}else u=null;null!==c&&za(o,i,c,u,!1),null!==l&&null!==h&&za(o,h,l,u,!0)}if("select"===(c=(i=a?ar(a):window).nodeName&&i.nodeName.toLowerCase())||"input"===c&&"file"===i.type)var g=Jn;else if(Kn(i))if($n)g=ca;else{g=oa;var y=sa}else(c=i.nodeName)&&"input"===c.toLowerCase()&&("checkbox"===i.type||"radio"===i.type)&&(g=ia);switch(g&&(g=g(e,a))?qn(o,g,n,r):(y&&y(e,i,a),"focusout"===e&&(y=i._wrapperState)&&y.controlled&&"number"===i.type&&re(i,"number",i.value)),y=a?ar(a):window,e){case"focusin":(Kn(y)||"true"===y.contentEditable)&&(ba=y,va=a,xa=null);break;case"focusout":xa=va=ba=null;break;case"mousedown":wa=!0;break;case"contextmenu":case"mouseup":case"dragend":wa=!1,ka(o,n,r);break;case"selectionchange":if(ya)break;case"keydown":case"keyup":ka(o,n,r)}var b;if(Ln)e:{switch(e){case"compositionstart":var v="onCompositionStart";break e;case"compositionend":v="onCompositionEnd";break e;case"compositionupdate":v="onCompositionUpdate";break e}v=void 0}else jn?Vn(e,n)&&(v="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(v="onCompositionStart");v&&(Bn&&"ko"!==n.locale&&(jn||"onCompositionStart"!==v?"onCompositionEnd"===v&&jn&&(b=nn()):(en="value"in($t=r)?$t.value:$t.textContent,jn=!0)),0<(y=La(a,v)).length&&(v=new kn(v,e,null,n,r),o.push({event:v,listeners:y}),b?v.data=b:null!==(b=Gn(n))&&(v.data=b))),(b=zn?function(e,t){switch(e){case"compositionend":return Gn(t);case"keypress":return 32!==t.which?null:(Un=!0,Wn);case"textInput":return(e=t.data)===Wn&&Un?null:e;default:return null}}(e,n):function(e,t){if(jn)return"compositionend"===e||!Ln&&Vn(e,t)?(e=nn(),tn=en=$t=null,jn=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Bn&&"ko"!==t.locale?null:t.data}}(e,n))&&(0<(a=La(a,"onBeforeInput")).length&&(r=new kn("onBeforeInput","beforeinput",null,n,r),o.push({event:r,listeners:a}),r.data=b))}Ea(o,t)}))}function Ma(e,t,n){return{instance:e,listener:t,currentTarget:n}}function La(e,t){for(var n=t+"Capture",a=[];null!==e;){var r=e,s=r.stateNode;5===r.tag&&null!==s&&(r=s,null!=(s=Be(e,n))&&a.unshift(Ma(e,s,r)),null!=(s=Be(e,t))&&a.push(Ma(e,s,r))),e=e.return}return a}function Pa(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function za(e,t,n,a,r){for(var s=t._reactName,o=[];null!==n&&n!==a;){var i=n,c=i.alternate,l=i.stateNode;if(null!==c&&c===a)break;5===i.tag&&null!==l&&(i=l,r?null!=(c=Be(n,s))&&o.unshift(Ma(n,c,i)):r||null!=(c=Be(n,s))&&o.push(Ma(n,c,i))),n=n.return}0!==o.length&&e.push({event:t,listeners:o})}function Ba(){}var Wa=null,Ua=null;function Va(e,t){switch(e){case"button":case"input":case"select":case"textarea":return!!t.autoFocus}return!1}function Ga(e,t){return"textarea"===e||"option"===e||"noscript"===e||"string"===typeof t.children||"number"===typeof t.children||"object"===typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var ja="function"===typeof setTimeout?setTimeout:void 0,Ha="function"===typeof clearTimeout?clearTimeout:void 0;function Ka(e){1===e.nodeType?e.textContent="":9===e.nodeType&&(null!=(e=e.body)&&(e.textContent=""))}function qa(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break}return e}function Xa(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}var Ya=0;var Za=Math.random().toString(36).slice(2),Qa="__reactFiber$"+Za,Ja="__reactProps$"+Za,$a="__reactContainer$"+Za,er="__reactEvents$"+Za;function tr(e){var t=e[Qa];if(t)return t;for(var n=e.parentNode;n;){if(t=n[$a]||n[Qa]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=Xa(e);null!==e;){if(n=e[Qa])return n;e=Xa(e)}return t}n=(e=n).parentNode}return null}function nr(e){return!(e=e[Qa]||e[$a])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function ar(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(o(33))}function rr(e){return e[Ja]||null}function sr(e){var t=e[er];return void 0===t&&(t=e[er]=new Set),t}var or=[],ir=-1;function cr(e){return{current:e}}function lr(e){0>ir||(e.current=or[ir],or[ir]=null,ir--)}function ur(e,t){ir++,or[ir]=e.current,e.current=t}var hr={},dr=cr(hr),pr=cr(!1),fr=hr;function mr(e,t){var n=e.type.contextTypes;if(!n)return hr;var a=e.stateNode;if(a&&a.__reactInternalMemoizedUnmaskedChildContext===t)return a.__reactInternalMemoizedMaskedChildContext;var r,s={};for(r in n)s[r]=t[r];return a&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=s),s}function gr(e){return null!==(e=e.childContextTypes)&&void 0!==e}function yr(){lr(pr),lr(dr)}function br(e,t,n){if(dr.current!==hr)throw Error(o(168));ur(dr,t),ur(pr,n)}function vr(e,t,n){var a=e.stateNode;if(e=t.childContextTypes,"function"!==typeof a.getChildContext)return n;for(var s in a=a.getChildContext())if(!(s in e))throw Error(o(108,q(t)||"Unknown",s));return r({},n,a)}function xr(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||hr,fr=dr.current,ur(dr,e),ur(pr,pr.current),!0}function wr(e,t,n){var a=e.stateNode;if(!a)throw Error(o(169));n?(e=vr(e,t,fr),a.__reactInternalMemoizedMergedChildContext=e,lr(pr),lr(dr),ur(dr,e)):lr(pr),ur(pr,n)}var kr=null,Sr=null,Ir=s.unstable_runWithPriority,Nr=s.unstable_scheduleCallback,Cr=s.unstable_cancelCallback,Tr=s.unstable_shouldYield,Er=s.unstable_requestPaint,Rr=s.unstable_now,Ar=s.unstable_getCurrentPriorityLevel,_r=s.unstable_ImmediatePriority,Fr=s.unstable_UserBlockingPriority,Or=s.unstable_NormalPriority,Dr=s.unstable_LowPriority,Mr=s.unstable_IdlePriority,Lr={},Pr=void 0!==Er?Er:function(){},zr=null,Br=null,Wr=!1,Ur=Rr(),Vr=1e4>Ur?Rr:function(){return Rr()-Ur};function Gr(){switch(Ar()){case _r:return 99;case Fr:return 98;case Or:return 97;case Dr:return 96;case Mr:return 95;default:throw Error(o(332))}}function jr(e){switch(e){case 99:return _r;case 98:return Fr;case 97:return Or;case 96:return Dr;case 95:return Mr;default:throw Error(o(332))}}function Hr(e,t){return e=jr(e),Ir(e,t)}function Kr(e,t,n){return e=jr(e),Nr(e,t,n)}function qr(){if(null!==Br){var e=Br;Br=null,Cr(e)}Xr()}function Xr(){if(!Wr&&null!==zr){Wr=!0;var e=0;try{var t=zr;Hr(99,(function(){for(;e<t.length;e++){var n=t[e];do{n=n(!0)}while(null!==n)}})),zr=null}catch(n){throw null!==zr&&(zr=zr.slice(e+1)),Nr(_r,qr),n}finally{Wr=!1}}}var Yr=w.ReactCurrentBatchConfig;function Zr(e,t){if(e&&e.defaultProps){for(var n in t=r({},t),e=e.defaultProps)void 0===t[n]&&(t[n]=e[n]);return t}return t}var Qr=cr(null),Jr=null,$r=null,es=null;function ts(){es=$r=Jr=null}function ns(e){var t=Qr.current;lr(Qr),e.type._context._currentValue=t}function as(e,t){for(;null!==e;){var n=e.alternate;if((e.childLanes&t)===t){if(null===n||(n.childLanes&t)===t)break;n.childLanes|=t}else e.childLanes|=t,null!==n&&(n.childLanes|=t);e=e.return}}function rs(e,t){Jr=e,es=$r=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(0!==(e.lanes&t)&&(Lo=!0),e.firstContext=null)}function ss(e,t){if(es!==e&&!1!==t&&0!==t)if("number"===typeof t&&1073741823!==t||(es=e,t=1073741823),t={context:e,observedBits:t,next:null},null===$r){if(null===Jr)throw Error(o(308));$r=t,Jr.dependencies={lanes:0,firstContext:t,responders:null}}else $r=$r.next=t;return e._currentValue}var os=!1;function is(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null},effects:null}}function cs(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function ls(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function us(e,t){if(null!==(e=e.updateQueue)){var n=(e=e.shared).pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}}function hs(e,t){var n=e.updateQueue,a=e.alternate;if(null!==a&&n===(a=a.updateQueue)){var r=null,s=null;if(null!==(n=n.firstBaseUpdate)){do{var o={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===s?r=s=o:s=s.next=o,n=n.next}while(null!==n);null===s?r=s=t:s=s.next=t}else r=s=t;return n={baseState:a.baseState,firstBaseUpdate:r,lastBaseUpdate:s,shared:a.shared,effects:a.effects},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function ds(e,t,n,a){var s=e.updateQueue;os=!1;var o=s.firstBaseUpdate,i=s.lastBaseUpdate,c=s.shared.pending;if(null!==c){s.shared.pending=null;var l=c,u=l.next;l.next=null,null===i?o=u:i.next=u,i=l;var h=e.alternate;if(null!==h){var d=(h=h.updateQueue).lastBaseUpdate;d!==i&&(null===d?h.firstBaseUpdate=u:d.next=u,h.lastBaseUpdate=l)}}if(null!==o){for(d=s.baseState,i=0,h=u=l=null;;){c=o.lane;var p=o.eventTime;if((a&c)===c){null!==h&&(h=h.next={eventTime:p,lane:0,tag:o.tag,payload:o.payload,callback:o.callback,next:null});e:{var f=e,m=o;switch(c=t,p=n,m.tag){case 1:if("function"===typeof(f=m.payload)){d=f.call(p,d,c);break e}d=f;break e;case 3:f.flags=-4097&f.flags|64;case 0:if(null===(c="function"===typeof(f=m.payload)?f.call(p,d,c):f)||void 0===c)break e;d=r({},d,c);break e;case 2:os=!0}}null!==o.callback&&(e.flags|=32,null===(c=s.effects)?s.effects=[o]:c.push(o))}else p={eventTime:p,lane:c,tag:o.tag,payload:o.payload,callback:o.callback,next:null},null===h?(u=h=p,l=d):h=h.next=p,i|=c;if(null===(o=o.next)){if(null===(c=s.shared.pending))break;o=c.next,c.next=null,s.lastBaseUpdate=c,s.shared.pending=null}}null===h&&(l=d),s.baseState=l,s.firstBaseUpdate=u,s.lastBaseUpdate=h,Ui|=i,e.lanes=i,e.memoizedState=d}}function ps(e,t,n){if(e=t.effects,t.effects=null,null!==e)for(t=0;t<e.length;t++){var a=e[t],r=a.callback;if(null!==r){if(a.callback=null,a=n,"function"!==typeof r)throw Error(o(191,r));r.call(a)}}}var fs=(new a.Component).refs;function ms(e,t,n,a){n=null===(n=n(a,t=e.memoizedState))||void 0===n?t:r({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var gs={isMounted:function(e){return!!(e=e._reactInternals)&&Ye(e)===e},enqueueSetState:function(e,t,n){e=e._reactInternals;var a=dc(),r=pc(e),s=ls(a,r);s.payload=t,void 0!==n&&null!==n&&(s.callback=n),us(e,s),fc(e,r,a)},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var a=dc(),r=pc(e),s=ls(a,r);s.tag=1,s.payload=t,void 0!==n&&null!==n&&(s.callback=n),us(e,s),fc(e,r,a)},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=dc(),a=pc(e),r=ls(n,a);r.tag=2,void 0!==t&&null!==t&&(r.callback=t),us(e,r),fc(e,a,n)}};function ys(e,t,n,a,r,s,o){return"function"===typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(a,s,o):!t.prototype||!t.prototype.isPureReactComponent||(!ha(n,a)||!ha(r,s))}function bs(e,t,n){var a=!1,r=hr,s=t.contextType;return"object"===typeof s&&null!==s?s=ss(s):(r=gr(t)?fr:dr.current,s=(a=null!==(a=t.contextTypes)&&void 0!==a)?mr(e,r):hr),t=new t(n,s),e.memoizedState=null!==t.state&&void 0!==t.state?t.state:null,t.updater=gs,e.stateNode=t,t._reactInternals=e,a&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=r,e.__reactInternalMemoizedMaskedChildContext=s),t}function vs(e,t,n,a){e=t.state,"function"===typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,a),"function"===typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,a),t.state!==e&&gs.enqueueReplaceState(t,t.state,null)}function xs(e,t,n,a){var r=e.stateNode;r.props=n,r.state=e.memoizedState,r.refs=fs,is(e);var s=t.contextType;"object"===typeof s&&null!==s?r.context=ss(s):(s=gr(t)?fr:dr.current,r.context=mr(e,s)),ds(e,n,r,a),r.state=e.memoizedState,"function"===typeof(s=t.getDerivedStateFromProps)&&(ms(e,t,s,n),r.state=e.memoizedState),"function"===typeof t.getDerivedStateFromProps||"function"===typeof r.getSnapshotBeforeUpdate||"function"!==typeof r.UNSAFE_componentWillMount&&"function"!==typeof r.componentWillMount||(t=r.state,"function"===typeof r.componentWillMount&&r.componentWillMount(),"function"===typeof r.UNSAFE_componentWillMount&&r.UNSAFE_componentWillMount(),t!==r.state&&gs.enqueueReplaceState(r,r.state,null),ds(e,n,r,a),r.state=e.memoizedState),"function"===typeof r.componentDidMount&&(e.flags|=4)}var ws=Array.isArray;function ks(e,t,n){if(null!==(e=n.ref)&&"function"!==typeof e&&"object"!==typeof e){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(o(309));var a=n.stateNode}if(!a)throw Error(o(147,e));var r=""+e;return null!==t&&null!==t.ref&&"function"===typeof t.ref&&t.ref._stringRef===r?t.ref:(t=function(e){var t=a.refs;t===fs&&(t=a.refs={}),null===e?delete t[r]:t[r]=e},t._stringRef=r,t)}if("string"!==typeof e)throw Error(o(284));if(!n._owner)throw Error(o(290,e))}return e}function Ss(e,t){if("textarea"!==e.type)throw Error(o(31,"[object Object]"===Object.prototype.toString.call(t)?"object with keys {"+Object.keys(t).join(", ")+"}":t))}function Is(e){function t(t,n){if(e){var a=t.lastEffect;null!==a?(a.nextEffect=n,t.lastEffect=n):t.firstEffect=t.lastEffect=n,n.nextEffect=null,n.flags=8}}function n(n,a){if(!e)return null;for(;null!==a;)t(n,a),a=a.sibling;return null}function a(e,t){for(e=new Map;null!==t;)null!==t.key?e.set(t.key,t):e.set(t.index,t),t=t.sibling;return e}function r(e,t){return(e=Kc(e,t)).index=0,e.sibling=null,e}function s(t,n,a){return t.index=a,e?null!==(a=t.alternate)?(a=a.index)<n?(t.flags=2,n):a:(t.flags=2,n):n}function i(t){return e&&null===t.alternate&&(t.flags=2),t}function c(e,t,n,a){return null===t||6!==t.tag?((t=Zc(n,e.mode,a)).return=e,t):((t=r(t,n)).return=e,t)}function l(e,t,n,a){return null!==t&&t.elementType===n.type?((a=r(t,n.props)).ref=ks(e,t,n),a.return=e,a):((a=qc(n.type,n.key,n.props,null,e.mode,a)).ref=ks(e,t,n),a.return=e,a)}function u(e,t,n,a){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=Qc(n,e.mode,a)).return=e,t):((t=r(t,n.children||[])).return=e,t)}function h(e,t,n,a,s){return null===t||7!==t.tag?((t=Xc(n,e.mode,a,s)).return=e,t):((t=r(t,n)).return=e,t)}function d(e,t,n){if("string"===typeof t||"number"===typeof t)return(t=Zc(""+t,e.mode,n)).return=e,t;if("object"===typeof t&&null!==t){switch(t.$$typeof){case k:return(n=qc(t.type,t.key,t.props,null,e.mode,n)).ref=ks(e,null,t),n.return=e,n;case S:return(t=Qc(t,e.mode,n)).return=e,t}if(ws(t)||V(t))return(t=Xc(t,e.mode,n,null)).return=e,t;Ss(e,t)}return null}function p(e,t,n,a){var r=null!==t?t.key:null;if("string"===typeof n||"number"===typeof n)return null!==r?null:c(e,t,""+n,a);if("object"===typeof n&&null!==n){switch(n.$$typeof){case k:return n.key===r?n.type===I?h(e,t,n.props.children,a,r):l(e,t,n,a):null;case S:return n.key===r?u(e,t,n,a):null}if(ws(n)||V(n))return null!==r?null:h(e,t,n,a,null);Ss(e,n)}return null}function f(e,t,n,a,r){if("string"===typeof a||"number"===typeof a)return c(t,e=e.get(n)||null,""+a,r);if("object"===typeof a&&null!==a){switch(a.$$typeof){case k:return e=e.get(null===a.key?n:a.key)||null,a.type===I?h(t,e,a.props.children,r,a.key):l(t,e,a,r);case S:return u(t,e=e.get(null===a.key?n:a.key)||null,a,r)}if(ws(a)||V(a))return h(t,e=e.get(n)||null,a,r,null);Ss(t,a)}return null}function m(r,o,i,c){for(var l=null,u=null,h=o,m=o=0,g=null;null!==h&&m<i.length;m++){h.index>m?(g=h,h=null):g=h.sibling;var y=p(r,h,i[m],c);if(null===y){null===h&&(h=g);break}e&&h&&null===y.alternate&&t(r,h),o=s(y,o,m),null===u?l=y:u.sibling=y,u=y,h=g}if(m===i.length)return n(r,h),l;if(null===h){for(;m<i.length;m++)null!==(h=d(r,i[m],c))&&(o=s(h,o,m),null===u?l=h:u.sibling=h,u=h);return l}for(h=a(r,h);m<i.length;m++)null!==(g=f(h,r,m,i[m],c))&&(e&&null!==g.alternate&&h.delete(null===g.key?m:g.key),o=s(g,o,m),null===u?l=g:u.sibling=g,u=g);return e&&h.forEach((function(e){return t(r,e)})),l}function g(r,i,c,l){var u=V(c);if("function"!==typeof u)throw Error(o(150));if(null==(c=u.call(c)))throw Error(o(151));for(var h=u=null,m=i,g=i=0,y=null,b=c.next();null!==m&&!b.done;g++,b=c.next()){m.index>g?(y=m,m=null):y=m.sibling;var v=p(r,m,b.value,l);if(null===v){null===m&&(m=y);break}e&&m&&null===v.alternate&&t(r,m),i=s(v,i,g),null===h?u=v:h.sibling=v,h=v,m=y}if(b.done)return n(r,m),u;if(null===m){for(;!b.done;g++,b=c.next())null!==(b=d(r,b.value,l))&&(i=s(b,i,g),null===h?u=b:h.sibling=b,h=b);return u}for(m=a(r,m);!b.done;g++,b=c.next())null!==(b=f(m,r,g,b.value,l))&&(e&&null!==b.alternate&&m.delete(null===b.key?g:b.key),i=s(b,i,g),null===h?u=b:h.sibling=b,h=b);return e&&m.forEach((function(e){return t(r,e)})),u}return function(e,a,s,c){var l="object"===typeof s&&null!==s&&s.type===I&&null===s.key;l&&(s=s.props.children);var u="object"===typeof s&&null!==s;if(u)switch(s.$$typeof){case k:e:{for(u=s.key,l=a;null!==l;){if(l.key===u){if(7===l.tag){if(s.type===I){n(e,l.sibling),(a=r(l,s.props.children)).return=e,e=a;break e}}else if(l.elementType===s.type){n(e,l.sibling),(a=r(l,s.props)).ref=ks(e,l,s),a.return=e,e=a;break e}n(e,l);break}t(e,l),l=l.sibling}s.type===I?((a=Xc(s.props.children,e.mode,c,s.key)).return=e,e=a):((c=qc(s.type,s.key,s.props,null,e.mode,c)).ref=ks(e,a,s),c.return=e,e=c)}return i(e);case S:e:{for(l=s.key;null!==a;){if(a.key===l){if(4===a.tag&&a.stateNode.containerInfo===s.containerInfo&&a.stateNode.implementation===s.implementation){n(e,a.sibling),(a=r(a,s.children||[])).return=e,e=a;break e}n(e,a);break}t(e,a),a=a.sibling}(a=Qc(s,e.mode,c)).return=e,e=a}return i(e)}if("string"===typeof s||"number"===typeof s)return s=""+s,null!==a&&6===a.tag?(n(e,a.sibling),(a=r(a,s)).return=e,e=a):(n(e,a),(a=Zc(s,e.mode,c)).return=e,e=a),i(e);if(ws(s))return m(e,a,s,c);if(V(s))return g(e,a,s,c);if(u&&Ss(e,s),"undefined"===typeof s&&!l)switch(e.tag){case 1:case 22:case 0:case 11:case 15:throw Error(o(152,q(e.type)||"Component"))}return n(e,a)}}var Ns=Is(!0),Cs=Is(!1),Ts={},Es=cr(Ts),Rs=cr(Ts),As=cr(Ts);function _s(e){if(e===Ts)throw Error(o(174));return e}function Fs(e,t){switch(ur(As,t),ur(Rs,e),ur(Es,Ts),e=t.nodeType){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:pe(null,"");break;default:t=pe(t=(e=8===e?t.parentNode:t).namespaceURI||null,e=e.tagName)}lr(Es),ur(Es,t)}function Os(){lr(Es),lr(Rs),lr(As)}function Ds(e){_s(As.current);var t=_s(Es.current),n=pe(t,e.type);t!==n&&(ur(Rs,e),ur(Es,n))}function Ms(e){Rs.current===e&&(lr(Es),lr(Rs))}var Ls=cr(0);function Ps(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!==(64&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var zs=null,Bs=null,Ws=!1;function Us(e,t){var n=jc(5,null,null,0);n.elementType="DELETED",n.type="DELETED",n.stateNode=t,n.return=e,n.flags=8,null!==e.lastEffect?(e.lastEffect.nextEffect=n,e.lastEffect=n):e.firstEffect=e.lastEffect=n}function Vs(e,t){switch(e.tag){case 5:var n=e.type;return null!==(t=1!==t.nodeType||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t)&&(e.stateNode=t,!0);case 6:return null!==(t=""===e.pendingProps||3!==t.nodeType?null:t)&&(e.stateNode=t,!0);default:return!1}}function Gs(e){if(Ws){var t=Bs;if(t){var n=t;if(!Vs(e,t)){if(!(t=qa(n.nextSibling))||!Vs(e,t))return e.flags=-1025&e.flags|2,Ws=!1,void(zs=e);Us(zs,n)}zs=e,Bs=qa(t.firstChild)}else e.flags=-1025&e.flags|2,Ws=!1,zs=e}}function js(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;zs=e}function Hs(e){if(e!==zs)return!1;if(!Ws)return js(e),Ws=!0,!1;var t=e.type;if(5!==e.tag||"head"!==t&&"body"!==t&&!Ga(t,e.memoizedProps))for(t=Bs;t;)Us(e,t),t=qa(t.nextSibling);if(js(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(o(317));e:{for(e=e.nextSibling,t=0;e;){if(8===e.nodeType){var n=e.data;if("/$"===n){if(0===t){Bs=qa(e.nextSibling);break e}t--}else"$"!==n&&"$!"!==n&&"$?"!==n||t++}e=e.nextSibling}Bs=null}}else Bs=zs?qa(e.stateNode.nextSibling):null;return!0}function Ks(){Bs=zs=null,Ws=!1}var qs=[];function Xs(){for(var e=0;e<qs.length;e++)qs[e]._workInProgressVersionPrimary=null;qs.length=0}var Ys=w.ReactCurrentDispatcher,Zs=w.ReactCurrentBatchConfig,Qs=0,Js=null,$s=null,eo=null,to=!1,no=!1;function ao(){throw Error(o(321))}function ro(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!la(e[n],t[n]))return!1;return!0}function so(e,t,n,a,r,s){if(Qs=s,Js=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,Ys.current=null===e||null===e.memoizedState?Fo:Oo,e=n(a,r),no){s=0;do{if(no=!1,!(25>s))throw Error(o(301));s+=1,eo=$s=null,t.updateQueue=null,Ys.current=Do,e=n(a,r)}while(no)}if(Ys.current=_o,t=null!==$s&&null!==$s.next,Qs=0,eo=$s=Js=null,to=!1,t)throw Error(o(300));return e}function oo(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===eo?Js.memoizedState=eo=e:eo=eo.next=e,eo}function io(){if(null===$s){var e=Js.alternate;e=null!==e?e.memoizedState:null}else e=$s.next;var t=null===eo?Js.memoizedState:eo.next;if(null!==t)eo=t,$s=e;else{if(null===e)throw Error(o(310));e={memoizedState:($s=e).memoizedState,baseState:$s.baseState,baseQueue:$s.baseQueue,queue:$s.queue,next:null},null===eo?Js.memoizedState=eo=e:eo=eo.next=e}return eo}function co(e,t){return"function"===typeof t?t(e):t}function lo(e){var t=io(),n=t.queue;if(null===n)throw Error(o(311));n.lastRenderedReducer=e;var a=$s,r=a.baseQueue,s=n.pending;if(null!==s){if(null!==r){var i=r.next;r.next=s.next,s.next=i}a.baseQueue=r=s,n.pending=null}if(null!==r){r=r.next,a=a.baseState;var c=i=s=null,l=r;do{var u=l.lane;if((Qs&u)===u)null!==c&&(c=c.next={lane:0,action:l.action,eagerReducer:l.eagerReducer,eagerState:l.eagerState,next:null}),a=l.eagerReducer===e?l.eagerState:e(a,l.action);else{var h={lane:u,action:l.action,eagerReducer:l.eagerReducer,eagerState:l.eagerState,next:null};null===c?(i=c=h,s=a):c=c.next=h,Js.lanes|=u,Ui|=u}l=l.next}while(null!==l&&l!==r);null===c?s=a:c.next=i,la(a,t.memoizedState)||(Lo=!0),t.memoizedState=a,t.baseState=s,t.baseQueue=c,n.lastRenderedState=a}return[t.memoizedState,n.dispatch]}function uo(e){var t=io(),n=t.queue;if(null===n)throw Error(o(311));n.lastRenderedReducer=e;var a=n.dispatch,r=n.pending,s=t.memoizedState;if(null!==r){n.pending=null;var i=r=r.next;do{s=e(s,i.action),i=i.next}while(i!==r);la(s,t.memoizedState)||(Lo=!0),t.memoizedState=s,null===t.baseQueue&&(t.baseState=s),n.lastRenderedState=s}return[s,a]}function ho(e,t,n){var a=t._getVersion;a=a(t._source);var r=t._workInProgressVersionPrimary;if(null!==r?e=r===a:(e=e.mutableReadLanes,(e=(Qs&e)===e)&&(t._workInProgressVersionPrimary=a,qs.push(t))),e)return n(t._source);throw qs.push(t),Error(o(350))}function po(e,t,n,a){var r=Oi;if(null===r)throw Error(o(349));var s=t._getVersion,i=s(t._source),c=Ys.current,l=c.useState((function(){return ho(r,t,n)})),u=l[1],h=l[0];l=eo;var d=e.memoizedState,p=d.refs,f=p.getSnapshot,m=d.source;d=d.subscribe;var g=Js;return e.memoizedState={refs:p,source:t,subscribe:a},c.useEffect((function(){p.getSnapshot=n,p.setSnapshot=u;var e=s(t._source);if(!la(i,e)){e=n(t._source),la(h,e)||(u(e),e=pc(g),r.mutableReadLanes|=e&r.pendingLanes),e=r.mutableReadLanes,r.entangledLanes|=e;for(var a=r.entanglements,o=e;0<o;){var c=31-Gt(o),l=1<<c;a[c]|=e,o&=~l}}}),[n,t,a]),c.useEffect((function(){return a(t._source,(function(){var e=p.getSnapshot,n=p.setSnapshot;try{n(e(t._source));var a=pc(g);r.mutableReadLanes|=a&r.pendingLanes}catch(s){n((function(){throw s}))}}))}),[t,a]),la(f,n)&&la(m,t)&&la(d,a)||((e={pending:null,dispatch:null,lastRenderedReducer:co,lastRenderedState:h}).dispatch=u=Ao.bind(null,Js,e),l.queue=e,l.baseQueue=null,h=ho(r,t,n),l.memoizedState=l.baseState=h),h}function fo(e,t,n){return po(io(),e,t,n)}function mo(e){var t=oo();return"function"===typeof e&&(e=e()),t.memoizedState=t.baseState=e,e=(e=t.queue={pending:null,dispatch:null,lastRenderedReducer:co,lastRenderedState:e}).dispatch=Ao.bind(null,Js,e),[t.memoizedState,e]}function go(e,t,n,a){return e={tag:e,create:t,destroy:n,deps:a,next:null},null===(t=Js.updateQueue)?(t={lastEffect:null},Js.updateQueue=t,t.lastEffect=e.next=e):null===(n=t.lastEffect)?t.lastEffect=e.next=e:(a=n.next,n.next=e,e.next=a,t.lastEffect=e),e}function yo(e){return e={current:e},oo().memoizedState=e}function bo(){return io().memoizedState}function vo(e,t,n,a){var r=oo();Js.flags|=e,r.memoizedState=go(1|t,n,void 0,void 0===a?null:a)}function xo(e,t,n,a){var r=io();a=void 0===a?null:a;var s=void 0;if(null!==$s){var o=$s.memoizedState;if(s=o.destroy,null!==a&&ro(a,o.deps))return void go(t,n,s,a)}Js.flags|=e,r.memoizedState=go(1|t,n,s,a)}function wo(e,t){return vo(516,4,e,t)}function ko(e,t){return xo(516,4,e,t)}function So(e,t){return xo(4,2,e,t)}function Io(e,t){return"function"===typeof t?(e=e(),t(e),function(){t(null)}):null!==t&&void 0!==t?(e=e(),t.current=e,function(){t.current=null}):void 0}function No(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,xo(4,2,Io.bind(null,t,e),n)}function Co(){}function To(e,t){var n=io();t=void 0===t?null:t;var a=n.memoizedState;return null!==a&&null!==t&&ro(t,a[1])?a[0]:(n.memoizedState=[e,t],e)}function Eo(e,t){var n=io();t=void 0===t?null:t;var a=n.memoizedState;return null!==a&&null!==t&&ro(t,a[1])?a[0]:(e=e(),n.memoizedState=[e,t],e)}function Ro(e,t){var n=Gr();Hr(98>n?98:n,(function(){e(!0)})),Hr(97<n?97:n,(function(){var n=Zs.transition;Zs.transition=1;try{e(!1),t()}finally{Zs.transition=n}}))}function Ao(e,t,n){var a=dc(),r=pc(e),s={lane:r,action:n,eagerReducer:null,eagerState:null,next:null},o=t.pending;if(null===o?s.next=s:(s.next=o.next,o.next=s),t.pending=s,o=e.alternate,e===Js||null!==o&&o===Js)no=to=!0;else{if(0===e.lanes&&(null===o||0===o.lanes)&&null!==(o=t.lastRenderedReducer))try{var i=t.lastRenderedState,c=o(i,n);if(s.eagerReducer=o,s.eagerState=c,la(c,i))return}catch(l){}fc(e,r,a)}}var _o={readContext:ss,useCallback:ao,useContext:ao,useEffect:ao,useImperativeHandle:ao,useLayoutEffect:ao,useMemo:ao,useReducer:ao,useRef:ao,useState:ao,useDebugValue:ao,useDeferredValue:ao,useTransition:ao,useMutableSource:ao,useOpaqueIdentifier:ao,unstable_isNewReconciler:!1},Fo={readContext:ss,useCallback:function(e,t){return oo().memoizedState=[e,void 0===t?null:t],e},useContext:ss,useEffect:wo,useImperativeHandle:function(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,vo(4,2,Io.bind(null,t,e),n)},useLayoutEffect:function(e,t){return vo(4,2,e,t)},useMemo:function(e,t){var n=oo();return t=void 0===t?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var a=oo();return t=void 0!==n?n(t):t,a.memoizedState=a.baseState=t,e=(e=a.queue={pending:null,dispatch:null,lastRenderedReducer:e,lastRenderedState:t}).dispatch=Ao.bind(null,Js,e),[a.memoizedState,e]},useRef:yo,useState:mo,useDebugValue:Co,useDeferredValue:function(e){var t=mo(e),n=t[0],a=t[1];return wo((function(){var t=Zs.transition;Zs.transition=1;try{a(e)}finally{Zs.transition=t}}),[e]),n},useTransition:function(){var e=mo(!1),t=e[0];return yo(e=Ro.bind(null,e[1])),[e,t]},useMutableSource:function(e,t,n){var a=oo();return a.memoizedState={refs:{getSnapshot:t,setSnapshot:null},source:e,subscribe:n},po(a,e,t,n)},useOpaqueIdentifier:function(){if(Ws){var e=!1,t=function(e){return{$$typeof:M,toString:e,valueOf:e}}((function(){throw e||(e=!0,n("r:"+(Ya++).toString(36))),Error(o(355))})),n=mo(t)[1];return 0===(2&Js.mode)&&(Js.flags|=516,go(5,(function(){n("r:"+(Ya++).toString(36))}),void 0,null)),t}return mo(t="r:"+(Ya++).toString(36)),t},unstable_isNewReconciler:!1},Oo={readContext:ss,useCallback:To,useContext:ss,useEffect:ko,useImperativeHandle:No,useLayoutEffect:So,useMemo:Eo,useReducer:lo,useRef:bo,useState:function(){return lo(co)},useDebugValue:Co,useDeferredValue:function(e){var t=lo(co),n=t[0],a=t[1];return ko((function(){var t=Zs.transition;Zs.transition=1;try{a(e)}finally{Zs.transition=t}}),[e]),n},useTransition:function(){var e=lo(co)[0];return[bo().current,e]},useMutableSource:fo,useOpaqueIdentifier:function(){return lo(co)[0]},unstable_isNewReconciler:!1},Do={readContext:ss,useCallback:To,useContext:ss,useEffect:ko,useImperativeHandle:No,useLayoutEffect:So,useMemo:Eo,useReducer:uo,useRef:bo,useState:function(){return uo(co)},useDebugValue:Co,useDeferredValue:function(e){var t=uo(co),n=t[0],a=t[1];return ko((function(){var t=Zs.transition;Zs.transition=1;try{a(e)}finally{Zs.transition=t}}),[e]),n},useTransition:function(){var e=uo(co)[0];return[bo().current,e]},useMutableSource:fo,useOpaqueIdentifier:function(){return uo(co)[0]},unstable_isNewReconciler:!1},Mo=w.ReactCurrentOwner,Lo=!1;function Po(e,t,n,a){t.child=null===e?Cs(t,null,n,a):Ns(t,e.child,n,a)}function zo(e,t,n,a,r){n=n.render;var s=t.ref;return rs(t,r),a=so(e,t,n,a,s,r),null===e||Lo?(t.flags|=1,Po(e,t,a,r),t.child):(t.updateQueue=e.updateQueue,t.flags&=-517,e.lanes&=~r,si(e,t,r))}function Bo(e,t,n,a,r,s){if(null===e){var o=n.type;return"function"!==typeof o||Hc(o)||void 0!==o.defaultProps||null!==n.compare||void 0!==n.defaultProps?((e=qc(n.type,null,a,t,t.mode,s)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=o,Wo(e,t,o,a,r,s))}return o=e.child,0===(r&s)&&(r=o.memoizedProps,(n=null!==(n=n.compare)?n:ha)(r,a)&&e.ref===t.ref)?si(e,t,s):(t.flags|=1,(e=Kc(o,a)).ref=t.ref,e.return=t,t.child=e)}function Wo(e,t,n,a,r,s){if(null!==e&&ha(e.memoizedProps,a)&&e.ref===t.ref){if(Lo=!1,0===(s&r))return t.lanes=e.lanes,si(e,t,s);0!==(16384&e.flags)&&(Lo=!0)}return Go(e,t,n,a,s)}function Uo(e,t,n){var a=t.pendingProps,r=a.children,s=null!==e?e.memoizedState:null;if("hidden"===a.mode||"unstable-defer-without-hiding"===a.mode)if(0===(4&t.mode))t.memoizedState={baseLanes:0},kc(t,n);else{if(0===(1073741824&n))return e=null!==s?s.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e},kc(t,e),null;t.memoizedState={baseLanes:0},kc(t,null!==s?s.baseLanes:n)}else null!==s?(a=s.baseLanes|n,t.memoizedState=null):a=n,kc(t,a);return Po(e,t,r,n),t.child}function Vo(e,t){var n=t.ref;(null===e&&null!==n||null!==e&&e.ref!==n)&&(t.flags|=128)}function Go(e,t,n,a,r){var s=gr(n)?fr:dr.current;return s=mr(t,s),rs(t,r),n=so(e,t,n,a,s,r),null===e||Lo?(t.flags|=1,Po(e,t,n,r),t.child):(t.updateQueue=e.updateQueue,t.flags&=-517,e.lanes&=~r,si(e,t,r))}function jo(e,t,n,a,r){if(gr(n)){var s=!0;xr(t)}else s=!1;if(rs(t,r),null===t.stateNode)null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2),bs(t,n,a),xs(t,n,a,r),a=!0;else if(null===e){var o=t.stateNode,i=t.memoizedProps;o.props=i;var c=o.context,l=n.contextType;"object"===typeof l&&null!==l?l=ss(l):l=mr(t,l=gr(n)?fr:dr.current);var u=n.getDerivedStateFromProps,h="function"===typeof u||"function"===typeof o.getSnapshotBeforeUpdate;h||"function"!==typeof o.UNSAFE_componentWillReceiveProps&&"function"!==typeof o.componentWillReceiveProps||(i!==a||c!==l)&&vs(t,o,a,l),os=!1;var d=t.memoizedState;o.state=d,ds(t,a,o,r),c=t.memoizedState,i!==a||d!==c||pr.current||os?("function"===typeof u&&(ms(t,n,u,a),c=t.memoizedState),(i=os||ys(t,n,i,a,d,c,l))?(h||"function"!==typeof o.UNSAFE_componentWillMount&&"function"!==typeof o.componentWillMount||("function"===typeof o.componentWillMount&&o.componentWillMount(),"function"===typeof o.UNSAFE_componentWillMount&&o.UNSAFE_componentWillMount()),"function"===typeof o.componentDidMount&&(t.flags|=4)):("function"===typeof o.componentDidMount&&(t.flags|=4),t.memoizedProps=a,t.memoizedState=c),o.props=a,o.state=c,o.context=l,a=i):("function"===typeof o.componentDidMount&&(t.flags|=4),a=!1)}else{o=t.stateNode,cs(e,t),i=t.memoizedProps,l=t.type===t.elementType?i:Zr(t.type,i),o.props=l,h=t.pendingProps,d=o.context,"object"===typeof(c=n.contextType)&&null!==c?c=ss(c):c=mr(t,c=gr(n)?fr:dr.current);var p=n.getDerivedStateFromProps;(u="function"===typeof p||"function"===typeof o.getSnapshotBeforeUpdate)||"function"!==typeof o.UNSAFE_componentWillReceiveProps&&"function"!==typeof o.componentWillReceiveProps||(i!==h||d!==c)&&vs(t,o,a,c),os=!1,d=t.memoizedState,o.state=d,ds(t,a,o,r);var f=t.memoizedState;i!==h||d!==f||pr.current||os?("function"===typeof p&&(ms(t,n,p,a),f=t.memoizedState),(l=os||ys(t,n,l,a,d,f,c))?(u||"function"!==typeof o.UNSAFE_componentWillUpdate&&"function"!==typeof o.componentWillUpdate||("function"===typeof o.componentWillUpdate&&o.componentWillUpdate(a,f,c),"function"===typeof o.UNSAFE_componentWillUpdate&&o.UNSAFE_componentWillUpdate(a,f,c)),"function"===typeof o.componentDidUpdate&&(t.flags|=4),"function"===typeof o.getSnapshotBeforeUpdate&&(t.flags|=256)):("function"!==typeof o.componentDidUpdate||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!==typeof o.getSnapshotBeforeUpdate||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=256),t.memoizedProps=a,t.memoizedState=f),o.props=a,o.state=f,o.context=c,a=l):("function"!==typeof o.componentDidUpdate||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!==typeof o.getSnapshotBeforeUpdate||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=256),a=!1)}return Ho(e,t,n,a,s,r)}function Ho(e,t,n,a,r,s){Vo(e,t);var o=0!==(64&t.flags);if(!a&&!o)return r&&wr(t,n,!1),si(e,t,s);a=t.stateNode,Mo.current=t;var i=o&&"function"!==typeof n.getDerivedStateFromError?null:a.render();return t.flags|=1,null!==e&&o?(t.child=Ns(t,e.child,null,s),t.child=Ns(t,null,i,s)):Po(e,t,i,s),t.memoizedState=a.state,r&&wr(t,n,!0),t.child}function Ko(e){var t=e.stateNode;t.pendingContext?br(0,t.pendingContext,t.pendingContext!==t.context):t.context&&br(0,t.context,!1),Fs(e,t.containerInfo)}var qo,Xo,Yo,Zo,Qo={dehydrated:null,retryLane:0};function Jo(e,t,n){var a,r=t.pendingProps,s=Ls.current,o=!1;return(a=0!==(64&t.flags))||(a=(null===e||null!==e.memoizedState)&&0!==(2&s)),a?(o=!0,t.flags&=-65):null!==e&&null===e.memoizedState||void 0===r.fallback||!0===r.unstable_avoidThisFallback||(s|=1),ur(Ls,1&s),null===e?(void 0!==r.fallback&&Gs(t),e=r.children,s=r.fallback,o?(e=$o(t,e,s,n),t.child.memoizedState={baseLanes:n},t.memoizedState=Qo,e):"number"===typeof r.unstable_expectedLoadTime?(e=$o(t,e,s,n),t.child.memoizedState={baseLanes:n},t.memoizedState=Qo,t.lanes=33554432,e):((n=Yc({mode:"visible",children:e},t.mode,n,null)).return=t,t.child=n)):(e.memoizedState,o?(r=ti(e,t,r.children,r.fallback,n),o=t.child,s=e.child.memoizedState,o.memoizedState=null===s?{baseLanes:n}:{baseLanes:s.baseLanes|n},o.childLanes=e.childLanes&~n,t.memoizedState=Qo,r):(n=ei(e,t,r.children,n),t.memoizedState=null,n))}function $o(e,t,n,a){var r=e.mode,s=e.child;return t={mode:"hidden",children:t},0===(2&r)&&null!==s?(s.childLanes=0,s.pendingProps=t):s=Yc(t,r,0,null),n=Xc(n,r,a,null),s.return=e,n.return=e,s.sibling=n,e.child=s,n}function ei(e,t,n,a){var r=e.child;return e=r.sibling,n=Kc(r,{mode:"visible",children:n}),0===(2&t.mode)&&(n.lanes=a),n.return=t,n.sibling=null,null!==e&&(e.nextEffect=null,e.flags=8,t.firstEffect=t.lastEffect=e),t.child=n}function ti(e,t,n,a,r){var s=t.mode,o=e.child;e=o.sibling;var i={mode:"hidden",children:n};return 0===(2&s)&&t.child!==o?((n=t.child).childLanes=0,n.pendingProps=i,null!==(o=n.lastEffect)?(t.firstEffect=n.firstEffect,t.lastEffect=o,o.nextEffect=null):t.firstEffect=t.lastEffect=null):n=Kc(o,i),null!==e?a=Kc(e,a):(a=Xc(a,s,r,null)).flags|=2,a.return=t,n.return=t,n.sibling=a,t.child=n,a}function ni(e,t){e.lanes|=t;var n=e.alternate;null!==n&&(n.lanes|=t),as(e.return,t)}function ai(e,t,n,a,r,s){var o=e.memoizedState;null===o?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:a,tail:n,tailMode:r,lastEffect:s}:(o.isBackwards=t,o.rendering=null,o.renderingStartTime=0,o.last=a,o.tail=n,o.tailMode=r,o.lastEffect=s)}function ri(e,t,n){var a=t.pendingProps,r=a.revealOrder,s=a.tail;if(Po(e,t,a.children,n),0!==(2&(a=Ls.current)))a=1&a|2,t.flags|=64;else{if(null!==e&&0!==(64&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&ni(e,n);else if(19===e.tag)ni(e,n);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}a&=1}if(ur(Ls,a),0===(2&t.mode))t.memoizedState=null;else switch(r){case"forwards":for(n=t.child,r=null;null!==n;)null!==(e=n.alternate)&&null===Ps(e)&&(r=n),n=n.sibling;null===(n=r)?(r=t.child,t.child=null):(r=n.sibling,n.sibling=null),ai(t,!1,r,n,s,t.lastEffect);break;case"backwards":for(n=null,r=t.child,t.child=null;null!==r;){if(null!==(e=r.alternate)&&null===Ps(e)){t.child=r;break}e=r.sibling,r.sibling=n,n=r,r=e}ai(t,!0,n,null,s,t.lastEffect);break;case"together":ai(t,!1,null,null,void 0,t.lastEffect);break;default:t.memoizedState=null}return t.child}function si(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),Ui|=t.lanes,0!==(n&t.childLanes)){if(null!==e&&t.child!==e.child)throw Error(o(153));if(null!==t.child){for(n=Kc(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=Kc(e,e.pendingProps)).return=t;n.sibling=null}return t.child}return null}function oi(e,t){if(!Ws)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var a=null;null!==n;)null!==n.alternate&&(a=n),n=n.sibling;null===a?t||null===e.tail?e.tail=null:e.tail.sibling=null:a.sibling=null}}function ii(e,t,n){var a=t.pendingProps;switch(t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:case 17:return gr(t.type)&&yr(),null;case 3:return Os(),lr(pr),lr(dr),Xs(),(a=t.stateNode).pendingContext&&(a.context=a.pendingContext,a.pendingContext=null),null!==e&&null!==e.child||(Hs(t)?t.flags|=4:a.hydrate||(t.flags|=256)),Xo(t),null;case 5:Ms(t);var s=_s(As.current);if(n=t.type,null!==e&&null!=t.stateNode)Yo(e,t,n,a,s),e.ref!==t.ref&&(t.flags|=128);else{if(!a){if(null===t.stateNode)throw Error(o(166));return null}if(e=_s(Es.current),Hs(t)){a=t.stateNode,n=t.type;var i=t.memoizedProps;switch(a[Qa]=t,a[Ja]=i,n){case"dialog":Ra("cancel",a),Ra("close",a);break;case"iframe":case"object":case"embed":Ra("load",a);break;case"video":case"audio":for(e=0;e<Na.length;e++)Ra(Na[e],a);break;case"source":Ra("error",a);break;case"img":case"image":case"link":Ra("error",a),Ra("load",a);break;case"details":Ra("toggle",a);break;case"input":ee(a,i),Ra("invalid",a);break;case"select":a._wrapperState={wasMultiple:!!i.multiple},Ra("invalid",a);break;case"textarea":ce(a,i),Ra("invalid",a)}for(var l in Se(n,i),e=null,i)i.hasOwnProperty(l)&&(s=i[l],"children"===l?"string"===typeof s?a.textContent!==s&&(e=["children",s]):"number"===typeof s&&a.textContent!==""+s&&(e=["children",""+s]):c.hasOwnProperty(l)&&null!=s&&"onScroll"===l&&Ra("scroll",a));switch(n){case"input":Z(a),ae(a,i,!0);break;case"textarea":Z(a),ue(a);break;case"select":case"option":break;default:"function"===typeof i.onClick&&(a.onclick=Ba)}a=e,t.updateQueue=a,null!==a&&(t.flags|=4)}else{switch(l=9===s.nodeType?s:s.ownerDocument,e===he.html&&(e=de(n)),e===he.html?"script"===n?((e=l.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"===typeof a.is?e=l.createElement(n,{is:a.is}):(e=l.createElement(n),"select"===n&&(l=e,a.multiple?l.multiple=!0:a.size&&(l.size=a.size))):e=l.createElementNS(e,n),e[Qa]=t,e[Ja]=a,qo(e,t,!1,!1),t.stateNode=e,l=Ie(n,a),n){case"dialog":Ra("cancel",e),Ra("close",e),s=a;break;case"iframe":case"object":case"embed":Ra("load",e),s=a;break;case"video":case"audio":for(s=0;s<Na.length;s++)Ra(Na[s],e);s=a;break;case"source":Ra("error",e),s=a;break;case"img":case"image":case"link":Ra("error",e),Ra("load",e),s=a;break;case"details":Ra("toggle",e),s=a;break;case"input":ee(e,a),s=$(e,a),Ra("invalid",e);break;case"option":s=se(e,a);break;case"select":e._wrapperState={wasMultiple:!!a.multiple},s=r({},a,{value:void 0}),Ra("invalid",e);break;case"textarea":ce(e,a),s=ie(e,a),Ra("invalid",e);break;default:s=a}Se(n,s);var u=s;for(i in u)if(u.hasOwnProperty(i)){var h=u[i];"style"===i?we(e,h):"dangerouslySetInnerHTML"===i?null!=(h=h?h.__html:void 0)&&ge(e,h):"children"===i?"string"===typeof h?("textarea"!==n||""!==h)&&ye(e,h):"number"===typeof h&&ye(e,""+h):"suppressContentEditableWarning"!==i&&"suppressHydrationWarning"!==i&&"autoFocus"!==i&&(c.hasOwnProperty(i)?null!=h&&"onScroll"===i&&Ra("scroll",e):null!=h&&x(e,i,h,l))}switch(n){case"input":Z(e),ae(e,a,!1);break;case"textarea":Z(e),ue(e);break;case"option":null!=a.value&&e.setAttribute("value",""+X(a.value));break;case"select":e.multiple=!!a.multiple,null!=(i=a.value)?oe(e,!!a.multiple,i,!1):null!=a.defaultValue&&oe(e,!!a.multiple,a.defaultValue,!0);break;default:"function"===typeof s.onClick&&(e.onclick=Ba)}Va(n,a)&&(t.flags|=4)}null!==t.ref&&(t.flags|=128)}return null;case 6:if(e&&null!=t.stateNode)Zo(e,t,e.memoizedProps,a);else{if("string"!==typeof a&&null===t.stateNode)throw Error(o(166));n=_s(As.current),_s(Es.current),Hs(t)?(a=t.stateNode,n=t.memoizedProps,a[Qa]=t,a.nodeValue!==n&&(t.flags|=4)):((a=(9===n.nodeType?n:n.ownerDocument).createTextNode(a))[Qa]=t,t.stateNode=a)}return null;case 13:return lr(Ls),a=t.memoizedState,0!==(64&t.flags)?(t.lanes=n,t):(a=null!==a,n=!1,null===e?void 0!==t.memoizedProps.fallback&&Hs(t):n=null!==e.memoizedState,a&&!n&&0!==(2&t.mode)&&(null===e&&!0!==t.memoizedProps.unstable_avoidThisFallback||0!==(1&Ls.current)?0===zi&&(zi=3):(0!==zi&&3!==zi||(zi=4),null===Oi||0===(134217727&Ui)&&0===(134217727&Vi)||bc(Oi,Mi))),(a||n)&&(t.flags|=4),null);case 4:return Os(),Xo(t),null===e&&_a(t.stateNode.containerInfo),null;case 10:return ns(t),null;case 19:if(lr(Ls),null===(a=t.memoizedState))return null;if(i=0!==(64&t.flags),null===(l=a.rendering))if(i)oi(a,!1);else{if(0!==zi||null!==e&&0!==(64&e.flags))for(e=t.child;null!==e;){if(null!==(l=Ps(e))){for(t.flags|=64,oi(a,!1),null!==(i=l.updateQueue)&&(t.updateQueue=i,t.flags|=4),null===a.lastEffect&&(t.firstEffect=null),t.lastEffect=a.lastEffect,a=n,n=t.child;null!==n;)e=a,(i=n).flags&=2,i.nextEffect=null,i.firstEffect=null,i.lastEffect=null,null===(l=i.alternate)?(i.childLanes=0,i.lanes=e,i.child=null,i.memoizedProps=null,i.memoizedState=null,i.updateQueue=null,i.dependencies=null,i.stateNode=null):(i.childLanes=l.childLanes,i.lanes=l.lanes,i.child=l.child,i.memoizedProps=l.memoizedProps,i.memoizedState=l.memoizedState,i.updateQueue=l.updateQueue,i.type=l.type,e=l.dependencies,i.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return ur(Ls,1&Ls.current|2),t.child}e=e.sibling}null!==a.tail&&Vr()>Ki&&(t.flags|=64,i=!0,oi(a,!1),t.lanes=33554432)}else{if(!i)if(null!==(e=Ps(l))){if(t.flags|=64,i=!0,null!==(n=e.updateQueue)&&(t.updateQueue=n,t.flags|=4),oi(a,!0),null===a.tail&&"hidden"===a.tailMode&&!l.alternate&&!Ws)return null!==(t=t.lastEffect=a.lastEffect)&&(t.nextEffect=null),null}else 2*Vr()-a.renderingStartTime>Ki&&1073741824!==n&&(t.flags|=64,i=!0,oi(a,!1),t.lanes=33554432);a.isBackwards?(l.sibling=t.child,t.child=l):(null!==(n=a.last)?n.sibling=l:t.child=l,a.last=l)}return null!==a.tail?(n=a.tail,a.rendering=n,a.tail=n.sibling,a.lastEffect=t.lastEffect,a.renderingStartTime=Vr(),n.sibling=null,t=Ls.current,ur(Ls,i?1&t|2:1&t),n):null;case 23:case 24:return Sc(),null!==e&&null!==e.memoizedState!==(null!==t.memoizedState)&&"unstable-defer-without-hiding"!==a.mode&&(t.flags|=4),null}throw Error(o(156,t.tag))}function ci(e){switch(e.tag){case 1:gr(e.type)&&yr();var t=e.flags;return 4096&t?(e.flags=-4097&t|64,e):null;case 3:if(Os(),lr(pr),lr(dr),Xs(),0!==(64&(t=e.flags)))throw Error(o(285));return e.flags=-4097&t|64,e;case 5:return Ms(e),null;case 13:return lr(Ls),4096&(t=e.flags)?(e.flags=-4097&t|64,e):null;case 19:return lr(Ls),null;case 4:return Os(),null;case 10:return ns(e),null;case 23:case 24:return Sc(),null;default:return null}}function li(e,t){try{var n="",a=t;do{n+=K(a),a=a.return}while(a);var r=n}catch(s){r="\nError generating stack: "+s.message+"\n"+s.stack}return{value:e,source:t,stack:r}}function ui(e,t){try{console.error(t.value)}catch(n){setTimeout((function(){throw n}))}}qo=function(e,t){for(var n=t.child;null!==n;){if(5===n.tag||6===n.tag)e.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===t)break;for(;null===n.sibling;){if(null===n.return||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Xo=function(){},Yo=function(e,t,n,a){var s=e.memoizedProps;if(s!==a){e=t.stateNode,_s(Es.current);var o,i=null;switch(n){case"input":s=$(e,s),a=$(e,a),i=[];break;case"option":s=se(e,s),a=se(e,a),i=[];break;case"select":s=r({},s,{value:void 0}),a=r({},a,{value:void 0}),i=[];break;case"textarea":s=ie(e,s),a=ie(e,a),i=[];break;default:"function"!==typeof s.onClick&&"function"===typeof a.onClick&&(e.onclick=Ba)}for(h in Se(n,a),n=null,s)if(!a.hasOwnProperty(h)&&s.hasOwnProperty(h)&&null!=s[h])if("style"===h){var l=s[h];for(o in l)l.hasOwnProperty(o)&&(n||(n={}),n[o]="")}else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(c.hasOwnProperty(h)?i||(i=[]):(i=i||[]).push(h,null));for(h in a){var u=a[h];if(l=null!=s?s[h]:void 0,a.hasOwnProperty(h)&&u!==l&&(null!=u||null!=l))if("style"===h)if(l){for(o in l)!l.hasOwnProperty(o)||u&&u.hasOwnProperty(o)||(n||(n={}),n[o]="");for(o in u)u.hasOwnProperty(o)&&l[o]!==u[o]&&(n||(n={}),n[o]=u[o])}else n||(i||(i=[]),i.push(h,n)),n=u;else"dangerouslySetInnerHTML"===h?(u=u?u.__html:void 0,l=l?l.__html:void 0,null!=u&&l!==u&&(i=i||[]).push(h,u)):"children"===h?"string"!==typeof u&&"number"!==typeof u||(i=i||[]).push(h,""+u):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(c.hasOwnProperty(h)?(null!=u&&"onScroll"===h&&Ra("scroll",e),i||l===u||(i=[])):"object"===typeof u&&null!==u&&u.$$typeof===M?u.toString():(i=i||[]).push(h,u))}n&&(i=i||[]).push("style",n);var h=i;(t.updateQueue=h)&&(t.flags|=4)}},Zo=function(e,t,n,a){n!==a&&(t.flags|=4)};var hi="function"===typeof WeakMap?WeakMap:Map;function di(e,t,n){(n=ls(-1,n)).tag=3,n.payload={element:null};var a=t.value;return n.callback=function(){Zi||(Zi=!0,Qi=a),ui(0,t)},n}function pi(e,t,n){(n=ls(-1,n)).tag=3;var a=e.type.getDerivedStateFromError;if("function"===typeof a){var r=t.value;n.payload=function(){return ui(0,t),a(r)}}var s=e.stateNode;return null!==s&&"function"===typeof s.componentDidCatch&&(n.callback=function(){"function"!==typeof a&&(null===Ji?Ji=new Set([this]):Ji.add(this),ui(0,t));var e=t.stack;this.componentDidCatch(t.value,{componentStack:null!==e?e:""})}),n}var fi="function"===typeof WeakSet?WeakSet:Set;function mi(e){var t=e.ref;if(null!==t)if("function"===typeof t)try{t(null)}catch(n){Wc(e,n)}else t.current=null}function gi(e,t){switch(t.tag){case 0:case 11:case 15:case 22:case 5:case 6:case 4:case 17:return;case 1:if(256&t.flags&&null!==e){var n=e.memoizedProps,a=e.memoizedState;t=(e=t.stateNode).getSnapshotBeforeUpdate(t.elementType===t.type?n:Zr(t.type,n),a),e.__reactInternalSnapshotBeforeUpdate=t}return;case 3:return void(256&t.flags&&Ka(t.stateNode.containerInfo))}throw Error(o(163))}function yi(e,t,n){switch(n.tag){case 0:case 11:case 15:case 22:if(null!==(t=null!==(t=n.updateQueue)?t.lastEffect:null)){e=t=t.next;do{if(3===(3&e.tag)){var a=e.create;e.destroy=a()}e=e.next}while(e!==t)}if(null!==(t=null!==(t=n.updateQueue)?t.lastEffect:null)){e=t=t.next;do{var r=e;a=r.next,0!==(4&(r=r.tag))&&0!==(1&r)&&(Pc(n,e),Lc(n,e)),e=a}while(e!==t)}return;case 1:return e=n.stateNode,4&n.flags&&(null===t?e.componentDidMount():(a=n.elementType===n.type?t.memoizedProps:Zr(n.type,t.memoizedProps),e.componentDidUpdate(a,t.memoizedState,e.__reactInternalSnapshotBeforeUpdate))),void(null!==(t=n.updateQueue)&&ps(n,t,e));case 3:if(null!==(t=n.updateQueue)){if(e=null,null!==n.child)switch(n.child.tag){case 5:case 1:e=n.child.stateNode}ps(n,t,e)}return;case 5:return e=n.stateNode,void(null===t&&4&n.flags&&Va(n.type,n.memoizedProps)&&e.focus());case 6:case 4:case 12:case 19:case 17:case 20:case 21:case 23:case 24:return;case 13:return void(null===n.memoizedState&&(n=n.alternate,null!==n&&(n=n.memoizedState,null!==n&&(n=n.dehydrated,null!==n&&wt(n)))))}throw Error(o(163))}function bi(e,t){for(var n=e;;){if(5===n.tag){var a=n.stateNode;if(t)"function"===typeof(a=a.style).setProperty?a.setProperty("display","none","important"):a.display="none";else{a=n.stateNode;var r=n.memoizedProps.style;r=void 0!==r&&null!==r&&r.hasOwnProperty("display")?r.display:null,a.style.display=xe("display",r)}}else if(6===n.tag)n.stateNode.nodeValue=t?"":n.memoizedProps;else if((23!==n.tag&&24!==n.tag||null===n.memoizedState||n===e)&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===e)break;for(;null===n.sibling;){if(null===n.return||n.return===e)return;n=n.return}n.sibling.return=n.return,n=n.sibling}}function vi(e,t){if(Sr&&"function"===typeof Sr.onCommitFiberUnmount)try{Sr.onCommitFiberUnmount(kr,t)}catch(s){}switch(t.tag){case 0:case 11:case 14:case 15:case 22:if(null!==(e=t.updateQueue)&&null!==(e=e.lastEffect)){var n=e=e.next;do{var a=n,r=a.destroy;if(a=a.tag,void 0!==r)if(0!==(4&a))Pc(t,n);else{a=t;try{r()}catch(s){Wc(a,s)}}n=n.next}while(n!==e)}break;case 1:if(mi(t),"function"===typeof(e=t.stateNode).componentWillUnmount)try{e.props=t.memoizedProps,e.state=t.memoizedState,e.componentWillUnmount()}catch(s){Wc(t,s)}break;case 5:mi(t);break;case 4:Ni(e,t)}}function xi(e){e.alternate=null,e.child=null,e.dependencies=null,e.firstEffect=null,e.lastEffect=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.return=null,e.updateQueue=null}function wi(e){return 5===e.tag||3===e.tag||4===e.tag}function ki(e){e:{for(var t=e.return;null!==t;){if(wi(t))break e;t=t.return}throw Error(o(160))}var n=t;switch(t=n.stateNode,n.tag){case 5:var a=!1;break;case 3:case 4:t=t.containerInfo,a=!0;break;default:throw Error(o(161))}16&n.flags&&(ye(t,""),n.flags&=-17);e:t:for(n=e;;){for(;null===n.sibling;){if(null===n.return||wi(n.return)){n=null;break e}n=n.return}for(n.sibling.return=n.return,n=n.sibling;5!==n.tag&&6!==n.tag&&18!==n.tag;){if(2&n.flags)continue t;if(null===n.child||4===n.tag)continue t;n.child.return=n,n=n.child}if(!(2&n.flags)){n=n.stateNode;break e}}a?Si(e,n,t):Ii(e,n,t)}function Si(e,t,n){var a=e.tag,r=5===a||6===a;if(r)e=r?e.stateNode:e.stateNode.instance,t?8===n.nodeType?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(8===n.nodeType?(t=n.parentNode).insertBefore(e,n):(t=n).appendChild(e),null!==(n=n._reactRootContainer)&&void 0!==n||null!==t.onclick||(t.onclick=Ba));else if(4!==a&&null!==(e=e.child))for(Si(e,t,n),e=e.sibling;null!==e;)Si(e,t,n),e=e.sibling}function Ii(e,t,n){var a=e.tag,r=5===a||6===a;if(r)e=r?e.stateNode:e.stateNode.instance,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==a&&null!==(e=e.child))for(Ii(e,t,n),e=e.sibling;null!==e;)Ii(e,t,n),e=e.sibling}function Ni(e,t){for(var n,a,r=t,s=!1;;){if(!s){s=r.return;e:for(;;){if(null===s)throw Error(o(160));switch(n=s.stateNode,s.tag){case 5:a=!1;break e;case 3:case 4:n=n.containerInfo,a=!0;break e}s=s.return}s=!0}if(5===r.tag||6===r.tag){e:for(var i=e,c=r,l=c;;)if(vi(i,l),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===c)break e;for(;null===l.sibling;){if(null===l.return||l.return===c)break e;l=l.return}l.sibling.return=l.return,l=l.sibling}a?(i=n,c=r.stateNode,8===i.nodeType?i.parentNode.removeChild(c):i.removeChild(c)):n.removeChild(r.stateNode)}else if(4===r.tag){if(null!==r.child){n=r.stateNode.containerInfo,a=!0,r.child.return=r,r=r.child;continue}}else if(vi(e,r),null!==r.child){r.child.return=r,r=r.child;continue}if(r===t)break;for(;null===r.sibling;){if(null===r.return||r.return===t)return;4===(r=r.return).tag&&(s=!1)}r.sibling.return=r.return,r=r.sibling}}function Ci(e,t){switch(t.tag){case 0:case 11:case 14:case 15:case 22:var n=t.updateQueue;if(null!==(n=null!==n?n.lastEffect:null)){var a=n=n.next;do{3===(3&a.tag)&&(e=a.destroy,a.destroy=void 0,void 0!==e&&e()),a=a.next}while(a!==n)}return;case 1:case 12:case 17:return;case 5:if(null!=(n=t.stateNode)){a=t.memoizedProps;var r=null!==e?e.memoizedProps:a;e=t.type;var s=t.updateQueue;if(t.updateQueue=null,null!==s){for(n[Ja]=a,"input"===e&&"radio"===a.type&&null!=a.name&&te(n,a),Ie(e,r),t=Ie(e,a),r=0;r<s.length;r+=2){var i=s[r],c=s[r+1];"style"===i?we(n,c):"dangerouslySetInnerHTML"===i?ge(n,c):"children"===i?ye(n,c):x(n,i,c,t)}switch(e){case"input":ne(n,a);break;case"textarea":le(n,a);break;case"select":e=n._wrapperState.wasMultiple,n._wrapperState.wasMultiple=!!a.multiple,null!=(s=a.value)?oe(n,!!a.multiple,s,!1):e!==!!a.multiple&&(null!=a.defaultValue?oe(n,!!a.multiple,a.defaultValue,!0):oe(n,!!a.multiple,a.multiple?[]:"",!1))}}}return;case 6:if(null===t.stateNode)throw Error(o(162));return void(t.stateNode.nodeValue=t.memoizedProps);case 3:return void((n=t.stateNode).hydrate&&(n.hydrate=!1,wt(n.containerInfo)));case 13:return null!==t.memoizedState&&(Hi=Vr(),bi(t.child,!0)),void Ti(t);case 19:return void Ti(t);case 23:case 24:return void bi(t,null!==t.memoizedState)}throw Error(o(163))}function Ti(e){var t=e.updateQueue;if(null!==t){e.updateQueue=null;var n=e.stateNode;null===n&&(n=e.stateNode=new fi),t.forEach((function(t){var a=Vc.bind(null,e,t);n.has(t)||(n.add(t),t.then(a,a))}))}}function Ei(e,t){return null!==e&&(null===(e=e.memoizedState)||null!==e.dehydrated)&&(null!==(t=t.memoizedState)&&null===t.dehydrated)}var Ri=Math.ceil,Ai=w.ReactCurrentDispatcher,_i=w.ReactCurrentOwner,Fi=0,Oi=null,Di=null,Mi=0,Li=0,Pi=cr(0),zi=0,Bi=null,Wi=0,Ui=0,Vi=0,Gi=0,ji=null,Hi=0,Ki=1/0;function qi(){Ki=Vr()+500}var Xi,Yi=null,Zi=!1,Qi=null,Ji=null,$i=!1,ec=null,tc=90,nc=[],ac=[],rc=null,sc=0,oc=null,ic=-1,cc=0,lc=0,uc=null,hc=!1;function dc(){return 0!==(48&Fi)?Vr():-1!==ic?ic:ic=Vr()}function pc(e){if(0===(2&(e=e.mode)))return 1;if(0===(4&e))return 99===Gr()?1:2;if(0===cc&&(cc=Wi),0!==Yr.transition){0!==lc&&(lc=null!==ji?ji.pendingLanes:0),e=cc;var t=4186112&~lc;return 0===(t&=-t)&&(0===(t=(e=4186112&~e)&-e)&&(t=8192)),t}return e=Gr(),0!==(4&Fi)&&98===e?e=Bt(12,cc):e=Bt(e=function(e){switch(e){case 99:return 15;case 98:return 10;case 97:case 96:return 8;case 95:return 2;default:return 0}}(e),cc),e}function fc(e,t,n){if(50<sc)throw sc=0,oc=null,Error(o(185));if(null===(e=mc(e,t)))return null;Vt(e,t,n),e===Oi&&(Vi|=t,4===zi&&bc(e,Mi));var a=Gr();1===t?0!==(8&Fi)&&0===(48&Fi)?vc(e):(gc(e,n),0===Fi&&(qi(),qr())):(0===(4&Fi)||98!==a&&99!==a||(null===rc?rc=new Set([e]):rc.add(e)),gc(e,n)),ji=e}function mc(e,t){e.lanes|=t;var n=e.alternate;for(null!==n&&(n.lanes|=t),n=e,e=e.return;null!==e;)e.childLanes|=t,null!==(n=e.alternate)&&(n.childLanes|=t),n=e,e=e.return;return 3===n.tag?n.stateNode:null}function gc(e,t){for(var n=e.callbackNode,a=e.suspendedLanes,r=e.pingedLanes,s=e.expirationTimes,i=e.pendingLanes;0<i;){var c=31-Gt(i),l=1<<c,u=s[c];if(-1===u){if(0===(l&a)||0!==(l&r)){u=t,Lt(l);var h=Mt;s[c]=10<=h?u+250:6<=h?u+5e3:-1}}else u<=t&&(e.expiredLanes|=l);i&=~l}if(a=Pt(e,e===Oi?Mi:0),t=Mt,0===a)null!==n&&(n!==Lr&&Cr(n),e.callbackNode=null,e.callbackPriority=0);else{if(null!==n){if(e.callbackPriority===t)return;n!==Lr&&Cr(n)}15===t?(n=vc.bind(null,e),null===zr?(zr=[n],Br=Nr(_r,Xr)):zr.push(n),n=Lr):14===t?n=Kr(99,vc.bind(null,e)):(n=function(e){switch(e){case 15:case 14:return 99;case 13:case 12:case 11:case 10:return 98;case 9:case 8:case 7:case 6:case 4:case 5:return 97;case 3:case 2:case 1:return 95;case 0:return 90;default:throw Error(o(358,e))}}(t),n=Kr(n,yc.bind(null,e))),e.callbackPriority=t,e.callbackNode=n}}function yc(e){if(ic=-1,lc=cc=0,0!==(48&Fi))throw Error(o(327));var t=e.callbackNode;if(Mc()&&e.callbackNode!==t)return null;var n=Pt(e,e===Oi?Mi:0);if(0===n)return null;var a=n,r=Fi;Fi|=16;var s=Cc();for(Oi===e&&Mi===a||(qi(),Ic(e,a));;)try{Rc();break}catch(c){Nc(e,c)}if(ts(),Ai.current=s,Fi=r,null!==Di?a=0:(Oi=null,Mi=0,a=zi),0!==(Wi&Vi))Ic(e,0);else if(0!==a){if(2===a&&(Fi|=64,e.hydrate&&(e.hydrate=!1,Ka(e.containerInfo)),0!==(n=zt(e))&&(a=Tc(e,n))),1===a)throw t=Bi,Ic(e,0),bc(e,n),gc(e,Vr()),t;switch(e.finishedWork=e.current.alternate,e.finishedLanes=n,a){case 0:case 1:throw Error(o(345));case 2:case 5:Fc(e);break;case 3:if(bc(e,n),(62914560&n)===n&&10<(a=Hi+500-Vr())){if(0!==Pt(e,0))break;if(((r=e.suspendedLanes)&n)!==n){dc(),e.pingedLanes|=e.suspendedLanes&r;break}e.timeoutHandle=ja(Fc.bind(null,e),a);break}Fc(e);break;case 4:if(bc(e,n),(4186112&n)===n)break;for(a=e.eventTimes,r=-1;0<n;){var i=31-Gt(n);s=1<<i,(i=a[i])>r&&(r=i),n&=~s}if(n=r,10<(n=(120>(n=Vr()-n)?120:480>n?480:1080>n?1080:1920>n?1920:3e3>n?3e3:4320>n?4320:1960*Ri(n/1960))-n)){e.timeoutHandle=ja(Fc.bind(null,e),n);break}Fc(e);break;default:throw Error(o(329))}}return gc(e,Vr()),e.callbackNode===t?yc.bind(null,e):null}function bc(e,t){for(t&=~Gi,t&=~Vi,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-Gt(t),a=1<<n;e[n]=-1,t&=~a}}function vc(e){if(0!==(48&Fi))throw Error(o(327));if(Mc(),e===Oi&&0!==(e.expiredLanes&Mi)){var t=Mi,n=Tc(e,t);0!==(Wi&Vi)&&(n=Tc(e,t=Pt(e,t)))}else n=Tc(e,t=Pt(e,0));if(0!==e.tag&&2===n&&(Fi|=64,e.hydrate&&(e.hydrate=!1,Ka(e.containerInfo)),0!==(t=zt(e))&&(n=Tc(e,t))),1===n)throw n=Bi,Ic(e,0),bc(e,t),gc(e,Vr()),n;return e.finishedWork=e.current.alternate,e.finishedLanes=t,Fc(e),gc(e,Vr()),null}function xc(e,t){var n=Fi;Fi|=1;try{return e(t)}finally{0===(Fi=n)&&(qi(),qr())}}function wc(e,t){var n=Fi;Fi&=-2,Fi|=8;try{return e(t)}finally{0===(Fi=n)&&(qi(),qr())}}function kc(e,t){ur(Pi,Li),Li|=t,Wi|=t}function Sc(){Li=Pi.current,lr(Pi)}function Ic(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(-1!==n&&(e.timeoutHandle=-1,Ha(n)),null!==Di)for(n=Di.return;null!==n;){var a=n;switch(a.tag){case 1:null!==(a=a.type.childContextTypes)&&void 0!==a&&yr();break;case 3:Os(),lr(pr),lr(dr),Xs();break;case 5:Ms(a);break;case 4:Os();break;case 13:case 19:lr(Ls);break;case 10:ns(a);break;case 23:case 24:Sc()}n=n.return}Oi=e,Di=Kc(e.current,null),Mi=Li=Wi=t,zi=0,Bi=null,Gi=Vi=Ui=0}function Nc(e,t){for(;;){var n=Di;try{if(ts(),Ys.current=_o,to){for(var a=Js.memoizedState;null!==a;){var r=a.queue;null!==r&&(r.pending=null),a=a.next}to=!1}if(Qs=0,eo=$s=Js=null,no=!1,_i.current=null,null===n||null===n.return){zi=1,Bi=t,Di=null;break}e:{var s=e,o=n.return,i=n,c=t;if(t=Mi,i.flags|=2048,i.firstEffect=i.lastEffect=null,null!==c&&"object"===typeof c&&"function"===typeof c.then){var l=c;if(0===(2&i.mode)){var u=i.alternate;u?(i.updateQueue=u.updateQueue,i.memoizedState=u.memoizedState,i.lanes=u.lanes):(i.updateQueue=null,i.memoizedState=null)}var h=0!==(1&Ls.current),d=o;do{var p;if(p=13===d.tag){var f=d.memoizedState;if(null!==f)p=null!==f.dehydrated;else{var m=d.memoizedProps;p=void 0!==m.fallback&&(!0!==m.unstable_avoidThisFallback||!h)}}if(p){var g=d.updateQueue;if(null===g){var y=new Set;y.add(l),d.updateQueue=y}else g.add(l);if(0===(2&d.mode)){if(d.flags|=64,i.flags|=16384,i.flags&=-2981,1===i.tag)if(null===i.alternate)i.tag=17;else{var b=ls(-1,1);b.tag=2,us(i,b)}i.lanes|=1;break e}c=void 0,i=t;var v=s.pingCache;if(null===v?(v=s.pingCache=new hi,c=new Set,v.set(l,c)):void 0===(c=v.get(l))&&(c=new Set,v.set(l,c)),!c.has(i)){c.add(i);var x=Uc.bind(null,s,l,i);l.then(x,x)}d.flags|=4096,d.lanes=t;break e}d=d.return}while(null!==d);c=Error((q(i.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.")}5!==zi&&(zi=2),c=li(c,i),d=o;do{switch(d.tag){case 3:s=c,d.flags|=4096,t&=-t,d.lanes|=t,hs(d,di(0,s,t));break e;case 1:s=c;var w=d.type,k=d.stateNode;if(0===(64&d.flags)&&("function"===typeof w.getDerivedStateFromError||null!==k&&"function"===typeof k.componentDidCatch&&(null===Ji||!Ji.has(k)))){d.flags|=4096,t&=-t,d.lanes|=t,hs(d,pi(d,s,t));break e}}d=d.return}while(null!==d)}_c(n)}catch(S){t=S,Di===n&&null!==n&&(Di=n=n.return);continue}break}}function Cc(){var e=Ai.current;return Ai.current=_o,null===e?_o:e}function Tc(e,t){var n=Fi;Fi|=16;var a=Cc();for(Oi===e&&Mi===t||Ic(e,t);;)try{Ec();break}catch(r){Nc(e,r)}if(ts(),Fi=n,Ai.current=a,null!==Di)throw Error(o(261));return Oi=null,Mi=0,zi}function Ec(){for(;null!==Di;)Ac(Di)}function Rc(){for(;null!==Di&&!Tr();)Ac(Di)}function Ac(e){var t=Xi(e.alternate,e,Li);e.memoizedProps=e.pendingProps,null===t?_c(e):Di=t,_i.current=null}function _c(e){var t=e;do{var n=t.alternate;if(e=t.return,0===(2048&t.flags)){if(null!==(n=ii(n,t,Li)))return void(Di=n);if(24!==(n=t).tag&&23!==n.tag||null===n.memoizedState||0!==(1073741824&Li)||0===(4&n.mode)){for(var a=0,r=n.child;null!==r;)a|=r.lanes|r.childLanes,r=r.sibling;n.childLanes=a}null!==e&&0===(2048&e.flags)&&(null===e.firstEffect&&(e.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==e.lastEffect&&(e.lastEffect.nextEffect=t.firstEffect),e.lastEffect=t.lastEffect),1<t.flags&&(null!==e.lastEffect?e.lastEffect.nextEffect=t:e.firstEffect=t,e.lastEffect=t))}else{if(null!==(n=ci(t)))return n.flags&=2047,void(Di=n);null!==e&&(e.firstEffect=e.lastEffect=null,e.flags|=2048)}if(null!==(t=t.sibling))return void(Di=t);Di=t=e}while(null!==t);0===zi&&(zi=5)}function Fc(e){var t=Gr();return Hr(99,Oc.bind(null,e,t)),null}function Oc(e,t){do{Mc()}while(null!==ec);if(0!==(48&Fi))throw Error(o(327));var n=e.finishedWork;if(null===n)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(o(177));e.callbackNode=null;var a=n.lanes|n.childLanes,r=a,s=e.pendingLanes&~r;e.pendingLanes=r,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=r,e.mutableReadLanes&=r,e.entangledLanes&=r,r=e.entanglements;for(var i=e.eventTimes,c=e.expirationTimes;0<s;){var l=31-Gt(s),u=1<<l;r[l]=0,i[l]=-1,c[l]=-1,s&=~u}if(null!==rc&&0===(24&a)&&rc.has(e)&&rc.delete(e),e===Oi&&(Di=Oi=null,Mi=0),1<n.flags?null!==n.lastEffect?(n.lastEffect.nextEffect=n,a=n.firstEffect):a=n:a=n.firstEffect,null!==a){if(r=Fi,Fi|=32,_i.current=null,Wa=Xt,ga(i=ma())){if("selectionStart"in i)c={start:i.selectionStart,end:i.selectionEnd};else e:if(c=(c=i.ownerDocument)&&c.defaultView||window,(u=c.getSelection&&c.getSelection())&&0!==u.rangeCount){c=u.anchorNode,s=u.anchorOffset,l=u.focusNode,u=u.focusOffset;try{c.nodeType,l.nodeType}catch(C){c=null;break e}var h=0,d=-1,p=-1,f=0,m=0,g=i,y=null;t:for(;;){for(var b;g!==c||0!==s&&3!==g.nodeType||(d=h+s),g!==l||0!==u&&3!==g.nodeType||(p=h+u),3===g.nodeType&&(h+=g.nodeValue.length),null!==(b=g.firstChild);)y=g,g=b;for(;;){if(g===i)break t;if(y===c&&++f===s&&(d=h),y===l&&++m===u&&(p=h),null!==(b=g.nextSibling))break;y=(g=y).parentNode}g=b}c=-1===d||-1===p?null:{start:d,end:p}}else c=null;c=c||{start:0,end:0}}else c=null;Ua={focusedElem:i,selectionRange:c},Xt=!1,uc=null,hc=!1,Yi=a;do{try{Dc()}catch(C){if(null===Yi)throw Error(o(330));Wc(Yi,C),Yi=Yi.nextEffect}}while(null!==Yi);uc=null,Yi=a;do{try{for(i=e;null!==Yi;){var v=Yi.flags;if(16&v&&ye(Yi.stateNode,""),128&v){var x=Yi.alternate;if(null!==x){var w=x.ref;null!==w&&("function"===typeof w?w(null):w.current=null)}}switch(1038&v){case 2:ki(Yi),Yi.flags&=-3;break;case 6:ki(Yi),Yi.flags&=-3,Ci(Yi.alternate,Yi);break;case 1024:Yi.flags&=-1025;break;case 1028:Yi.flags&=-1025,Ci(Yi.alternate,Yi);break;case 4:Ci(Yi.alternate,Yi);break;case 8:Ni(i,c=Yi);var k=c.alternate;xi(c),null!==k&&xi(k)}Yi=Yi.nextEffect}}catch(C){if(null===Yi)throw Error(o(330));Wc(Yi,C),Yi=Yi.nextEffect}}while(null!==Yi);if(w=Ua,x=ma(),v=w.focusedElem,i=w.selectionRange,x!==v&&v&&v.ownerDocument&&fa(v.ownerDocument.documentElement,v)){null!==i&&ga(v)&&(x=i.start,void 0===(w=i.end)&&(w=x),"selectionStart"in v?(v.selectionStart=x,v.selectionEnd=Math.min(w,v.value.length)):(w=(x=v.ownerDocument||document)&&x.defaultView||window).getSelection&&(w=w.getSelection(),c=v.textContent.length,k=Math.min(i.start,c),i=void 0===i.end?k:Math.min(i.end,c),!w.extend&&k>i&&(c=i,i=k,k=c),c=pa(v,k),s=pa(v,i),c&&s&&(1!==w.rangeCount||w.anchorNode!==c.node||w.anchorOffset!==c.offset||w.focusNode!==s.node||w.focusOffset!==s.offset)&&((x=x.createRange()).setStart(c.node,c.offset),w.removeAllRanges(),k>i?(w.addRange(x),w.extend(s.node,s.offset)):(x.setEnd(s.node,s.offset),w.addRange(x))))),x=[];for(w=v;w=w.parentNode;)1===w.nodeType&&x.push({element:w,left:w.scrollLeft,top:w.scrollTop});for("function"===typeof v.focus&&v.focus(),v=0;v<x.length;v++)(w=x[v]).element.scrollLeft=w.left,w.element.scrollTop=w.top}Xt=!!Wa,Ua=Wa=null,e.current=n,Yi=a;do{try{for(v=e;null!==Yi;){var S=Yi.flags;if(36&S&&yi(v,Yi.alternate,Yi),128&S){x=void 0;var I=Yi.ref;if(null!==I){var N=Yi.stateNode;Yi.tag,x=N,"function"===typeof I?I(x):I.current=x}}Yi=Yi.nextEffect}}catch(C){if(null===Yi)throw Error(o(330));Wc(Yi,C),Yi=Yi.nextEffect}}while(null!==Yi);Yi=null,Pr(),Fi=r}else e.current=n;if($i)$i=!1,ec=e,tc=t;else for(Yi=a;null!==Yi;)t=Yi.nextEffect,Yi.nextEffect=null,8&Yi.flags&&((S=Yi).sibling=null,S.stateNode=null),Yi=t;if(0===(a=e.pendingLanes)&&(Ji=null),1===a?e===oc?sc++:(sc=0,oc=e):sc=0,n=n.stateNode,Sr&&"function"===typeof Sr.onCommitFiberRoot)try{Sr.onCommitFiberRoot(kr,n,void 0,64===(64&n.current.flags))}catch(C){}if(gc(e,Vr()),Zi)throw Zi=!1,e=Qi,Qi=null,e;return 0!==(8&Fi)||qr(),null}function Dc(){for(;null!==Yi;){var e=Yi.alternate;hc||null===uc||(0!==(8&Yi.flags)?$e(Yi,uc)&&(hc=!0):13===Yi.tag&&Ei(e,Yi)&&$e(Yi,uc)&&(hc=!0));var t=Yi.flags;0!==(256&t)&&gi(e,Yi),0===(512&t)||$i||($i=!0,Kr(97,(function(){return Mc(),null}))),Yi=Yi.nextEffect}}function Mc(){if(90!==tc){var e=97<tc?97:tc;return tc=90,Hr(e,zc)}return!1}function Lc(e,t){nc.push(t,e),$i||($i=!0,Kr(97,(function(){return Mc(),null})))}function Pc(e,t){ac.push(t,e),$i||($i=!0,Kr(97,(function(){return Mc(),null})))}function zc(){if(null===ec)return!1;var e=ec;if(ec=null,0!==(48&Fi))throw Error(o(331));var t=Fi;Fi|=32;var n=ac;ac=[];for(var a=0;a<n.length;a+=2){var r=n[a],s=n[a+1],i=r.destroy;if(r.destroy=void 0,"function"===typeof i)try{i()}catch(l){if(null===s)throw Error(o(330));Wc(s,l)}}for(n=nc,nc=[],a=0;a<n.length;a+=2){r=n[a],s=n[a+1];try{var c=r.create;r.destroy=c()}catch(l){if(null===s)throw Error(o(330));Wc(s,l)}}for(c=e.current.firstEffect;null!==c;)e=c.nextEffect,c.nextEffect=null,8&c.flags&&(c.sibling=null,c.stateNode=null),c=e;return Fi=t,qr(),!0}function Bc(e,t,n){us(e,t=di(0,t=li(n,t),1)),t=dc(),null!==(e=mc(e,1))&&(Vt(e,1,t),gc(e,t))}function Wc(e,t){if(3===e.tag)Bc(e,e,t);else for(var n=e.return;null!==n;){if(3===n.tag){Bc(n,e,t);break}if(1===n.tag){var a=n.stateNode;if("function"===typeof n.type.getDerivedStateFromError||"function"===typeof a.componentDidCatch&&(null===Ji||!Ji.has(a))){var r=pi(n,e=li(t,e),1);if(us(n,r),r=dc(),null!==(n=mc(n,1)))Vt(n,1,r),gc(n,r);else if("function"===typeof a.componentDidCatch&&(null===Ji||!Ji.has(a)))try{a.componentDidCatch(t,e)}catch(s){}break}}n=n.return}}function Uc(e,t,n){var a=e.pingCache;null!==a&&a.delete(t),t=dc(),e.pingedLanes|=e.suspendedLanes&n,Oi===e&&(Mi&n)===n&&(4===zi||3===zi&&(62914560&Mi)===Mi&&500>Vr()-Hi?Ic(e,0):Gi|=n),gc(e,t)}function Vc(e,t){var n=e.stateNode;null!==n&&n.delete(t),0===(t=0)&&(0===(2&(t=e.mode))?t=1:0===(4&t)?t=99===Gr()?1:2:(0===cc&&(cc=Wi),0===(t=Wt(62914560&~cc))&&(t=4194304))),n=dc(),null!==(e=mc(e,t))&&(Vt(e,t,n),gc(e,n))}function Gc(e,t,n,a){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=a,this.flags=0,this.lastEffect=this.firstEffect=this.nextEffect=null,this.childLanes=this.lanes=0,this.alternate=null}function jc(e,t,n,a){return new Gc(e,t,n,a)}function Hc(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Kc(e,t){var n=e.alternate;return null===n?((n=jc(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.nextEffect=null,n.firstEffect=null,n.lastEffect=null),n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function qc(e,t,n,a,r,s){var i=2;if(a=e,"function"===typeof e)Hc(e)&&(i=1);else if("string"===typeof e)i=5;else e:switch(e){case I:return Xc(n.children,r,s,t);case L:i=8,r|=16;break;case N:i=8,r|=1;break;case C:return(e=jc(12,n,t,8|r)).elementType=C,e.type=C,e.lanes=s,e;case A:return(e=jc(13,n,t,r)).type=A,e.elementType=A,e.lanes=s,e;case _:return(e=jc(19,n,t,r)).elementType=_,e.lanes=s,e;case P:return Yc(n,r,s,t);case z:return(e=jc(24,n,t,r)).elementType=z,e.lanes=s,e;default:if("object"===typeof e&&null!==e)switch(e.$$typeof){case T:i=10;break e;case E:i=9;break e;case R:i=11;break e;case F:i=14;break e;case O:i=16,a=null;break e;case D:i=22;break e}throw Error(o(130,null==e?e:typeof e,""))}return(t=jc(i,n,t,r)).elementType=e,t.type=a,t.lanes=s,t}function Xc(e,t,n,a){return(e=jc(7,e,a,t)).lanes=n,e}function Yc(e,t,n,a){return(e=jc(23,e,a,t)).elementType=P,e.lanes=n,e}function Zc(e,t,n){return(e=jc(6,e,null,t)).lanes=n,e}function Qc(e,t,n){return(t=jc(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function Jc(e,t,n){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.pendingContext=this.context=null,this.hydrate=n,this.callbackNode=null,this.callbackPriority=0,this.eventTimes=Ut(0),this.expirationTimes=Ut(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Ut(0),this.mutableSourceEagerHydrationData=null}function $c(e,t,n,a){var r=t.current,s=dc(),i=pc(r);e:if(n){t:{if(Ye(n=n._reactInternals)!==n||1!==n.tag)throw Error(o(170));var c=n;do{switch(c.tag){case 3:c=c.stateNode.context;break t;case 1:if(gr(c.type)){c=c.stateNode.__reactInternalMemoizedMergedChildContext;break t}}c=c.return}while(null!==c);throw Error(o(171))}if(1===n.tag){var l=n.type;if(gr(l)){n=vr(n,l,c);break e}}n=c}else n=hr;return null===t.context?t.context=n:t.pendingContext=n,(t=ls(s,i)).payload={element:e},null!==(a=void 0===a?null:a)&&(t.callback=a),us(r,t),fc(r,i,s),i}function el(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function tl(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function nl(e,t){tl(e,t),(e=e.alternate)&&tl(e,t)}function al(e,t,n){var a=null!=n&&null!=n.hydrationOptions&&n.hydrationOptions.mutableSources||null;if(n=new Jc(e,t,null!=n&&!0===n.hydrate),t=jc(3,null,null,2===t?7:1===t?3:0),n.current=t,t.stateNode=n,is(t),e[$a]=n.current,_a(8===e.nodeType?e.parentNode:e),a)for(e=0;e<a.length;e++){var r=(t=a[e])._getVersion;r=r(t._source),null==n.mutableSourceEagerHydrationData?n.mutableSourceEagerHydrationData=[t,r]:n.mutableSourceEagerHydrationData.push(t,r)}this._internalRoot=n}function rl(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function sl(e,t,n,a,r){var s=n._reactRootContainer;if(s){var o=s._internalRoot;if("function"===typeof r){var i=r;r=function(){var e=el(o);i.call(e)}}$c(t,o,e,r)}else{if(s=n._reactRootContainer=function(e,t){if(t||(t=!(!(t=e?9===e.nodeType?e.documentElement:e.firstChild:null)||1!==t.nodeType||!t.hasAttribute("data-reactroot"))),!t)for(var n;n=e.lastChild;)e.removeChild(n);return new al(e,0,t?{hydrate:!0}:void 0)}(n,a),o=s._internalRoot,"function"===typeof r){var c=r;r=function(){var e=el(o);c.call(e)}}wc((function(){$c(t,o,e,r)}))}return el(o)}function ol(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!rl(t))throw Error(o(200));return function(e,t,n){var a=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:S,key:null==a?null:""+a,children:e,containerInfo:t,implementation:n}}(e,t,null,n)}Xi=function(e,t,n){var a=t.lanes;if(null!==e)if(e.memoizedProps!==t.pendingProps||pr.current)Lo=!0;else{if(0===(n&a)){switch(Lo=!1,t.tag){case 3:Ko(t),Ks();break;case 5:Ds(t);break;case 1:gr(t.type)&&xr(t);break;case 4:Fs(t,t.stateNode.containerInfo);break;case 10:a=t.memoizedProps.value;var r=t.type._context;ur(Qr,r._currentValue),r._currentValue=a;break;case 13:if(null!==t.memoizedState)return 0!==(n&t.child.childLanes)?Jo(e,t,n):(ur(Ls,1&Ls.current),null!==(t=si(e,t,n))?t.sibling:null);ur(Ls,1&Ls.current);break;case 19:if(a=0!==(n&t.childLanes),0!==(64&e.flags)){if(a)return ri(e,t,n);t.flags|=64}if(null!==(r=t.memoizedState)&&(r.rendering=null,r.tail=null,r.lastEffect=null),ur(Ls,Ls.current),a)break;return null;case 23:case 24:return t.lanes=0,Uo(e,t,n)}return si(e,t,n)}Lo=0!==(16384&e.flags)}else Lo=!1;switch(t.lanes=0,t.tag){case 2:if(a=t.type,null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2),e=t.pendingProps,r=mr(t,dr.current),rs(t,n),r=so(null,t,a,e,r,n),t.flags|=1,"object"===typeof r&&null!==r&&"function"===typeof r.render&&void 0===r.$$typeof){if(t.tag=1,t.memoizedState=null,t.updateQueue=null,gr(a)){var s=!0;xr(t)}else s=!1;t.memoizedState=null!==r.state&&void 0!==r.state?r.state:null,is(t);var i=a.getDerivedStateFromProps;"function"===typeof i&&ms(t,a,i,e),r.updater=gs,t.stateNode=r,r._reactInternals=t,xs(t,a,e,n),t=Ho(null,t,a,!0,s,n)}else t.tag=0,Po(null,t,r,n),t=t.child;return t;case 16:r=t.elementType;e:{switch(null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2),e=t.pendingProps,r=(s=r._init)(r._payload),t.type=r,s=t.tag=function(e){if("function"===typeof e)return Hc(e)?1:0;if(void 0!==e&&null!==e){if((e=e.$$typeof)===R)return 11;if(e===F)return 14}return 2}(r),e=Zr(r,e),s){case 0:t=Go(null,t,r,e,n);break e;case 1:t=jo(null,t,r,e,n);break e;case 11:t=zo(null,t,r,e,n);break e;case 14:t=Bo(null,t,r,Zr(r.type,e),a,n);break e}throw Error(o(306,r,""))}return t;case 0:return a=t.type,r=t.pendingProps,Go(e,t,a,r=t.elementType===a?r:Zr(a,r),n);case 1:return a=t.type,r=t.pendingProps,jo(e,t,a,r=t.elementType===a?r:Zr(a,r),n);case 3:if(Ko(t),a=t.updateQueue,null===e||null===a)throw Error(o(282));if(a=t.pendingProps,r=null!==(r=t.memoizedState)?r.element:null,cs(e,t),ds(t,a,null,n),(a=t.memoizedState.element)===r)Ks(),t=si(e,t,n);else{if((s=(r=t.stateNode).hydrate)&&(Bs=qa(t.stateNode.containerInfo.firstChild),zs=t,s=Ws=!0),s){if(null!=(e=r.mutableSourceEagerHydrationData))for(r=0;r<e.length;r+=2)(s=e[r])._workInProgressVersionPrimary=e[r+1],qs.push(s);for(n=Cs(t,null,a,n),t.child=n;n;)n.flags=-3&n.flags|1024,n=n.sibling}else Po(e,t,a,n),Ks();t=t.child}return t;case 5:return Ds(t),null===e&&Gs(t),a=t.type,r=t.pendingProps,s=null!==e?e.memoizedProps:null,i=r.children,Ga(a,r)?i=null:null!==s&&Ga(a,s)&&(t.flags|=16),Vo(e,t),Po(e,t,i,n),t.child;case 6:return null===e&&Gs(t),null;case 13:return Jo(e,t,n);case 4:return Fs(t,t.stateNode.containerInfo),a=t.pendingProps,null===e?t.child=Ns(t,null,a,n):Po(e,t,a,n),t.child;case 11:return a=t.type,r=t.pendingProps,zo(e,t,a,r=t.elementType===a?r:Zr(a,r),n);case 7:return Po(e,t,t.pendingProps,n),t.child;case 8:case 12:return Po(e,t,t.pendingProps.children,n),t.child;case 10:e:{a=t.type._context,r=t.pendingProps,i=t.memoizedProps,s=r.value;var c=t.type._context;if(ur(Qr,c._currentValue),c._currentValue=s,null!==i)if(c=i.value,0===(s=la(c,s)?0:0|("function"===typeof a._calculateChangedBits?a._calculateChangedBits(c,s):1073741823))){if(i.children===r.children&&!pr.current){t=si(e,t,n);break e}}else for(null!==(c=t.child)&&(c.return=t);null!==c;){var l=c.dependencies;if(null!==l){i=c.child;for(var u=l.firstContext;null!==u;){if(u.context===a&&0!==(u.observedBits&s)){1===c.tag&&((u=ls(-1,n&-n)).tag=2,us(c,u)),c.lanes|=n,null!==(u=c.alternate)&&(u.lanes|=n),as(c.return,n),l.lanes|=n;break}u=u.next}}else i=10===c.tag&&c.type===t.type?null:c.child;if(null!==i)i.return=c;else for(i=c;null!==i;){if(i===t){i=null;break}if(null!==(c=i.sibling)){c.return=i.return,i=c;break}i=i.return}c=i}Po(e,t,r.children,n),t=t.child}return t;case 9:return r=t.type,a=(s=t.pendingProps).children,rs(t,n),a=a(r=ss(r,s.unstable_observedBits)),t.flags|=1,Po(e,t,a,n),t.child;case 14:return s=Zr(r=t.type,t.pendingProps),Bo(e,t,r,s=Zr(r.type,s),a,n);case 15:return Wo(e,t,t.type,t.pendingProps,a,n);case 17:return a=t.type,r=t.pendingProps,r=t.elementType===a?r:Zr(a,r),null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2),t.tag=1,gr(a)?(e=!0,xr(t)):e=!1,rs(t,n),bs(t,a,r),xs(t,a,r,n),Ho(null,t,a,!0,e,n);case 19:return ri(e,t,n);case 23:case 24:return Uo(e,t,n)}throw Error(o(156,t.tag))},al.prototype.render=function(e){$c(e,this._internalRoot,null,null)},al.prototype.unmount=function(){var e=this._internalRoot,t=e.containerInfo;$c(null,e,null,(function(){t[$a]=null}))},et=function(e){13===e.tag&&(fc(e,4,dc()),nl(e,4))},tt=function(e){13===e.tag&&(fc(e,67108864,dc()),nl(e,67108864))},nt=function(e){if(13===e.tag){var t=dc(),n=pc(e);fc(e,n,t),nl(e,n)}},at=function(e,t){return t()},Ce=function(e,t,n){switch(t){case"input":if(ne(e,n),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var a=n[t];if(a!==e&&a.form===e.form){var r=rr(a);if(!r)throw Error(o(90));Q(a),ne(a,r)}}}break;case"textarea":le(e,n);break;case"select":null!=(t=n.value)&&oe(e,!!n.multiple,t,!1)}},Fe=xc,Oe=function(e,t,n,a,r){var s=Fi;Fi|=4;try{return Hr(98,e.bind(null,t,n,a,r))}finally{0===(Fi=s)&&(qi(),qr())}},De=function(){0===(49&Fi)&&(function(){if(null!==rc){var e=rc;rc=null,e.forEach((function(e){e.expiredLanes|=24&e.pendingLanes,gc(e,Vr())}))}qr()}(),Mc())},Me=function(e,t){var n=Fi;Fi|=2;try{return e(t)}finally{0===(Fi=n)&&(qi(),qr())}};var il={Events:[nr,ar,rr,Ae,_e,Mc,{current:!1}]},cl={findFiberByHostInstance:tr,bundleType:0,version:"17.0.2",rendererPackageName:"react-dom"},ll={bundleType:cl.bundleType,version:cl.version,rendererPackageName:cl.rendererPackageName,rendererConfig:cl.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:w.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=Je(e))?null:e.stateNode},findFiberByHostInstance:cl.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var ul=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!ul.isDisabled&&ul.supportsFiber)try{kr=ul.inject(ll),Sr=ul}catch(me){}}t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=il,t.createPortal=ol,t.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var t=e._reactInternals;if(void 0===t){if("function"===typeof e.render)throw Error(o(188));throw Error(o(268,Object.keys(e)))}return e=null===(e=Je(t))?null:e.stateNode},t.flushSync=function(e,t){var n=Fi;if(0!==(48&n))return e(t);Fi|=1;try{if(e)return Hr(99,e.bind(null,t))}finally{Fi=n,qr()}},t.hydrate=function(e,t,n){if(!rl(t))throw Error(o(200));return sl(null,e,t,!0,n)},t.render=function(e,t,n){if(!rl(t))throw Error(o(200));return sl(null,e,t,!1,n)},t.unmountComponentAtNode=function(e){if(!rl(e))throw Error(o(40));return!!e._reactRootContainer&&(wc((function(){sl(null,null,e,!1,(function(){e._reactRootContainer=null,e[$a]=null}))})),!0)},t.unstable_batchedUpdates=xc,t.unstable_createPortal=function(e,t){return ol(e,t,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)},t.unstable_renderSubtreeIntoContainer=function(e,t,n,a){if(!rl(n))throw Error(o(200));if(null==e||void 0===e._reactInternals)throw Error(o(38));return sl(e,t,n,!1,a)},t.version="17.0.2"},292:(e,t,n)=>{"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(144)},776:function(e,t,n){var a;a=function(e){return function(e){var t={};function n(a){if(t[a])return t[a].exports;var r=t[a]={i:a,l:!1,exports:{}};return e[a].call(r.exports,r,r.exports,n),r.l=!0,r.exports}return n.m=e,n.c=t,n.d=function(e,t,a){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:a})},n.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var a=Object.create(null);if(n.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)n.d(a,r,function(t){return e[t]}.bind(null,r));return a},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s="./src/react-webcam.tsx")}({"./src/react-webcam.tsx":function(e,t,n){"use strict";n.r(t);var a=n("react"),r=function(){var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])},e(t,n)};return function(t,n){function a(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(a.prototype=n.prototype,new a)}}(),s=function(){return s=Object.assign||function(e){for(var t,n=1,a=arguments.length;n<a;n++)for(var r in t=arguments[n])Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e},s.apply(this,arguments)},o=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var r=0;for(a=Object.getOwnPropertySymbols(e);r<a.length;r++)t.indexOf(a[r])<0&&Object.prototype.propertyIsEnumerable.call(e,a[r])&&(n[a[r]]=e[a[r]])}return n};function i(){return!(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)}"undefined"!==typeof window&&(void 0===navigator.mediaDevices&&(navigator.mediaDevices={}),void 0===navigator.mediaDevices.getUserMedia&&(navigator.mediaDevices.getUserMedia=function(e){var t=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;return t?new Promise((function(n,a){t.call(navigator,e,n,a)})):Promise.reject(new Error("getUserMedia is not implemented in this browser"))}));var c=function(e){function t(t){var n=e.call(this,t)||this;return n.canvas=null,n.ctx=null,n.requestUserMediaId=0,n.unmounted=!1,n.state={hasUserMedia:!1},n}return r(t,e),t.prototype.componentDidMount=function(){var e=this.state,t=this.props;i()?e.hasUserMedia||this.requestUserMedia():t.onUserMediaError("getUserMedia not supported")},t.prototype.componentDidUpdate=function(e){var t=this.props;if(i()){var n=JSON.stringify(e.audioConstraints)!==JSON.stringify(t.audioConstraints),a=JSON.stringify(e.videoConstraints)!==JSON.stringify(t.videoConstraints),r=e.minScreenshotWidth!==t.minScreenshotWidth,s=e.minScreenshotHeight!==t.minScreenshotHeight;(a||r||s)&&(this.canvas=null,this.ctx=null),(n||a)&&(this.stopAndCleanup(),this.requestUserMedia())}else t.onUserMediaError("getUserMedia not supported")},t.prototype.componentWillUnmount=function(){this.unmounted=!0,this.stopAndCleanup()},t.stopMediaStream=function(e){e&&(e.getVideoTracks&&e.getAudioTracks?(e.getVideoTracks().map((function(t){e.removeTrack(t),t.stop()})),e.getAudioTracks().map((function(t){e.removeTrack(t),t.stop()}))):e.stop())},t.prototype.stopAndCleanup=function(){var e=this.state;e.hasUserMedia&&(t.stopMediaStream(this.stream),e.src&&window.URL.revokeObjectURL(e.src))},t.prototype.getScreenshot=function(e){var t=this.state,n=this.props;if(!t.hasUserMedia)return null;var a=this.getCanvas(e);return a&&a.toDataURL(n.screenshotFormat,n.screenshotQuality)},t.prototype.getCanvas=function(e){var t=this.state,n=this.props;if(!this.video)return null;if(!t.hasUserMedia||!this.video.videoHeight)return null;if(!this.ctx){var a=this.video.videoWidth,r=this.video.videoHeight;if(!this.props.forceScreenshotSourceSize){var s=a/r;r=(a=n.minScreenshotWidth||this.video.clientWidth)/s,n.minScreenshotHeight&&r<n.minScreenshotHeight&&(a=(r=n.minScreenshotHeight)*s)}this.canvas=document.createElement("canvas"),this.canvas.width=(null===e||void 0===e?void 0:e.width)||a,this.canvas.height=(null===e||void 0===e?void 0:e.height)||r,this.ctx=this.canvas.getContext("2d")}var o=this.ctx,i=this.canvas;return o&&i&&(n.mirrored&&(o.translate(i.width,0),o.scale(-1,1)),o.imageSmoothingEnabled=n.imageSmoothing,o.drawImage(this.video,0,0,(null===e||void 0===e?void 0:e.width)||i.width,(null===e||void 0===e?void 0:e.height)||i.height),n.mirrored&&(o.scale(-1,1),o.translate(-i.width,0))),i},t.prototype.requestUserMedia=function(){var e=this,n=this.props,a=function(a,r){var s={video:"undefined"===typeof r||r};n.audio&&(s.audio="undefined"===typeof a||a),e.requestUserMediaId++;var o=e.requestUserMediaId;navigator.mediaDevices.getUserMedia(s).then((function(n){e.unmounted||o!==e.requestUserMediaId?t.stopMediaStream(n):e.handleUserMedia(null,n)})).catch((function(t){e.handleUserMedia(t)}))};if("mediaDevices"in navigator)a(n.audioConstraints,n.videoConstraints);else{var r=function(e){return{optional:[{sourceId:e}]}},s=function(e){var t=e.deviceId;return"string"===typeof t?t:Array.isArray(t)&&t.length>0?t[0]:"object"===typeof t&&t.ideal?t.ideal:null};MediaStreamTrack.getSources((function(e){var t=null,o=null;e.forEach((function(e){"audio"===e.kind?t=e.id:"video"===e.kind&&(o=e.id)}));var i=s(n.audioConstraints);i&&(t=i);var c=s(n.videoConstraints);c&&(o=c),a(r(t),r(o))}))}},t.prototype.handleUserMedia=function(e,t){var n=this.props;if(e||!t)return this.setState({hasUserMedia:!1}),void n.onUserMediaError(e);this.stream=t;try{this.video&&(this.video.srcObject=t),this.setState({hasUserMedia:!0})}catch(a){this.setState({hasUserMedia:!0,src:window.URL.createObjectURL(t)})}n.onUserMedia(t)},t.prototype.render=function(){var e=this,t=this.state,n=this.props,r=n.audio,i=(n.forceScreenshotSourceSize,n.onUserMedia,n.onUserMediaError,n.screenshotFormat,n.screenshotQuality,n.minScreenshotWidth,n.minScreenshotHeight,n.audioConstraints,n.videoConstraints,n.imageSmoothing,n.mirrored),c=n.style,l=void 0===c?{}:c,u=o(n,["audio","forceScreenshotSourceSize","onUserMedia","onUserMediaError","screenshotFormat","screenshotQuality","minScreenshotWidth","minScreenshotHeight","audioConstraints","videoConstraints","imageSmoothing","mirrored","style"]),h=i?s(s({},l),{transform:(l.transform||"")+" scaleX(-1)"}):l;return a.createElement("video",s({autoPlay:!0,src:t.src,muted:!r,playsInline:!0,ref:function(t){e.video=t},style:h},u))},t.defaultProps={audio:!1,forceScreenshotSourceSize:!1,imageSmoothing:!0,mirrored:!1,onUserMedia:function(){},onUserMediaError:function(){},screenshotFormat:"image/webp",screenshotQuality:.92},t}(a.Component);t.default=c},react:function(t,n){t.exports=e}}).default},e.exports=a(n(60))},36:(e,t,n)=>{"use strict";n(528);var a=n(60),r=60103;if(60107,"function"===typeof Symbol&&Symbol.for){var s=Symbol.for;r=s("react.element"),s("react.fragment")}var o=a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,i=Object.prototype.hasOwnProperty,c={key:!0,ref:!0,__self:!0,__source:!0};function l(e,t,n){var a,s={},l=null,u=null;for(a in void 0!==n&&(l=""+n),void 0!==t.key&&(l=""+t.key),void 0!==t.ref&&(u=t.ref),t)i.call(t,a)&&!c.hasOwnProperty(a)&&(s[a]=t[a]);if(e&&e.defaultProps)for(a in t=e.defaultProps)void 0===s[a]&&(s[a]=t[a]);return{$$typeof:r,type:e,key:l,ref:u,props:s,_owner:o.current}}t.jsx=l,t.jsxs=l},564:(e,t,n)=>{"use strict";var a=n(528),r=60103,s=60106;t.Fragment=60107,t.StrictMode=60108,t.Profiler=60114;var o=60109,i=60110,c=60112;t.Suspense=60113;var l=60115,u=60116;if("function"===typeof Symbol&&Symbol.for){var h=Symbol.for;r=h("react.element"),s=h("react.portal"),t.Fragment=h("react.fragment"),t.StrictMode=h("react.strict_mode"),t.Profiler=h("react.profiler"),o=h("react.provider"),i=h("react.context"),c=h("react.forward_ref"),t.Suspense=h("react.suspense"),l=h("react.memo"),u=h("react.lazy")}var d="function"===typeof Symbol&&Symbol.iterator;function p(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},m={};function g(e,t,n){this.props=e,this.context=t,this.refs=m,this.updater=n||f}function y(){}function b(e,t,n){this.props=e,this.context=t,this.refs=m,this.updater=n||f}g.prototype.isReactComponent={},g.prototype.setState=function(e,t){if("object"!==typeof e&&"function"!==typeof e&&null!=e)throw Error(p(85));this.updater.enqueueSetState(this,e,t,"setState")},g.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},y.prototype=g.prototype;var v=b.prototype=new y;v.constructor=b,a(v,g.prototype),v.isPureReactComponent=!0;var x={current:null},w=Object.prototype.hasOwnProperty,k={key:!0,ref:!0,__self:!0,__source:!0};function S(e,t,n){var a,s={},o=null,i=null;if(null!=t)for(a in void 0!==t.ref&&(i=t.ref),void 0!==t.key&&(o=""+t.key),t)w.call(t,a)&&!k.hasOwnProperty(a)&&(s[a]=t[a]);var c=arguments.length-2;if(1===c)s.children=n;else if(1<c){for(var l=Array(c),u=0;u<c;u++)l[u]=arguments[u+2];s.children=l}if(e&&e.defaultProps)for(a in c=e.defaultProps)void 0===s[a]&&(s[a]=c[a]);return{$$typeof:r,type:e,key:o,ref:i,props:s,_owner:x.current}}function I(e){return"object"===typeof e&&null!==e&&e.$$typeof===r}var N=/\/+/g;function C(e,t){return"object"===typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function T(e,t,n,a,o){var i=typeof e;"undefined"!==i&&"boolean"!==i||(e=null);var c=!1;if(null===e)c=!0;else switch(i){case"string":case"number":c=!0;break;case"object":switch(e.$$typeof){case r:case s:c=!0}}if(c)return o=o(c=e),e=""===a?"."+C(c,0):a,Array.isArray(o)?(n="",null!=e&&(n=e.replace(N,"$&/")+"/"),T(o,t,n,"",(function(e){return e}))):null!=o&&(I(o)&&(o=function(e,t){return{$$typeof:r,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(o,n+(!o.key||c&&c.key===o.key?"":(""+o.key).replace(N,"$&/")+"/")+e)),t.push(o)),1;if(c=0,a=""===a?".":a+":",Array.isArray(e))for(var l=0;l<e.length;l++){var u=a+C(i=e[l],l);c+=T(i,t,n,u,o)}else if(u=function(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=d&&e[d]||e["@@iterator"])?e:null}(e),"function"===typeof u)for(e=u.call(e),l=0;!(i=e.next()).done;)c+=T(i=i.value,t,n,u=a+C(i,l++),o);else if("object"===i)throw t=""+e,Error(p(31,"[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t));return c}function E(e,t,n){if(null==e)return e;var a=[],r=0;return T(e,a,"","",(function(e){return t.call(n,e,r++)})),a}function R(e){if(-1===e._status){var t=e._result;t=t(),e._status=0,e._result=t,t.then((function(t){0===e._status&&(t=t.default,e._status=1,e._result=t)}),(function(t){0===e._status&&(e._status=2,e._result=t)}))}if(1===e._status)return e._result;throw e._result}var A={current:null};function _(){var e=A.current;if(null===e)throw Error(p(321));return e}var F={ReactCurrentDispatcher:A,ReactCurrentBatchConfig:{transition:0},ReactCurrentOwner:x,IsSomeRendererActing:{current:!1},assign:a};t.Children={map:E,forEach:function(e,t,n){E(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return E(e,(function(){t++})),t},toArray:function(e){return E(e,(function(e){return e}))||[]},only:function(e){if(!I(e))throw Error(p(143));return e}},t.Component=g,t.PureComponent=b,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=F,t.cloneElement=function(e,t,n){if(null===e||void 0===e)throw Error(p(267,e));var s=a({},e.props),o=e.key,i=e.ref,c=e._owner;if(null!=t){if(void 0!==t.ref&&(i=t.ref,c=x.current),void 0!==t.key&&(o=""+t.key),e.type&&e.type.defaultProps)var l=e.type.defaultProps;for(u in t)w.call(t,u)&&!k.hasOwnProperty(u)&&(s[u]=void 0===t[u]&&void 0!==l?l[u]:t[u])}var u=arguments.length-2;if(1===u)s.children=n;else if(1<u){l=Array(u);for(var h=0;h<u;h++)l[h]=arguments[h+2];s.children=l}return{$$typeof:r,type:e.type,key:o,ref:i,props:s,_owner:c}},t.createContext=function(e,t){return void 0===t&&(t=null),(e={$$typeof:i,_calculateChangedBits:t,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null}).Provider={$$typeof:o,_context:e},e.Consumer=e},t.createElement=S,t.createFactory=function(e){var t=S.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:c,render:e}},t.isValidElement=I,t.lazy=function(e){return{$$typeof:u,_payload:{_status:-1,_result:e},_init:R}},t.memo=function(e,t){return{$$typeof:l,type:e,compare:void 0===t?null:t}},t.useCallback=function(e,t){return _().useCallback(e,t)},t.useContext=function(e,t){return _().useContext(e,t)},t.useDebugValue=function(){},t.useEffect=function(e,t){return _().useEffect(e,t)},t.useImperativeHandle=function(e,t,n){return _().useImperativeHandle(e,t,n)},t.useLayoutEffect=function(e,t){return _().useLayoutEffect(e,t)},t.useMemo=function(e,t){return _().useMemo(e,t)},t.useReducer=function(e,t,n){return _().useReducer(e,t,n)},t.useRef=function(e){return _().useRef(e)},t.useState=function(e){return _().useState(e)},t.version="17.0.2"},60:(e,t,n)=>{"use strict";e.exports=n(564)},496:(e,t,n)=>{"use strict";e.exports=n(36)},692:(e,t)=>{"use strict";var n,a,r,s;if("object"===typeof performance&&"function"===typeof performance.now){var o=performance;t.unstable_now=function(){return o.now()}}else{var i=Date,c=i.now();t.unstable_now=function(){return i.now()-c}}if("undefined"===typeof window||"function"!==typeof MessageChannel){var l=null,u=null,h=function(){if(null!==l)try{var e=t.unstable_now();l(!0,e),l=null}catch(n){throw setTimeout(h,0),n}};n=function(e){null!==l?setTimeout(n,0,e):(l=e,setTimeout(h,0))},a=function(e,t){u=setTimeout(e,t)},r=function(){clearTimeout(u)},t.unstable_shouldYield=function(){return!1},s=t.unstable_forceFrameRate=function(){}}else{var d=window.setTimeout,p=window.clearTimeout;if("undefined"!==typeof console){var f=window.cancelAnimationFrame;"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"),"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills")}var m=!1,g=null,y=-1,b=5,v=0;t.unstable_shouldYield=function(){return t.unstable_now()>=v},s=function(){},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):b=0<e?Math.floor(1e3/e):5};var x=new MessageChannel,w=x.port2;x.port1.onmessage=function(){if(null!==g){var e=t.unstable_now();v=e+b;try{g(!0,e)?w.postMessage(null):(m=!1,g=null)}catch(n){throw w.postMessage(null),n}}else m=!1},n=function(e){g=e,m||(m=!0,w.postMessage(null))},a=function(e,n){y=d((function(){e(t.unstable_now())}),n)},r=function(){p(y),y=-1}}function k(e,t){var n=e.length;e.push(t);e:for(;;){var a=n-1>>>1,r=e[a];if(!(void 0!==r&&0<N(r,t)))break e;e[a]=t,e[n]=r,n=a}}function S(e){return void 0===(e=e[0])?null:e}function I(e){var t=e[0];if(void 0!==t){var n=e.pop();if(n!==t){e[0]=n;e:for(var a=0,r=e.length;a<r;){var s=2*(a+1)-1,o=e[s],i=s+1,c=e[i];if(void 0!==o&&0>N(o,n))void 0!==c&&0>N(c,o)?(e[a]=c,e[i]=n,a=i):(e[a]=o,e[s]=n,a=s);else{if(!(void 0!==c&&0>N(c,n)))break e;e[a]=c,e[i]=n,a=i}}}return t}return null}function N(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}var C=[],T=[],E=1,R=null,A=3,_=!1,F=!1,O=!1;function D(e){for(var t=S(T);null!==t;){if(null===t.callback)I(T);else{if(!(t.startTime<=e))break;I(T),t.sortIndex=t.expirationTime,k(C,t)}t=S(T)}}function M(e){if(O=!1,D(e),!F)if(null!==S(C))F=!0,n(L);else{var t=S(T);null!==t&&a(M,t.startTime-e)}}function L(e,n){F=!1,O&&(O=!1,r()),_=!0;var s=A;try{for(D(n),R=S(C);null!==R&&(!(R.expirationTime>n)||e&&!t.unstable_shouldYield());){var o=R.callback;if("function"===typeof o){R.callback=null,A=R.priorityLevel;var i=o(R.expirationTime<=n);n=t.unstable_now(),"function"===typeof i?R.callback=i:R===S(C)&&I(C),D(n)}else I(C);R=S(C)}if(null!==R)var c=!0;else{var l=S(T);null!==l&&a(M,l.startTime-n),c=!1}return c}finally{R=null,A=s,_=!1}}var P=s;t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_continueExecution=function(){F||_||(F=!0,n(L))},t.unstable_getCurrentPriorityLevel=function(){return A},t.unstable_getFirstCallbackNode=function(){return S(C)},t.unstable_next=function(e){switch(A){case 1:case 2:case 3:var t=3;break;default:t=A}var n=A;A=t;try{return e()}finally{A=n}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=P,t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=A;A=e;try{return t()}finally{A=n}},t.unstable_scheduleCallback=function(e,s,o){var i=t.unstable_now();switch("object"===typeof o&&null!==o?o="number"===typeof(o=o.delay)&&0<o?i+o:i:o=i,e){case 1:var c=-1;break;case 2:c=250;break;case 5:c=1073741823;break;case 4:c=1e4;break;default:c=5e3}return e={id:E++,callback:s,priorityLevel:e,startTime:o,expirationTime:c=o+c,sortIndex:-1},o>i?(e.sortIndex=o,k(T,e),null===S(C)&&e===S(T)&&(O?r():O=!0,a(M,o-i))):(e.sortIndex=c,k(C,e),F||_||(F=!0,n(L))),e},t.unstable_wrapCallback=function(e){var t=A;return function(){var n=A;A=t;try{return e.apply(this,arguments)}finally{A=n}}}},724:(e,t,n)=>{"use strict";e.exports=n(692)},928:(e,t,n)=>{var a=n(408),r=n(344),s=n(936),o=n(552),i=n(584),c=n(296),l=n(996);l.alea=a,l.xor128=r,l.xorwow=s,l.xorshift7=o,l.xor4096=i,l.tychei=c,e.exports=l},408:function(e,t,n){var a;!function(e,r,s){function o(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var a=.02519603282416938*(e+=t.charCodeAt(n));a-=e=a>>>0,e=(a*=e)>>>0,e+=4294967296*(a-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function c(e,t){var n=new o(e),a=t&&t.state,r=n.next;return r.int32=function(){return 4294967296*n.next()|0},r.double=function(){return r()+11102230246251565e-32*(2097152*r()|0)},r.quick=r,a&&("object"==typeof a&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.alea=c}(0,e=n.nmd(e),n.amdD)},296:function(e,t,n){var a;!function(e,r,s){function o(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,a=t.d,r=t.a;return e=e<<25^e>>>7^n,n=n-a|0,a=a<<24^a>>>8^r,r=r-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-a|0,t.d=a<<16^n>>>16^r,t.a=r-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var a=0;a<n.length+20;a++)t.b^=0|n.charCodeAt(a),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function c(e,t){var n=new o(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&("object"==typeof a&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.tychei=c}(0,e=n.nmd(e),n.amdD)},344:function(e,t,n){var a;!function(e,r,s){function o(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var a=0;a<n.length+64;a++)t.x^=0|n.charCodeAt(a),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function c(e,t){var n=new o(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&("object"==typeof a&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.xor128=c}(0,e=n.nmd(e),n.amdD)},584:function(e,t,n){var a;!function(e,r,s){function o(e){var t=this;t.next=function(){var e,n,a=t.w,r=t.X,s=t.i;return t.w=a=a+1640531527|0,n=r[s+34&127],e=r[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=r[s]=n^e,t.i=s,n+(a^a>>>16)|0},function(e,t){var n,a,r,s,o,i=[],c=128;for(t===(0|t)?(a=t,t=null):(t+="\0",a=0,c=Math.max(c,t.length)),r=0,s=-32;s<c;++s)t&&(a^=t.charCodeAt((s+32)%t.length)),0===s&&(o=a),a^=a<<10,a^=a>>>15,a^=a<<4,a^=a>>>13,s>=0&&(o=o+1640531527|0,r=0==(n=i[127&s]^=a+o)?r+1:0);for(r>=128&&(i[127&(t&&t.length||0)]=-1),r=127,s=512;s>0;--s)a=i[r+34&127],n=i[r=r+1&127],a^=a<<13,n^=n<<17,a^=a>>>15,n^=n>>>12,i[r]=a^n;e.w=o,e.X=i,e.i=r}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function c(e,t){null==e&&(e=+new Date);var n=new o(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&(a.X&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.xor4096=c}(0,e=n.nmd(e),n.amdD)},552:function(e,t,n){var a;!function(e,r,s){function o(e){var t=this;t.next=function(){var e,n,a=t.x,r=t.i;return e=a[r],n=(e^=e>>>7)^e<<24,n^=(e=a[r+1&7])^e>>>10,n^=(e=a[r+3&7])^e>>>3,n^=(e=a[r+4&7])^e<<7,e=a[r+7&7],n^=(e^=e<<13)^e<<9,a[r]=n,t.i=r+1&7,n},function(e,t){var n,a=[];if(t===(0|t))a[0]=t;else for(t=""+t,n=0;n<t.length;++n)a[7&n]=a[7&n]<<15^t.charCodeAt(n)+a[n+1&7]<<13;for(;a.length<8;)a.push(0);for(n=0;n<8&&0===a[n];++n);for(8==n?a[7]=-1:a[n],e.x=a,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function c(e,t){null==e&&(e=+new Date);var n=new o(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&(a.x&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.xorshift7=c}(0,e=n.nmd(e),n.amdD)},936:function(e,t,n){var a;!function(e,r,s){function o(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var a=0;a<n.length+64;a++)t.x^=0|n.charCodeAt(a),a==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function c(e,t){var n=new o(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&("object"==typeof a&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.xorwow=c}(0,e=n.nmd(e),n.amdD)},996:function(e,t,n){var a;!function(r,s,o){var i,c=256,l=o.pow(c,6),u=o.pow(2,52),h=2*u,d=c-1;function p(e,t,n){var a=[],d=y(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,b(s)]:null==e?function(){try{var e;return i&&(e=i.randomBytes)?e=e(c):(e=new Uint8Array(c),(r.crypto||r.msCrypto).getRandomValues(e)),b(e)}catch(a){var t=r.navigator,n=t&&t.plugins;return[+new Date,r,n,r.screen,b(s)]}}():e,3),a),p=new f(a),v=function(){for(var e=p.g(6),t=l,n=0;e<u;)e=(e+n)*c,t*=c,n=p.g(1);for(;e>=h;)e/=2,t/=2,n>>>=1;return(e+n)/t};return v.int32=function(){return 0|p.g(4)},v.quick=function(){return p.g(4)/4294967296},v.double=v,y(b(p.S),s),(t.pass||n||function(e,t,n,a){return a&&(a.S&&m(a,p),e.state=function(){return m(p,{})}),n?(o.random=e,t):e})(v,d,"global"in t?t.global:this==o,t.state)}function f(e){var t,n=e.length,a=this,r=0,s=a.i=a.j=0,o=a.S=[];for(n||(e=[n++]);r<c;)o[r]=r++;for(r=0;r<c;r++)o[r]=o[s=d&s+e[r%n]+(t=o[r])],o[s]=t;(a.g=function(e){for(var t,n=0,r=a.i,s=a.j,o=a.S;e--;)t=o[r=d&r+1],n=n*c+o[d&(o[r]=o[s=d&s+t])+(o[s]=t)];return a.i=r,a.j=s,n})(c)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,a=[],r=typeof e;if(t&&"object"==r)for(n in e)try{a.push(g(e[n],t-1))}catch(s){}return a.length?a:"string"==r?e:e+"\0"}function y(e,t){for(var n,a=e+"",r=0;r<a.length;)t[d&r]=d&(n^=19*t[d&r])+a.charCodeAt(r++);return b(t)}function b(e){return String.fromCharCode.apply(0,e)}if(y(o.random(),s),e.exports){e.exports=p;try{i=n(604)}catch(v){}}else void 0===(a=function(){return p}.call(t,n,t,e))||(e.exports=a)}("undefined"!==typeof self?self:this,[],Math)},748:()=>{},688:()=>{},556:()=>{},932:()=>{},830:()=>{},604:()=>{}},t={};function n(a){var r=t[a];if(void 0!==r)return r.exports;var s=t[a]={id:a,loaded:!1,exports:{}};return e[a].call(s.exports,s,s.exports,n),s.loaded=!0,s.exports}n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},(()=>{var e,t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__;n.t=function(a,r){if(1&r&&(a=this(a)),8&r)return a;if("object"===typeof a&&a){if(4&r&&a.__esModule)return a;if(16&r&&"function"===typeof a.then)return a}var s=Object.create(null);n.r(s);var o={};e=e||[null,t({}),t([]),t(t)];for(var i=2&r&&a;"object"==typeof i&&!~e.indexOf(i);i=t(i))Object.getOwnPropertyNames(i).forEach((e=>o[e]=()=>a[e]));return o.default=()=>a,n.d(s,o),s}})(),n.d=(e,t)=>{for(var a in t)n.o(t,a)&&!n.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),n.p="/Yoga-Posture-Detection/",(()=>{"use strict";var e={};n.r(e),n.d(e,{browserFiles:()=>ec,browserHTTPRequest:()=>lc,concatenateArrayBuffers:()=>ti,copyModel:()=>Ui,decodeWeights:()=>Qo,encodeWeights:()=>Zo,fromMemory:()=>pc,fromMemorySync:()=>fc,getLoadHandlers:()=>pi,getModelArtifactsForJSON:()=>si,getModelArtifactsForJSONSync:()=>ri,getModelArtifactsInfoForJSON:()=>oi,getSaveHandlers:()=>di,getWeightSpecs:()=>ii,http:()=>cc,isHTTPScheme:()=>oc,listModels:()=>Bi,loadWeights:()=>ac,moveModel:()=>Vi,registerLoadRouter:()=>hi,registerSaveRouter:()=>ui,removeModel:()=>Wi,weightsLoaderFactory:()=>rc,withSaveHandler:()=>mc,withSaveHandlerSync:()=>gc});var t={};n.r(t),n.d(t,{assertParamsValid:()=>Cc,computeFlatOffset:()=>Bc,computeOutShape:()=>Ec,getNormalizedAxes:()=>Fc,isSliceContinous:()=>zc,maskToAxes:()=>Tc,parseSliceParams:()=>Wc,sliceInfo:()=>Uc,startForAxis:()=>Lc,startIndicesWithElidedDims:()=>Oc,stopForAxis:()=>Pc,stopIndicesWithElidedDims:()=>Dc,stridesForAxis:()=>Mc,stridesWithElidedDims:()=>Rc});var a={};n.r(a),n.d(a,{conv2d:()=>vp,depthwiseConv2d:()=>kp,matMul:()=>Sp});var r={};n.r(r),n.d(r,{collectGatherOpShapeInfo:()=>Um,computeOutShape:()=>Wm,segOpComputeOptimalWindowSize:()=>Bm});var s={};n.r(s),n.d(s,{ERF_A1:()=>am,ERF_A2:()=>rm,ERF_A3:()=>sm,ERF_A4:()=>om,ERF_A5:()=>im,ERF_P:()=>nm,PARALLELIZE_THRESHOLD:()=>Hf,RowPartitionType:()=>Wf,SELU_SCALE:()=>tm,SELU_SCALEALPHA:()=>em,applyActivation:()=>yp,assertAndGetBroadcastShape:()=>vc,assertAxesAreInnerMostDims:()=>_u,assertParamsConsistent:()=>zf,assignToTypedArray:()=>pm,axesAreInnerMostDims:()=>Tu,calculateShapes:()=>op,checkEinsumDimSizes:()=>km,checkPadOnDimRoundingMode:()=>Rl,combineLocations:()=>Eu,combineRaggedTensorToTensorShapes:()=>Uf,complexWithEvenIndex:()=>um,complexWithOddIndex:()=>hm,computeConv2DInfo:()=>vl,computeConv3DInfo:()=>xl,computeDefaultPad:()=>wl,computeDilation2DInfo:()=>gl,computeOptimalWindowSize:()=>Kf,computeOutAndReduceShapes:()=>Ru,computeOutShape:()=>Bf,computePool2DInfo:()=>yl,computePool3DInfo:()=>bl,convertConv2DDataFormat:()=>El,decodeEinsumEquation:()=>xm,eitherStridesOrDilationsAreOne:()=>Tl,expandShapeToKeepDim:()=>Au,exponent:()=>mm,exponents:()=>fm,fromStringArrayToUint8:()=>Gm,fromUint8ToStringArray:()=>Vm,getAxesPermutation:()=>Fu,getBroadcastDims:()=>yc,getComplexWithIndex:()=>dm,getEinsumComputePath:()=>Sm,getEinsumPermutation:()=>wm,getFusedBiasGradient:()=>gp,getFusedDyActivation:()=>mp,getImageCenter:()=>qf,getInnerMostAxes:()=>Du,getPermuted:()=>Yf,getRaggedRank:()=>Gf,getReductionAxes:()=>bc,getReshaped:()=>Xf,getReshapedPermuted:()=>Zf,getRowPartitionTypesHelper:()=>Vf,getSliceBeginCoords:()=>Qf,getSliceSize:()=>Jf,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>Tm,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Em,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Rm,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Fm,getSparseReshapeInputOutputMismatchErrorMessage:()=>Dm,getSparseReshapeInputOutputMultipleErrorMessage:()=>Om,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Am,getSparseReshapeNegativeOutputDimErrorMessage:()=>_m,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>zm,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Mm,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Lm,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Pm,getUndoAxesPermutation:()=>Ou,isIdentityPermutation:()=>Im,log:()=>Ss,mergeRealAndImagArrays:()=>cm,prepareAndValidate:()=>$f,prepareSplitSize:()=>Cm,segment_util:()=>r,shouldFuse:()=>bp,slice_util:()=>t,splitRealAndImagArrays:()=>lm,tupleValuesAreOne:()=>Cl,upcastType:()=>ko,validateDefaultValueShape:()=>jf,validateInput:()=>sp,validateUpdateShape:()=>rp,warn:()=>ks});var o={};n.r(o),n.d(o,{json:()=>tg});var i={};n.r(i),n.d(i,{json:()=>ng});var c={};n.r(c),n.d(c,{json:()=>ag});var l={};n.r(l),n.d(l,{json:()=>rg});var u={};n.r(u),n.d(u,{json:()=>sg});var h={};n.r(h),n.d(h,{json:()=>og});var d={};n.r(d),n.d(d,{json:()=>ig});var p={};n.r(p),n.d(p,{json:()=>cg});var f={};n.r(f),n.d(f,{json:()=>lg});var m={};n.r(m),n.d(m,{json:()=>ug});var g={};n.r(g),n.d(g,{json:()=>hg});var y={};n.r(y),n.d(y,{json:()=>dg});var b={};n.r(b),n.d(b,{json:()=>pg});var v={};n.r(v),n.d(v,{json:()=>fg});var x={};n.r(x),n.d(x,{json:()=>mg});var w={};n.r(w),n.d(w,{json:()=>gg});var k={};n.r(k),n.d(k,{json:()=>yg});var S={};n.r(S),n.d(S,{json:()=>bg});var I={};n.r(I),n.d(I,{json:()=>vg});var N={};n.r(N),n.d(N,{OP_SCOPE_SUFFIX:()=>Go,abs:()=>nl,acos:()=>al,acosh:()=>rl,add:()=>sl,addN:()=>ol,all:()=>il,any:()=>cl,argMax:()=>ll,argMin:()=>ul,asin:()=>hl,asinh:()=>dl,atan:()=>pl,atan2:()=>fl,atanh:()=>ml,avgPool:()=>_l,avgPool3d:()=>Fl,basicLSTMCell:()=>Bl,batchNorm:()=>Ul,batchNorm2d:()=>Vl,batchNorm3d:()=>Gl,batchNorm4d:()=>jl,batchToSpaceND:()=>Wl,bincount:()=>Hl,booleanMaskAsync:()=>tp,broadcastArgs:()=>Kl,broadcastTo:()=>ql,buffer:()=>qi,cast:()=>Xi,ceil:()=>Xl,clipByValue:()=>Zl,clone:()=>Yi,complex:()=>Ho,concat:()=>Ol,concat1d:()=>Ql,concat2d:()=>Jl,concat3d:()=>$l,concat4d:()=>eu,conv1d:()=>nu,conv2d:()=>tu,conv2dTranspose:()=>ru,conv3d:()=>su,conv3dTranspose:()=>iu,cos:()=>cu,cosh:()=>lu,cosineWindow:()=>dp,cumprod:()=>uu,cumsum:()=>hu,denseBincount:()=>du,depthToSpace:()=>pu,depthwiseConv2d:()=>fu,diag:()=>mu,dilation2d:()=>gu,div:()=>bu,divNoNan:()=>ku,dot:()=>Su,dropout:()=>up,einsum:()=>Iu,elu:()=>Nu,enclosingPowerOfTwo:()=>hp,equal:()=>vu,erf:()=>Cu,euclideanNorm:()=>Gu,exp:()=>ju,expandDims:()=>Hu,expm1:()=>Ku,eye:()=>Xu,fft:()=>Ad,fill:()=>Yl,floor:()=>Yu,floorDiv:()=>yu,fused:()=>a,gather:()=>Zu,gatherND:()=>lp,greater:()=>Qu,greaterEqual:()=>Ju,ifft:()=>_d,imag:()=>$u,image:()=>kf,inTopKAsync:()=>pp,irfft:()=>Fd,isFinite:()=>eh,isInf:()=>th,isNaN:()=>nh,leakyRelu:()=>ah,less:()=>rh,lessEqual:()=>sh,linalg:()=>Sf,linspace:()=>oh,localResponseNormalization:()=>ih,log:()=>ch,log1p:()=>lh,logSigmoid:()=>dh,logSoftmax:()=>fh,logSumExp:()=>mh,logicalAnd:()=>gh,logicalNot:()=>yh,logicalOr:()=>bh,logicalXor:()=>vh,losses:()=>If,lowerBound:()=>kh,matMul:()=>Dl,max:()=>Mu,maxPool:()=>Sh,maxPool3d:()=>Ih,maxPoolWithArgmax:()=>Nh,maximum:()=>Ch,mean:()=>Th,meshgrid:()=>Ah,min:()=>Lu,minimum:()=>_h,mirrorPad:()=>Fh,mod:()=>Oh,moments:()=>Dh,movingAverage:()=>ap,mul:()=>Ml,multiRNNCell:()=>Mh,multinomial:()=>Lh,neg:()=>uh,norm:()=>Vu,notEqual:()=>Ph,oneHot:()=>zh,ones:()=>Rh,onesLike:()=>Bh,op:()=>jo,outerProduct:()=>Wh,pad:()=>Uh,pad1d:()=>Vh,pad2d:()=>Gh,pad3d:()=>jh,pad4d:()=>Hh,pool:()=>qh,pow:()=>Pu,prelu:()=>Xh,print:()=>Zi,prod:()=>Yh,raggedGather:()=>Zh,raggedTensorToTensor:()=>Qh,rand:()=>Jh,randomGamma:()=>ad,randomNormal:()=>rd,randomStandardNormal:()=>sd,randomUniform:()=>od,range:()=>id,real:()=>cd,reciprocal:()=>ld,relu:()=>ud,relu6:()=>hd,reshape:()=>Al,reverse:()=>dd,reverse1d:()=>pd,reverse2d:()=>fd,reverse3d:()=>md,reverse4d:()=>gd,rfft:()=>Dd,round:()=>yd,rsqrt:()=>bd,scalar:()=>el,scatterND:()=>ip,searchSorted:()=>wh,selu:()=>vd,separableConv2d:()=>xd,setdiff1dAsync:()=>wd,sigmoid:()=>Ll,sign:()=>kd,signal:()=>wf,sin:()=>Sd,sinh:()=>Id,slice:()=>Pl,slice1d:()=>Nd,slice2d:()=>Cd,slice3d:()=>Td,slice4d:()=>Ed,softmax:()=>Rd,softplus:()=>hh,spaceToBatchND:()=>Kh,sparse:()=>Nf,sparseToDense:()=>cp,spectral:()=>xf,split:()=>Od,sqrt:()=>zu,square:()=>Bu,squaredDifference:()=>Md,squeeze:()=>Ld,stack:()=>Pd,step:()=>zd,stridedSlice:()=>Bd,string:()=>Cf,sub:()=>ph,sum:()=>Wu,tan:()=>Wd,tanh:()=>zl,tensor:()=>qo,tensor1d:()=>Ud,tensor2d:()=>Vd,tensor3d:()=>xc,tensor4d:()=>Gd,tensor5d:()=>jd,tensor6d:()=>Hd,tile:()=>qu,topk:()=>Kd,transpose:()=>np,truncatedNormal:()=>qd,unique:()=>Xd,unsortedSegmentSum:()=>Yd,unstack:()=>Zd,upperBound:()=>Qd,variable:()=>Jd,where:()=>xu,whereAsync:()=>ep,zeros:()=>Eh,zerosLike:()=>wu});var C={};n.r(C),n.d(C,{addImpl:()=>wT,bincountImpl:()=>pE,bincountReduceImpl:()=>fE,castImpl:()=>gT,ceilImpl:()=>yE,concatImpl:()=>SE,equalImpl:()=>oR,expImpl:()=>yR,expm1Impl:()=>kR,floorImpl:()=>BR,gatherNdImpl:()=>qR,gatherV2Impl:()=>YR,greaterEqualImpl:()=>eA,greaterImpl:()=>QR,lessEqualImpl:()=>pA,lessImpl:()=>uA,linSpaceImpl:()=>gA,logImpl:()=>bA,maxImpl:()=>OA,maximumImpl:()=>LA,minimumImpl:()=>KA,multiplyImpl:()=>JE,negImpl:()=>n_,notEqualImpl:()=>u_,prodImpl:()=>S_,raggedGatherImpl:()=>E_,raggedTensorToTensorImpl:()=>D_,rangeImpl:()=>L_,rsqrtImpl:()=>X_,scatterImpl:()=>Q_,sigmoidImpl:()=>iT,simpleAbsImpl:()=>AT,sliceImpl:()=>lE,sparseFillEmptyRowsImpl:()=>yF,sparseReshapeImpl:()=>vF,sparseSegmentReductionImpl:()=>wF,sqrtImpl:()=>CF,stridedSliceImpl:()=>MF,stringNGramsImpl:()=>zF,stringSplitImpl:()=>UF,stringToHashBucketFastImpl:()=>GF,subImpl:()=>ER,tileImpl:()=>XF,topKImpl:()=>JF,transposeImpl:()=>PT,uniqueImpl:()=>sO});var T,E=n(60),R=n.t(E,2),A=n(292),_=n.t(A,2);function F(){return F=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},F.apply(this,arguments)}!function(e){e.Pop="POP",e.Push="PUSH",e.Replace="REPLACE"}(T||(T={}));const O="popstate";function D(e,t){if(!1===e||null===e||"undefined"===typeof e)throw new Error(t)}function M(e,t){if(!e){"undefined"!==typeof console&&console.warn(t);try{throw new Error(t)}catch(n){}}}function L(e,t){return{usr:e.state,key:e.key,idx:t}}function P(e,t,n,a){return void 0===n&&(n=null),F({pathname:"string"===typeof e?e:e.pathname,search:"",hash:""},"string"===typeof t?B(t):t,{state:n,key:t&&t.key||a||Math.random().toString(36).substr(2,8)})}function z(e){let{pathname:t="/",search:n="",hash:a=""}=e;return n&&"?"!==n&&(t+="?"===n.charAt(0)?n:"?"+n),a&&"#"!==a&&(t+="#"===a.charAt(0)?a:"#"+a),t}function B(e){let t={};if(e){let n=e.indexOf("#");n>=0&&(t.hash=e.substr(n),e=e.substr(0,n));let a=e.indexOf("?");a>=0&&(t.search=e.substr(a),e=e.substr(0,a)),e&&(t.pathname=e)}return t}function W(e,t,n,a){void 0===a&&(a={});let{window:r=document.defaultView,v5Compat:s=!1}=a,o=r.history,i=T.Pop,c=null,l=u();function u(){return(o.state||{idx:null}).idx}function h(){i=T.Pop;let e=u(),t=null==e?null:e-l;l=e,c&&c({action:i,location:p.location,delta:t})}function d(e){let t="null"!==r.location.origin?r.location.origin:r.location.href,n="string"===typeof e?e:z(e);return D(t,"No window.location.(origin|href) available to create URL for href: "+n),new URL(n,t)}null==l&&(l=0,o.replaceState(F({},o.state,{idx:l}),""));let p={get action(){return i},get location(){return e(r,o)},listen(e){if(c)throw new Error("A history only accepts one active listener");return r.addEventListener(O,h),c=e,()=>{r.removeEventListener(O,h),c=null}},createHref:e=>t(r,e),createURL:d,encodeLocation(e){let t=d(e);return{pathname:t.pathname,search:t.search,hash:t.hash}},push:function(e,t){i=T.Push;let a=P(p.location,e,t);n&&n(a,e),l=u()+1;let h=L(a,l),d=p.createHref(a);try{o.pushState(h,"",d)}catch(f){if(f instanceof DOMException&&"DataCloneError"===f.name)throw f;r.location.assign(d)}s&&c&&c({action:i,location:p.location,delta:1})},replace:function(e,t){i=T.Replace;let a=P(p.location,e,t);n&&n(a,e),l=u();let r=L(a,l),h=p.createHref(a);o.replaceState(r,"",h),s&&c&&c({action:i,location:p.location,delta:0})},go:e=>o.go(e)};return p}var U;!function(e){e.data="data",e.deferred="deferred",e.redirect="redirect",e.error="error"}(U||(U={}));new Set(["lazy","caseSensitive","path","id","index","children"]);function V(e,t,n){void 0===n&&(n="/");let a=ne(("string"===typeof t?B(t):t).pathname||"/",n);if(null==a)return null;let r=G(e);!function(e){e.sort(((e,t)=>e.score!==t.score?t.score-e.score:function(e,t){let n=e.length===t.length&&e.slice(0,-1).every(((e,n)=>e===t[n]));return n?e[e.length-1]-t[t.length-1]:0}(e.routesMeta.map((e=>e.childrenIndex)),t.routesMeta.map((e=>e.childrenIndex)))))}(r);let s=null;for(let o=0;null==s&&o<r.length;++o)s=$(r[o],te(a));return s}function G(e,t,n,a){void 0===t&&(t=[]),void 0===n&&(n=[]),void 0===a&&(a="");let r=(e,r,s)=>{let o={relativePath:void 0===s?e.path||"":s,caseSensitive:!0===e.caseSensitive,childrenIndex:r,route:e};o.relativePath.startsWith("/")&&(D(o.relativePath.startsWith(a),'Absolute route path "'+o.relativePath+'" nested under path "'+a+'" is not valid. An absolute child route path must start with the combined path of all its parent routes.'),o.relativePath=o.relativePath.slice(a.length));let i=ie([a,o.relativePath]),c=n.concat(o);e.children&&e.children.length>0&&(D(!0!==e.index,'Index routes must not have child routes. Please remove all child routes from route path "'+i+'".'),G(e.children,t,c,i)),(null!=e.path||e.index)&&t.push({path:i,score:J(i,e.index),routesMeta:c})};return e.forEach(((e,t)=>{var n;if(""!==e.path&&null!=(n=e.path)&&n.includes("?"))for(let a of j(e.path))r(e,t,a);else r(e,t)})),t}function j(e){let t=e.split("/");if(0===t.length)return[];let[n,...a]=t,r=n.endsWith("?"),s=n.replace(/\?$/,"");if(0===a.length)return r?[s,""]:[s];let o=j(a.join("/")),i=[];return i.push(...o.map((e=>""===e?s:[s,e].join("/")))),r&&i.push(...o),i.map((t=>e.startsWith("/")&&""===t?"/":t))}const H=/^:[\w-]+$/,K=3,q=2,X=1,Y=10,Z=-2,Q=e=>"*"===e;function J(e,t){let n=e.split("/"),a=n.length;return n.some(Q)&&(a+=Z),t&&(a+=q),n.filter((e=>!Q(e))).reduce(((e,t)=>e+(H.test(t)?K:""===t?X:Y)),a)}function $(e,t){let{routesMeta:n}=e,a={},r="/",s=[];for(let o=0;o<n.length;++o){let e=n[o],i=o===n.length-1,c="/"===r?t:t.slice(r.length)||"/",l=ee({path:e.relativePath,caseSensitive:e.caseSensitive,end:i},c);if(!l)return null;Object.assign(a,l.params);let u=e.route;s.push({params:a,pathname:ie([r,l.pathname]),pathnameBase:ce(ie([r,l.pathnameBase])),route:u}),"/"!==l.pathnameBase&&(r=ie([r,l.pathnameBase]))}return s}function ee(e,t){"string"===typeof e&&(e={path:e,caseSensitive:!1,end:!0});let[n,a]=function(e,t,n){void 0===t&&(t=!1);void 0===n&&(n=!0);M("*"===e||!e.endsWith("*")||e.endsWith("/*"),'Route path "'+e+'" will be treated as if it were "'+e.replace(/\*$/,"/*")+'" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "'+e.replace(/\*$/,"/*")+'".');let a=[],r="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,((e,t,n)=>(a.push({paramName:t,isOptional:null!=n}),n?"/?([^\\/]+)?":"/([^\\/]+)")));e.endsWith("*")?(a.push({paramName:"*"}),r+="*"===e||"/*"===e?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?r+="\\/*$":""!==e&&"/"!==e&&(r+="(?:(?=\\/|$))");let s=new RegExp(r,t?void 0:"i");return[s,a]}(e.path,e.caseSensitive,e.end),r=t.match(n);if(!r)return null;let s=r[0],o=s.replace(/(.)\/+$/,"$1"),i=r.slice(1);return{params:a.reduce(((e,t,n)=>{let{paramName:a,isOptional:r}=t;if("*"===a){let e=i[n]||"";o=s.slice(0,s.length-e.length).replace(/(.)\/+$/,"$1")}const c=i[n];return e[a]=r&&!c?void 0:function(e,t){try{return decodeURIComponent(e)}catch(n){return M(!1,'The value for the URL param "'+t+'" will not be decoded because the string "'+e+'" is a malformed URL segment. This is probably due to a bad percent encoding ('+n+")."),e}}(c||"",a),e}),{}),pathname:s,pathnameBase:o,pattern:e}}function te(e){try{return decodeURI(e)}catch(t){return M(!1,'The URL path "'+e+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding ('+t+")."),e}}function ne(e,t){if("/"===t)return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=t.endsWith("/")?t.length-1:t.length,a=e.charAt(n);return a&&"/"!==a?null:e.slice(n)||"/"}function ae(e,t,n,a){return"Cannot include a '"+e+"' character in a manually specified `to."+t+"` field ["+JSON.stringify(a)+"].  Please separate it out to the `to."+n+'` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.'}function re(e){return e.filter(((e,t)=>0===t||e.route.path&&e.route.path.length>0))}function se(e,t){let n=re(e);return t?n.map(((t,n)=>n===e.length-1?t.pathname:t.pathnameBase)):n.map((e=>e.pathnameBase))}function oe(e,t,n,a){let r;void 0===a&&(a=!1),"string"===typeof e?r=B(e):(r=F({},e),D(!r.pathname||!r.pathname.includes("?"),ae("?","pathname","search",r)),D(!r.pathname||!r.pathname.includes("#"),ae("#","pathname","hash",r)),D(!r.search||!r.search.includes("#"),ae("#","search","hash",r)));let s,o=""===e||""===r.pathname,i=o?"/":r.pathname;if(null==i)s=n;else{let e=t.length-1;if(!a&&i.startsWith("..")){let t=i.split("/");for(;".."===t[0];)t.shift(),e-=1;r.pathname=t.join("/")}s=e>=0?t[e]:"/"}let c=function(e,t){void 0===t&&(t="/");let{pathname:n,search:a="",hash:r=""}="string"===typeof e?B(e):e,s=n?n.startsWith("/")?n:function(e,t){let n=t.replace(/\/+$/,"").split("/");return e.split("/").forEach((e=>{".."===e?n.length>1&&n.pop():"."!==e&&n.push(e)})),n.length>1?n.join("/"):"/"}(n,t):t;return{pathname:s,search:le(a),hash:ue(r)}}(r,s),l=i&&"/"!==i&&i.endsWith("/"),u=(o||"."===i)&&n.endsWith("/");return c.pathname.endsWith("/")||!l&&!u||(c.pathname+="/"),c}const ie=e=>e.join("/").replace(/\/\/+/g,"/"),ce=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),le=e=>e&&"?"!==e?e.startsWith("?")?e:"?"+e:"",ue=e=>e&&"#"!==e?e.startsWith("#")?e:"#"+e:"";Error;function he(e){return null!=e&&"number"===typeof e.status&&"string"===typeof e.statusText&&"boolean"===typeof e.internal&&"data"in e}const de=["post","put","patch","delete"],pe=(new Set(de),["get",...de]);new Set(pe),new Set([301,302,303,307,308]),new Set([307,308]);Symbol("deferred");function fe(){return fe=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},fe.apply(this,arguments)}const me=E.createContext(null);const ge=E.createContext(null);const ye=E.createContext(null);const be=E.createContext(null);const ve=E.createContext({outlet:null,matches:[],isDataRoute:!1});const xe=E.createContext(null);function we(){return null!=E.useContext(be)}function ke(){return we()||D(!1),E.useContext(be).location}function Se(e){E.useContext(ye).static||E.useLayoutEffect(e)}function Ie(){let{isDataRoute:e}=E.useContext(ve);return e?function(){let{router:e}=De(Fe.UseNavigateStable),t=Le(Oe.UseNavigateStable),n=E.useRef(!1);return Se((()=>{n.current=!0})),E.useCallback((function(a,r){void 0===r&&(r={}),n.current&&("number"===typeof a?e.navigate(a):e.navigate(a,fe({fromRouteId:t},r)))}),[e,t])}():function(){we()||D(!1);let e=E.useContext(me),{basename:t,future:n,navigator:a}=E.useContext(ye),{matches:r}=E.useContext(ve),{pathname:s}=ke(),o=JSON.stringify(se(r,n.v7_relativeSplatPath)),i=E.useRef(!1);Se((()=>{i.current=!0}));let c=E.useCallback((function(n,r){if(void 0===r&&(r={}),!i.current)return;if("number"===typeof n)return void a.go(n);let c=oe(n,JSON.parse(o),s,"path"===r.relative);null==e&&"/"!==t&&(c.pathname="/"===c.pathname?t:ie([t,c.pathname])),(r.replace?a.replace:a.push)(c,r.state,r)}),[t,a,o,s,e]);return c}()}function Ne(e,t){let{relative:n}=void 0===t?{}:t,{future:a}=E.useContext(ye),{matches:r}=E.useContext(ve),{pathname:s}=ke(),o=JSON.stringify(se(r,a.v7_relativeSplatPath));return E.useMemo((()=>oe(e,JSON.parse(o),s,"path"===n)),[e,o,s,n])}function Ce(e,t,n,a){we()||D(!1);let{navigator:r}=E.useContext(ye),{matches:s}=E.useContext(ve),o=s[s.length-1],i=o?o.params:{},c=(o&&o.pathname,o?o.pathnameBase:"/");o&&o.route;let l,u=ke();if(t){var h;let e="string"===typeof t?B(t):t;"/"===c||(null==(h=e.pathname)?void 0:h.startsWith(c))||D(!1),l=e}else l=u;let d=l.pathname||"/",p=V(e,{pathname:"/"===c?d:d.slice(c.length)||"/"});let f=_e(p&&p.map((e=>Object.assign({},e,{params:Object.assign({},i,e.params),pathname:ie([c,r.encodeLocation?r.encodeLocation(e.pathname).pathname:e.pathname]),pathnameBase:"/"===e.pathnameBase?c:ie([c,r.encodeLocation?r.encodeLocation(e.pathnameBase).pathname:e.pathnameBase])}))),s,n,a);return t&&f?E.createElement(be.Provider,{value:{location:fe({pathname:"/",search:"",hash:"",state:null,key:"default"},l),navigationType:T.Pop}},f):f}function Te(){let e=function(){var e;let t=E.useContext(xe),n=Me(Oe.UseRouteError),a=Le(Oe.UseRouteError);if(void 0!==t)return t;return null==(e=n.errors)?void 0:e[a]}(),t=he(e)?e.status+" "+e.statusText:e instanceof Error?e.message:JSON.stringify(e),n=e instanceof Error?e.stack:null,a="rgba(200,200,200, 0.5)",r={padding:"0.5rem",backgroundColor:a};return E.createElement(E.Fragment,null,E.createElement("h2",null,"Unexpected Application Error!"),E.createElement("h3",{style:{fontStyle:"italic"}},t),n?E.createElement("pre",{style:r},n):null,null)}const Ee=E.createElement(Te,null);class Re extends E.Component{constructor(e){super(e),this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,t){return t.location!==e.location||"idle"!==t.revalidation&&"idle"===e.revalidation?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:void 0!==e.error?e.error:t.error,location:t.location,revalidation:e.revalidation||t.revalidation}}componentDidCatch(e,t){console.error("React Router caught the following error during render",e,t)}render(){return void 0!==this.state.error?E.createElement(ve.Provider,{value:this.props.routeContext},E.createElement(xe.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function Ae(e){let{routeContext:t,match:n,children:a}=e,r=E.useContext(me);return r&&r.static&&r.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(r.staticContext._deepestRenderedBoundaryId=n.route.id),E.createElement(ve.Provider,{value:t},a)}function _e(e,t,n,a){var r;if(void 0===t&&(t=[]),void 0===n&&(n=null),void 0===a&&(a=null),null==e){var s;if(null==(s=n)||!s.errors)return null;e=n.matches}let o=e,i=null==(r=n)?void 0:r.errors;if(null!=i){let e=o.findIndex((e=>e.route.id&&(null==i?void 0:i[e.route.id])));e>=0||D(!1),o=o.slice(0,Math.min(o.length,e+1))}let c=!1,l=-1;if(n&&a&&a.v7_partialHydration)for(let u=0;u<o.length;u++){let e=o[u];if((e.route.HydrateFallback||e.route.hydrateFallbackElement)&&(l=u),e.route.id){let{loaderData:t,errors:a}=n,r=e.route.loader&&void 0===t[e.route.id]&&(!a||void 0===a[e.route.id]);if(e.route.lazy||r){c=!0,o=l>=0?o.slice(0,l+1):[o[0]];break}}}return o.reduceRight(((e,a,r)=>{let s,u=!1,h=null,d=null;var p;n&&(s=i&&a.route.id?i[a.route.id]:void 0,h=a.route.errorElement||Ee,c&&(l<0&&0===r?(p="route-fallback",!1||Pe[p]||(Pe[p]=!0),u=!0,d=null):l===r&&(u=!0,d=a.route.hydrateFallbackElement||null)));let f=t.concat(o.slice(0,r+1)),m=()=>{let t;return t=s?h:u?d:a.route.Component?E.createElement(a.route.Component,null):a.route.element?a.route.element:e,E.createElement(Ae,{match:a,routeContext:{outlet:e,matches:f,isDataRoute:null!=n},children:t})};return n&&(a.route.ErrorBoundary||a.route.errorElement||0===r)?E.createElement(Re,{location:n.location,revalidation:n.revalidation,component:h,error:s,children:m(),routeContext:{outlet:null,matches:f,isDataRoute:!0}}):m()}),null)}var Fe=function(e){return e.UseBlocker="useBlocker",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e}(Fe||{}),Oe=function(e){return e.UseBlocker="useBlocker",e.UseLoaderData="useLoaderData",e.UseActionData="useActionData",e.UseRouteError="useRouteError",e.UseNavigation="useNavigation",e.UseRouteLoaderData="useRouteLoaderData",e.UseMatches="useMatches",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e.UseRouteId="useRouteId",e}(Oe||{});function De(e){let t=E.useContext(me);return t||D(!1),t}function Me(e){let t=E.useContext(ge);return t||D(!1),t}function Le(e){let t=function(e){let t=E.useContext(ve);return t||D(!1),t}(),n=t.matches[t.matches.length-1];return n.route.id||D(!1),n.route.id}const Pe={};R.startTransition;function ze(e){D(!1)}function Be(e){let{basename:t="/",children:n=null,location:a,navigationType:r=T.Pop,navigator:s,static:o=!1,future:i}=e;we()&&D(!1);let c=t.replace(/^\/*/,"/"),l=E.useMemo((()=>({basename:c,navigator:s,static:o,future:fe({v7_relativeSplatPath:!1},i)})),[c,i,s,o]);"string"===typeof a&&(a=B(a));let{pathname:u="/",search:h="",hash:d="",state:p=null,key:f="default"}=a,m=E.useMemo((()=>{let e=ne(u,c);return null==e?null:{location:{pathname:e,search:h,hash:d,state:p,key:f},navigationType:r}}),[c,u,h,d,p,f,r]);return null==m?null:E.createElement(ye.Provider,{value:l},E.createElement(be.Provider,{children:n,value:m}))}function We(e){let{children:t,location:n}=e;return Ce(Ue(t),n)}new Promise((()=>{}));E.Component;function Ue(e,t){void 0===t&&(t=[]);let n=[];return E.Children.forEach(e,((e,a)=>{if(!E.isValidElement(e))return;let r=[...t,a];if(e.type===E.Fragment)return void n.push.apply(n,Ue(e.props.children,r));e.type!==ze&&D(!1),e.props.index&&e.props.children&&D(!1);let s={id:e.props.id||r.join("-"),caseSensitive:e.props.caseSensitive,element:e.props.element,Component:e.props.Component,index:e.props.index,path:e.props.path,loader:e.props.loader,action:e.props.action,errorElement:e.props.errorElement,ErrorBoundary:e.props.ErrorBoundary,hasErrorBoundary:null!=e.props.ErrorBoundary||null!=e.props.errorElement,shouldRevalidate:e.props.shouldRevalidate,handle:e.props.handle,lazy:e.props.lazy};e.props.children&&(s.children=Ue(e.props.children,r)),n.push(s)})),n}function Ve(){return Ve=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},Ve.apply(this,arguments)}function Ge(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);const je=["onClick","relative","reloadDocument","replace","state","target","to","preventScrollReset","unstable_viewTransition"];try{window.__reactRouterVersion="6"}catch(qV){}new Map;const He=R.startTransition;_.flushSync,R.useId;function Ke(e){let{basename:t,children:n,future:a,window:r}=e,s=E.useRef();var o;null==s.current&&(s.current=(void 0===(o={window:r,v5Compat:!0})&&(o={}),W((function(e,t){let{pathname:n,search:a,hash:r}=e.location;return P("",{pathname:n,search:a,hash:r},t.state&&t.state.usr||null,t.state&&t.state.key||"default")}),(function(e,t){return"string"===typeof t?t:z(t)}),null,o)));let i=s.current,[c,l]=E.useState({action:i.action,location:i.location}),{v7_startTransition:u}=a||{},h=E.useCallback((e=>{u&&He?He((()=>l(e))):l(e)}),[l,u]);return E.useLayoutEffect((()=>i.listen(h)),[i,h]),E.createElement(Be,{basename:t,children:n,location:c.location,navigationType:c.action,navigator:i,future:a})}const qe="undefined"!==typeof window&&"undefined"!==typeof window.document&&"undefined"!==typeof window.document.createElement,Xe=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,Ye=E.forwardRef((function(e,t){let n,{onClick:a,relative:r,reloadDocument:s,replace:o,state:i,target:c,to:l,preventScrollReset:u,unstable_viewTransition:h}=e,d=Ge(e,je),{basename:p}=E.useContext(ye),f=!1;if("string"===typeof l&&Xe.test(l)&&(n=l,qe))try{let e=new URL(window.location.href),t=l.startsWith("//")?new URL(e.protocol+l):new URL(l),n=ne(t.pathname,p);t.origin===e.origin&&null!=n?l=n+t.search+t.hash:f=!0}catch(qV){}let m=function(e,t){let{relative:n}=void 0===t?{}:t;we()||D(!1);let{basename:a,navigator:r}=E.useContext(ye),{hash:s,pathname:o,search:i}=Ne(e,{relative:n}),c=o;return"/"!==a&&(c="/"===o?a:ie([a,o])),r.createHref({pathname:c,search:i,hash:s})}(l,{relative:r}),g=function(e,t){let{target:n,replace:a,state:r,preventScrollReset:s,relative:o,unstable_viewTransition:i}=void 0===t?{}:t,c=Ie(),l=ke(),u=Ne(e,{relative:o});return E.useCallback((t=>{if(function(e,t){return 0===e.button&&(!t||"_self"===t)&&!function(e){return!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}(e)}(t,n)){t.preventDefault();let n=void 0!==a?a:z(l)===z(u);c(e,{replace:n,state:r,preventScrollReset:s,relative:o,unstable_viewTransition:i})}}),[l,c,u,a,r,n,e,s,o,i])}(l,{replace:o,state:i,target:c,preventScrollReset:u,relative:r,unstable_viewTransition:h});return E.createElement("a",Ve({},d,{href:n||m,onClick:f||s?a:function(e){a&&a(e),e.defaultPrevented||g(e)},ref:t,target:c}))}));var Ze,Qe;(function(e){e.UseScrollRestoration="useScrollRestoration",e.UseSubmit="useSubmit",e.UseSubmitFetcher="useSubmitFetcher",e.UseFetcher="useFetcher",e.useViewTransitionState="useViewTransitionState"})(Ze||(Ze={})),function(e){e.UseFetcher="useFetcher",e.UseFetchers="useFetchers",e.UseScrollRestoration="useScrollRestoration"}(Qe||(Qe={}));var Je=n(496);const $e=(0,E.createContext)();const et=e=>{let{children:t}=e;const[n,a]=(0,E.useState)(0),[r,s]=(0,E.useState)(0),[o,i]=(0,E.useState)(0),[c,l]=(0,E.useState)(0),[u,h]=(0,E.useState)("Tree"),[d,p]=(0,E.useState)(!1);return(0,Je.jsx)($e.Provider,{value:{startYoga:e=>{p(e)},stopPose:function(){p(!1),clearInterval(undefined)},startingTimefunc:e=>{a(e)},currentTimefunc:e=>{s(e)},poseTimefunc:e=>{i(e)},bestPerformfunc:e=>{l(e)},setCurrentPosefunc:e=>{h(e)},startingTime:n,currentTime:r,poseTime:o,bestPerform:c,currentPose:u,isStartPose:d},children:t})},tt=$e;const nt=n.p+"static/media/carousel1.3ab5bea37f682927a45f2c6f4a1dd8df.svg";const at=n.p+"static/media/carousel2.1e8ef45f5a214428ac039b14dc9e8862.svg";const rt=n.p+"static/media/carousel3.55907215a815436de9c8a730394ff2d6.svg";function st(){return(0,Je.jsxs)("div",{className:"home-container",children:[(0,Je.jsxs)("div",{className:"home-header",children:[(0,Je.jsx)("div",{className:"home-heading",children:(0,Je.jsxs)("svg",{viewBox:"0 0 114 110",fill:"none",xmlns:"http://www.w3.org/2000/svg",children:[(0,Je.jsx)("path",{d:"M2.196 31.2557C3.604 35.0317 5.444 38.0717 7.716 40.3757C9.988 42.6797 12.324 43.8317 14.724 43.8317C15.972 43.8317 17.108 43.5437 18.132 42.9677C19.188 42.3917 20.02 41.6237 20.628 40.6637C21.268 39.6717 21.588 38.6157 21.588 37.4957C21.588 36.3117 21.044 34.9357 19.956 33.3677C19.188 34.2317 18.356 34.9037 17.46 35.3837C16.564 35.8637 15.7 36.1037 14.868 36.1037C13.812 36.1037 12.676 35.7677 11.46 35.0957C10.276 34.3917 9.268 33.5277 8.436 32.5037C7.636 31.4797 7.236 30.4877 7.236 29.5277C7.236 28.3757 7.764 27.3837 8.82 26.5517C9.876 25.6877 11.092 25.2557 12.468 25.2557C13.3 25.2557 14.164 25.4957 15.06 25.9757C15.988 26.4237 16.836 27.0637 17.604 27.8957C18.18 27.3197 18.628 26.5997 18.948 25.7357C19.268 24.8717 19.428 24.0077 19.428 23.1437C19.428 22.0557 19.092 21.1437 18.42 20.4077C17.748 19.6717 16.868 19.3037 15.78 19.3037C14.404 19.3037 13.012 19.6237 11.604 20.2637C10.196 20.9037 8.884 21.7997 7.668 22.9517L3.444 18.5837C4.5 17.5917 5.78 16.8397 7.284 16.3277C8.82 15.8157 10.5 15.5597 12.324 15.5597C14.212 15.5597 16.036 16.0717 17.796 17.0957C19.588 18.0877 21.028 19.3677 22.116 20.9357C23.236 22.5037 23.796 24.0557 23.796 25.5917C23.796 27.0957 23.412 28.5677 22.644 30.0077C23.22 30.6157 24.036 30.9197 25.092 30.9197C25.924 30.9197 26.74 30.7597 27.54 30.4397C28.372 30.1197 29.092 29.6397 29.7 28.9997V21.8957H25.428L21.06 16.6637H30.612L35.268 21.8957V45.0797C35.268 45.6877 35.716 46.4077 36.612 47.2397C37.508 48.0397 38.548 48.7437 39.732 49.3517C40.948 49.9277 41.972 50.2157 42.804 50.2157C44.02 50.2157 44.98 49.6557 45.684 48.5357L50.58 51.4637C50.068 52.0717 49.46 52.5357 48.756 52.8557C48.052 53.1757 47.332 53.3357 46.596 53.3357C44.676 53.3357 42.372 52.6477 39.684 51.2717C36.996 49.9277 34.66 48.3437 32.676 46.5197C30.692 44.6637 29.7 43.0797 29.7 41.7677V34.0397C28.932 34.3277 28.196 34.4717 27.492 34.4717C25.924 34.4717 24.02 33.4797 21.78 31.4957L21.3 32.0717C22.644 33.5437 23.684 35.0317 24.42 36.5357C25.156 38.0397 25.524 39.4637 25.524 40.8077C25.524 42.2477 25.172 43.5757 24.468 44.7917C23.764 46.0077 22.804 46.9837 21.588 47.7197C20.404 48.4237 19.108 48.7757 17.7 48.7757C15.46 48.7757 13.22 48.0717 10.98 46.6637C8.74 45.2557 6.692 43.2877 4.836 40.7597C2.98 38.2317 1.46 35.3357 0.276 32.0717L2.196 31.2557ZM33.396 16.6637H40.692V21.8957H38.004L33.396 16.6637ZM12.084 32.6957C12.564 32.6957 13.188 32.4397 13.956 31.9277C14.724 31.4157 15.588 30.6317 16.548 29.5757C16.036 28.9037 15.46 28.5677 14.82 28.5677C14.116 28.5677 13.332 28.9357 12.468 29.6717C11.636 30.4077 11.22 31.0957 11.22 31.7357C11.22 31.9917 11.3 32.2157 11.46 32.4077C11.652 32.5997 11.86 32.6957 12.084 32.6957ZM80.2208 51.4637C79.2288 52.7117 77.9168 53.3357 76.2848 53.3357C74.3008 53.3357 71.9808 52.6317 69.3247 51.2237C66.7008 49.8157 64.4128 48.1837 62.4608 46.3277C60.5088 44.4717 59.5328 43.0317 59.5328 42.0077V40.0397C58.7968 40.7757 57.9648 41.3517 57.0368 41.7677C56.1408 42.1837 55.2128 42.3917 54.2528 42.3917C52.3008 42.3917 50.3648 41.8477 48.4448 40.7597C46.5568 39.6397 45.0048 38.2477 43.7888 36.5837C42.6048 34.8877 42.0128 33.2717 42.0128 31.7357C42.0128 30.5197 42.4128 29.3837 43.2127 28.3277C44.0128 27.2717 45.0688 26.4237 46.3807 25.7837C47.6928 25.1437 49.0688 24.8237 50.5088 24.8237C52.1408 24.8237 53.7248 25.2077 55.2608 25.9757C56.8288 26.7437 58.1728 27.8157 59.2928 29.1917V21.8957H39.3247V16.6637H59.7248L64.9088 21.8957V45.0797C64.9088 45.6877 65.3408 46.4077 66.2048 47.2397C67.0688 48.0397 68.0768 48.7437 69.2288 49.3517C70.4128 49.9277 71.4208 50.2157 72.2528 50.2157C73.4368 50.2157 74.4608 49.6397 75.3248 48.4877L80.2208 51.4637ZM67.6448 21.8957L62.4128 16.6637H70.3328V21.8957H67.6448ZM59.2928 31.3997C58.6848 30.5997 57.9968 29.9757 57.2288 29.5277C56.4608 29.0477 55.7088 28.8077 54.9728 28.8077C53.6288 28.8077 52.2848 29.1437 50.9408 29.8157L56.7488 36.2477C57.7088 35.5117 58.5568 34.6637 59.2928 33.7037V31.3997ZM49.8848 38.4557C51.6768 38.4557 53.3568 38.0717 54.9248 37.3037L49.0688 30.9677C48.2368 31.6397 47.5647 32.3757 47.0527 33.1757C46.5727 33.9757 46.3327 34.7597 46.3327 35.5277C46.3327 36.3277 46.6848 37.0157 47.3888 37.5917C48.0928 38.1677 48.9248 38.4557 49.8848 38.4557ZM53.1221 7.11174C53.1221 6.08775 53.4421 5.09575 54.0821 4.13575C54.6901 3.14375 55.5061 2.34375 56.5301 1.73575C57.5221 1.12775 58.5781 0.823746 59.6981 0.823746C60.6901 0.823746 61.7621 1.22375 62.9141 2.02375C64.0661 2.79175 65.1701 3.84775 66.2261 5.19175L64.8341 6.39175C64.5141 6.00775 64.1461 5.70375 63.7301 5.47975C63.2821 5.25575 62.8501 5.14375 62.4341 5.14375C61.4101 5.14375 60.5141 5.63975 59.7461 6.63175C58.9461 7.62375 58.5461 8.74375 58.5461 9.99174C58.5461 12.2957 59.7621 14.5197 62.1941 16.6637H59.9381C57.8901 15.1277 56.2421 13.5117 54.9941 11.8157C53.7461 10.1197 53.1221 8.55175 53.1221 7.11174ZM69.0435 16.6637H93.4275L98.6115 21.8957V45.0797C98.6115 45.6877 99.0435 46.4077 99.9075 47.2397C100.772 48.0397 101.796 48.7437 102.98 49.3517C104.164 49.9277 105.172 50.2157 106.004 50.2157C106.548 50.2157 107.076 50.0557 107.588 49.7357C108.132 49.4477 108.612 49.0317 109.028 48.4877L113.972 51.4637C112.916 52.7117 111.556 53.3357 109.892 53.3357C108.068 53.3357 105.796 52.6477 103.076 51.2717C100.356 49.9277 97.9875 48.3277 95.9715 46.4717C93.9875 44.5837 92.9955 42.8877 92.9955 41.3837V35.0477C90.4675 32.6797 87.7315 31.4957 84.7875 31.4957C83.6995 31.4957 82.9315 31.6077 82.4835 31.8317C84.2755 33.2077 85.6835 34.6477 86.7075 36.1517C87.7315 37.6237 88.2435 38.9837 88.2435 40.2317C88.2435 41.5757 87.7155 42.7117 86.6595 43.6397C85.6355 44.5677 84.4355 45.0317 83.0595 45.0317C81.4915 45.0317 79.8115 44.4077 78.0195 43.1597C76.2595 41.9117 74.7715 40.3917 73.5555 38.5997C72.3715 36.7757 71.7795 35.0637 71.7795 33.4637C71.7795 32.2157 72.1955 31.0477 73.0275 29.9597C73.8915 28.8717 75.0435 28.0077 76.4835 27.3677C77.9235 26.6957 79.4595 26.3597 81.0915 26.3597C83.1395 26.3597 85.1875 26.9037 87.2355 27.9917C89.2835 29.0477 91.2035 30.5517 92.9955 32.5037V21.8957H69.0435V16.6637ZM96.1635 16.6637H104.036V21.8957H101.396L96.1635 16.6637ZM78.8355 40.6157C80.0835 40.6157 81.1715 40.2317 82.0995 39.4637C83.0595 38.6957 83.5395 37.7677 83.5395 36.6797C83.5395 36.0717 83.2835 35.3997 82.7715 34.6637C82.2915 33.8957 81.6195 33.1597 80.7555 32.4557C79.2515 32.9677 78.0355 33.7037 77.1075 34.6637C76.2115 35.5917 75.7635 36.5677 75.7635 37.5917C75.7635 38.3277 76.0835 39.0157 76.7235 39.6557C77.3955 40.2957 78.0995 40.6157 78.8355 40.6157Z",fill:"#78290F"}),(0,Je.jsx)("path",{d:"M22.5675 87.8637C20.7755 93.1117 17.6715 95.7357 13.2555 95.7357C11.2395 95.7357 9.7035 95.0797 8.6475 93.7677C7.5915 92.4237 7.0635 90.7437 7.0635 88.7277V66.5517C7.0635 65.9117 6.9195 65.3837 6.6315 64.9677C6.3755 64.5197 5.9435 64.2957 5.3355 64.2957C4.8235 64.2957 4.3115 64.4557 3.7995 64.7757C3.3195 65.0637 2.9195 65.4317 2.5995 65.8797L1.4955 64.9197C3.0635 62.5197 5.0795 61.3197 7.5435 61.3197C9.3035 61.3197 10.6635 61.8957 11.6235 63.0477C12.6155 64.1997 13.1115 65.7517 13.1115 67.7037V87.1917C13.1115 88.8877 13.2715 90.2797 13.5915 91.3677C13.9435 92.4557 14.6955 92.9997 15.8475 92.9997C17.3835 92.9997 18.6635 92.1677 19.6875 90.5037C20.7435 88.8077 21.5275 86.8717 22.0395 84.6957C22.5515 82.4877 22.8075 80.6477 22.8075 79.1757V62.7597L28.8075 60.8397V94.4397C28.8075 96.5837 28.2795 98.5677 27.2235 100.392C26.1675 102.216 24.7275 103.672 22.9035 104.76C21.1115 105.848 19.1435 106.392 16.9995 106.392C15.3035 106.392 13.8155 106.168 12.5355 105.72C11.2555 105.272 10.0875 104.6 9.0315 103.704L13.5915 99.7677C14.1035 100.856 14.8075 101.816 15.7035 102.648C16.6315 103.512 17.6235 103.944 18.6795 103.944C20.0235 103.944 21.0475 103.448 21.7515 102.456C22.4555 101.496 22.8075 100.312 22.8075 98.9037V87.8637H22.5675ZM46.1468 72.3117C44.0348 73.8157 42.3708 75.5277 41.1548 77.4477C39.9708 79.3357 39.3788 81.5597 39.3788 84.1197C39.3788 85.5277 39.6508 86.9517 40.1948 88.3917C40.7388 89.8317 41.5388 91.0317 42.5948 91.9917C43.6508 92.9197 44.9148 93.3837 46.3868 93.3837C48.2428 93.3837 49.7308 92.7117 50.8508 91.3677C52.0028 90.0237 52.5788 88.3597 52.5788 86.3757C52.5788 84.8717 52.1788 83.3517 51.3788 81.8157C50.6108 80.2477 49.5708 78.9357 48.2588 77.8797C46.9468 76.7917 45.5388 76.1837 44.0348 76.0557C44.7068 75.3197 45.4268 74.6477 46.1948 74.0397C46.9948 73.4317 47.9868 72.6957 49.1708 71.8317C51.4748 72.5997 53.2988 74.0237 54.6428 76.1037C56.0188 78.1837 56.7068 80.4717 56.7068 82.9677C56.7068 85.1757 56.2108 87.3197 55.2188 89.3997C54.2588 91.4797 52.8508 93.1757 50.9948 94.4877C49.1708 95.7677 47.0428 96.4077 44.6108 96.4077C42.5948 96.4077 40.7388 95.9437 39.0428 95.0157C37.3788 94.0557 36.0508 92.7597 35.0588 91.1277C34.0668 89.4637 33.5707 87.6397 33.5707 85.6557C33.5707 82.2317 34.6428 79.2237 36.7868 76.6317C38.9628 74.0397 41.7788 72.2317 45.2348 71.2077L46.1468 72.3117ZM73.7284 71.3037C75.3924 71.3037 76.9604 71.7037 78.4324 72.5037C79.9364 73.3037 81.0564 74.4237 81.7924 75.8637L77.1364 77.7837C76.6564 76.6957 76.0164 75.8637 75.2164 75.2877C74.4484 74.6797 73.6004 74.3757 72.6724 74.3757C71.2964 74.3757 70.0804 74.9037 69.0244 75.9597C67.9684 76.9837 67.1524 78.2637 66.5764 79.7997C66.0324 81.3357 65.7604 82.8397 65.7604 84.3117C65.7604 86.5837 66.1604 88.5677 66.9604 90.2637C67.7604 91.9277 69.0404 92.7597 70.8004 92.7597C72.8164 92.7597 74.2084 91.7037 74.9764 89.5917C75.7764 87.4797 76.1764 85.2077 76.1764 82.7757V80.6637L81.8404 78.6477V93.3837C81.8404 95.8477 81.2004 98.3597 79.9204 100.92C78.6404 103.512 76.9124 105.64 74.7364 107.304C72.5604 109 70.2084 109.848 67.6804 109.848C65.8884 109.848 64.4164 109.256 63.2644 108.072L67.3444 104.184C68.3684 105.528 69.5684 106.2 70.9444 106.2C73.0884 106.2 74.4964 105.384 75.1684 103.752C75.8724 102.152 76.2244 100.024 76.2244 97.3677L76.1764 94.0077C76.1764 92.5677 76.3044 91.3997 76.5604 90.5037H76.1764C75.2484 92.2317 74.2084 93.6397 73.0564 94.7277C71.9044 95.7837 70.5124 96.3117 68.8804 96.3117C66.2564 96.3117 64.2244 95.3997 62.7844 93.5757C61.3444 91.7517 60.6244 89.4477 60.6244 86.6637C60.6244 84.0397 61.1684 81.5437 62.2564 79.1757C63.3764 76.8077 64.9284 74.9037 66.9124 73.4637C68.9284 72.0237 71.2004 71.3037 73.7284 71.3037ZM93.534 66.6957L90.51 67.6557L88.542 57.6237L95.214 55.3677L93.534 66.6957ZM95.07 91.3197C95.07 91.7997 95.182 92.1837 95.406 92.4717C95.63 92.7597 95.934 92.9037 96.318 92.9037C97.118 92.9037 97.934 92.3437 98.766 91.2237L99.63 92.1357C98.926 93.4157 98.014 94.3917 96.894 95.0637C95.806 95.7357 94.718 96.0717 93.63 96.0717C90.718 96.0717 89.262 94.3917 89.262 91.0317V73.7517L95.07 71.7357V91.3197Z",fill:"#1B7E8D"})]})}),(0,Je.jsx)(Ye,{to:"/about",children:(0,Je.jsx)("button",{className:"btn btn-secondary",id:"about-btn",children:"About"})})]}),(0,Je.jsxs)("div",{className:"home-main",children:[(0,Je.jsx)("div",{className:"carousel-container",children:(0,Je.jsx)("div",{id:"carouselExampleSlidesOnly",class:"carousel slide","data-bs-ride":"carousel",children:(0,Je.jsxs)("div",{class:"carousel-inner",children:[(0,Je.jsx)("div",{class:"carousel-item active",children:(0,Je.jsx)("img",{src:nt,id:"img-car",class:"d-block",alt:"..."})}),(0,Je.jsx)("div",{class:"carousel-item",children:(0,Je.jsx)("img",{src:at,id:"img-car",class:"d-block",alt:"..."})}),(0,Je.jsx)("div",{class:"carousel-item",children:(0,Je.jsx)("img",{src:rt,id:"img-car",class:"d-block",alt:"..."})})]})})}),(0,Je.jsxs)("div",{className:"btn-section",children:[(0,Je.jsx)(Ye,{to:"/start",children:(0,Je.jsx)("button",{className:"btn start-btn",children:"Let's Start"})}),(0,Je.jsx)(Ye,{to:"/tutorials",children:(0,Je.jsx)("button",{className:"btn start-btn",children:"Tutorials"})})]})]})]})}const ot={Tree:["DIfficulty:Easy","Start by standing straight with a long, tall back and your feet aligned and touching. Your arms should be straight along either side of your body.","Take a few breaths and find a place or object in the room to focus your attention. Slowly shift your weight to your left leg and begin to raise your right foot off the floor. Align the sole of your right foot with the inside of your left thigh. The toes should be pointing down and your pelvis should be completely straight.","Stretch your arms straight up toward the ceiling with palms pressed together forming an inverted V.","Hold and repeat. Hold the pose for as long as necessary, making sure to breathe properly. When you\u2019re ready to switch legs, exhale, and return to the pose to start again.",(0,Je.jsx)("a",{target:"blank",href:"https://classpass.com/movements/tree-pose",children:"Know More"})],Chair:["Difficulty:Easy","Stand straight and tall with your feet slightly wider than hip\xad-width apart and your arms at your sides.","Inhale and lift your arms next to your ears, stretching them straight and parallel with wrists and fingers long. Keep your shoulders down and spine neutral.","Exhale as you bend your knees, keeping your thighs and knees parallel. Lean your torso forward to create a right angle with the tops of your thighs. Keep your neck and head in line with your torso and arms. Hold for 30 seconds to 1 minute.",(0,Je.jsx)("a",{target:"blank",href:"https://classpass.com/movements/chair-pose",children:"Know More"})],Dog:["Difficulty:Intermediate","Spread your hands wide on the mat with your arms internally rotated. Position your feet hip-width apart.","With your chin tucked into your chest and pelvic floor engaged, lift your hips and gaze at your toes through your legs. ",'Keep your legs straight and your heels on the mat. Your body should look like an upside-down "V".',"Stay in the pose for 10 or more breaths, then bend your knees on an exhalation and lower yourself.",(0,Je.jsx)("a",{target:"blank",href:"https://classpass.com/movements/downward-dog",children:"Know More"})],Cobra:["Difficulty:Easy","Begin on your belly with your feet hip-distance apart and your hands beside your ribs.Extend your big toes straight back and press down with all ten toenails to activate your quadriceps.","Rotate your inner thighs toward the ceiling to broaden the lower back.Pressing down lightly with your hands, start to lift your head and chest, rolling your shoulders back and down.","Keep the back of your neck long and focus on lifting your sternum instead of lifting your chin.Straighten your arms while keeping your shoulders remaining away from your ears. Keep at least a slight bend in your elbows.","To exit the pose, release back to your mat.",(0,Je.jsx)("a",{target:"blank",href:"https://www.yogajournal.com/poses/cobra-pose-2/",children:"Know More"})],Warrior:["Difficulty:Hard","Begin in lunge with your front knee bent, your back leg straight and your back heel lifted. Your hips and chest should be squared to front of the mat. Raise your arms above your head.","Move your hands to your heart, with palms pressed against each other in a prayer position. Lean forward until your back leg extends straight back, even with your hips. Keep your foot flexed and your gaze downward.","Make sure your standing leg is strong and straight, but not locked at knee. Reach your arms forward so your body forms a \u201cT\u201d shape.",(0,Je.jsx)("a",{target:"blank",href:"https://www.yogajournal.com/poses/warrior-3-pose/",children:"Know More"})],Traingle:["Difficulty:Medium","Begin standing, then lightly jump your feet apart to a wide position about three to four feet apart. Turn your left foot out and turn to face that direction. Take a slight bend in your left leg and raise your arms out on your sides, forming a \u201cT\u201d shape.","Straighten through your left leg, then hinge and reach your torso over your left leg as your hips jut back. Rotate your left palm so it faces the ceiling, and gaze out over your left arm.","Maintain a long, straight spine as you reach your left hand to the mat, placing it in front of your left foot. If you feel off balance, bring in your back leg closer to shorten your stance. Gaze towards your right arm, which should be extended overhead. Hold and repeat on the other side.",(0,Je.jsx)("a",{target:"blank",href:"https://classpass.com/movements/triangle-pose/",children:"Know More"})],Shoulderstand:["Difficulty:Hard","Start with a stack of two folded blankets. Lay down on your mat aligning shoulders onto the blankets. With legs bent and feet on the floor (as if setting up for bridge pose) begin to walk your shoulders underneath your upper back feeling the chest gently rising.","Lift your hips off of the mat coming into bridge pose and extend your arms onto the ground, palms facing down as if your hands could touch your heels. Press firmly into the palms using them as leverage to lift onto the balls of the feet and extend one leg up. Bend at the elbows, place your hands on your low back creating a shelf, and then extend the next leg up.","Once you raise the legs, don't turn your head to the side to look around the room, since you can injure your neck. Keep your gaze upward and your neck straight.","Lift up through the balls of your feet. Walk your hands further up the back for more stability. Feel the chest reaching towards the chin to support opening the upper back.","Move your hips toward the front of the room and your feet toward the back of the room to straighten the body. The correct alignment is with the hips over the shoulders and feet over the hips. Ask your teacher or a friend to help you determine if your legs are perpendicular to the floor.","Stay in the pose for up to 10 breaths",(0,Je.jsx)("a",{target:"blank",href:"https://www.verywellfit.com/shoulderstand-salamba-sarvangasana-3567115",children:"Know More"})]},it=["1. When App ask for permission of camera, allow it to access to capture pose.","2. Select what pose you want to do in the dropdown.","3. Read Instrctions of that pose so you will know how to do that pose.","4. Click on Start pose and see the image of the that pose in the right side and replecate that image in front of camera.","5. If you will do correctly the skeleton over the video will become green in color and sound will start playing"],ct=["Solution 1. Make sure you have allowed the permission of camera, if you have denined the permission, go to setting of your browser to allow the access of camera to the application.","Solution 2. Make sure no any other application is not accessing camera at that time, if yes, close that application","Solution 3. Try to close all the other opened broswers"],lt={NOSE:0,LEFT_EYE:1,RIGHT_EYE:2,LEFT_EAR:3,RIGHT_EAR:4,LEFT_SHOULDER:5,RIGHT_SHOULDER:6,LEFT_ELBOW:7,RIGHT_ELBOW:8,LEFT_WRIST:9,RIGHT_WRIST:10,LEFT_HIP:11,RIGHT_HIP:12,LEFT_KNEE:13,RIGHT_KNEE:14,LEFT_ANKLE:15,RIGHT_ANKLE:16},ut={nose:["left_ear","right_ear"],left_ear:["left_shoulder"],right_ear:["right_shoulder"],left_shoulder:["right_shoulder","left_elbow","left_hip"],right_shoulder:["right_elbow","right_hip"],left_elbow:["left_wrist"],right_elbow:["right_wrist"],left_hip:["left_knee","right_hip"],right_hip:["right_knee"],left_knee:["left_ankle"],right_knee:["right_ankle"]},ht=n.p+"static/media/cobra.f213f46b25c23aac3679.jpg",dt=n.p+"static/media/dog.6b3d1b154cef3cbf3112.jpg",pt={Tree:n.p+"static/media/tree.fb45711a5fb378d2cdc5.jpg",Cobra:ht,Dog:dt,Warrior:n.p+"static/media/warrior.ad323405cbcf62e55010.jpg",Chair:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmMAAAIJCAMAAADeecpzAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAC/VBMVEX+/Pv+7+3/4Nv/0cv+7er+6eb/1M7/y8T+5uP+4Nz/4Nz+2tX++ff+9vT/3dj/49//zsj/19L+49/+8/H/4+D+4+D/2tT/1M/+8O3+8/D+7On+19L/19H+6ub+3dn+5OD+7en+5uLu7Ouuraxvbm1fX14fHx9APz9/fn2+vbze3NsQEBAAAAAgICCfnp3/6eZgX17OzcwgHx/e3dwwLy9vbm6enZy/vbyPjo2enZ2/mJM/Pz4gIB9fXl7f3dxQT0/Ox8R/fn6voJ9/cnD/5uPu4+He19Xu4N2vjoo/MjHfxMC/q6eQfHmAbGmAaWaPe3i/p6X+19H+1M4wLy6QdnL/2tU/PDughYGekY/PrqkgHR3fuLMgGhmff3tPT06fjImvrazv1NCuqqn/3dn3wbnDhHSZUTzdo5fu5uXv1tP+4dyqZVKrZVPdo5Z4KQ+iXEfMjoDlrKKJPSWrZlOAMxrut67uvLTtycGJPSb+5+PMlIaANh7MoJSqbFqIQyzdr6TLrKKJRC2ZXUqzhXbmrKLt4d3dvraqeGeiW0eaXkrcx8C7koXUurL+3djdx8CIPSWRUTzl1M7u4t727+zDn5SraVb21tD2497l1M/ct667k4WyhXbMraPUtKqZVECZXkqJQyz25eLUraOiaFXuvbSaUjzUurGyfGzutq2SRzGzb17NjoG7emndopbutq7VmIv17+yZUjyqZlOzcF6ia1jMo5i7gHDLl4rUmIvdopeaUTyJQy3ut62zfGyqZlLMm47uwLeqcmHmraLuzMW8eWrEmo3DoJT27+3t4t7MlIeRSzTMkYPuw7u7hneRUTvtz8jDmY3Mp5uaXUrtzMXMpJjMlYeRSDHUmYv3x7/UsaeRRzHCn5SANh3EhHXLraOBMxr+3tm6koWpeGeha1jk1M7VmIyqeGiiZVKRUDu6k4X23Niia1mIRC2ha1nkxb327OnMmIqzhXeqbFnEkILmtq2zdmXk1M/lyMDcurLLoJXVurG0cF/+8vH+0cv///8mpTZEAAAAAWJLR0T+0gDCUwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB+YHBQQaAD4TLBoAABDxSURBVHja7d17mFVVGcdxxsPM4nLOcJip6TDMCMEoEGcAAQUlM9Myu0vR/e4wU0pLICxoirhIyGAIQkViSKWkhkRCF8rsrlSiZZapiJhFltjF7hefpzMXhnPZZ++111qvo87381c9jP+8z+9Z77vfvc/eAwYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4SqOSwykCpBTWaWUGkQdIHaGJVSnwVQCQoaobkMpBUQkq3oiphIUAxJSCdWLakD0FMtJUQ/4V50XMcXyAv4Ny48YywsIDGMFEWN5Af8ShRljeQHfKgsjxvIC3jtl0THG8gKeDDm6ohhSHDGWF/BjcLoyaODvNJzqwIcapao7D6zq0oypIZQHfjKmErVBxxjdEp56ZVeYnlUdmLFnUx+4q1MhnkN94K4qLGNp6gNnSRWKAsFZRXjGGPrhaeTnHEMfjWNkDO5S4RHjuhLOKsMzxuM9cFYXnrEaKgRX6fCMZagQHI0Ij5hKUiI4qg+P2EgqBFcR2zF+mQTpkb+WCsFVQ2jE+NEIpC8r+YElnCW5IQ5hFVxVQtig0Iw1UiDIri7SLGAhfFl5PPWB8GUlEz/cjWDih7B6Jn704cjPjh8+VHGMQVaSYwzCKrioRN+NY6OoDmTHMTolvCj/08oEnRJelP9p5WiKAy8aGMbQR5sL7oVDuFUmeKQHnpT5SVKaeR/CV5XcQ4Jwq2QYg/BVJZsxSLdKOiW8qeYeEoQlOMbQFxM/xxikJ34uKiE98fMqKAhP/LwoHdLHGBM/vHkuz/BDWIIfhkNWJa0SfXKM8S5+SB9jfBoJ0scYrRLCxxitEtLHGK0S0scYrRLCxxgLWEgfYyxg4UsDX3iDrAreNwZhdbwMCrJSfOENwqr5Nj366BhT1AbCxxibC0gfY2wuIHyM8YMkSB9jbC4gfYzx2114Ucm3kSDcKRN8uAZ91Sn5fTiCjBnbdMKJ48ZPMP4PhvHhcMTxvKaJ2W7Nk8z+i8lhX9wdSEVRdIY1ZfNMGeMaMX4tgiInTc0WaJ4W/d80hEWMcQyFJk3MFpk+xi1jPNeDwohlS50c3FKnjT2l6YTpJ84YUP6HIoxjKDE2G6T48nLMhJm5cPWcclOmnZo9jXEMpheUEwMz1lwQsJmziv51zKmnMY7B8IpyajYbcZBNmFX6rzPDPk7Pdgz5mspELDul5w9OmRX0r+MHMY7BsFOWi1j2+d1n2PTgf51ZF5YxblbimNPLZizbmcBZ5f5xRoJxDI7HWDb7gklnlP235hGMY3A+xrLjQ/5t0mDGMZiZmrXSPC3BOAYjL7SLWPbM+rCI8Sg/eo14keUxFn6zknEMvSrPssvYpFTocz08yo9edWdZHmPVinEMZsbbHWOh95EYx5DvFLtjLPSiknEM+cZYHWNnK8YxGBtncYyl0opxDMYmxM/YtAbFOIYYzowbsZOHhUeMcQyOIWt+cUTEGMdQYmyse5YvSURljHEMARsM88n/zKqoiPHsGEo1qnMmTc+eMW7c9HFTOs+0l6pzy0XsjCFREWMcQ2DIzs3O6LnMnDqxaUambMaaXxYZMZ4dQ6AxM2Y2NZ3eNHPmzJNy/y+ZLpOxiQYR45eVKC9Zf1xVz2cbgn9xmX25QcR4YzqMrjSDI/YKg4ipGsoHA8EP+b/SJGJ8wAZmTrSOGDeSYJ0xs4ixuYB1xl4V0SFrz3n1ua85b3aaG0kw89riiL0u4vhKV82pqXx99uiaDYhSdAdz4hvMGqV6IyGD4e6i8D0qzW8yjJjKnErGYLa7KHjPxZvfYhoxVUntYOik/IydZhwxFrAwd+xm0lvfZh4xNZTKwdTbj45i70jHiBgbWJh7Z8+z++9S8fAMLEyN6WyWE999vnG4Wua2tjH0I47xuUPsPVUqLj4vAvMry+YZtYnYEeNhfpg7feJ708oCT8HC2DBlpZbKwUxyjl3EGPphKJVQZAySaq0jRsZgZHLaOmI8zg/BaZ/rSpga4hKxUdQPkc53idgF1A+RO4sq63ylZw9mGINkxFi+QvoUo3oQjNiF897Hb3dhImV7irVq3cJbx2AQMevlfqu+iIesEc3h/lGrns8rCBCpIu2yF+MYQ6TJygmLMURGrGVuC3eQIBmxBQvf7xCxKiqIqHF/wSJ9scMwxo8qEbW0+MAifVGMTI3MpFKZ43svQ0fyOA+ifHCh1m2xh69kY1fK0sxiiFR5odaLzSO25Nh/mVlS08ghhmgf0lrP5xIScipynbK9hYcQIefDuWPsI+zzIWhpLmMfZUsBOctyEVveYBKwi/mKM6ysyGVspcn98EvaeBMnbKzKRUx/zOQYm9/GSxJhY3UuYu0VJhm7tI0vU8J24l8zyGziZxqDhY7OVrm2xuxp18uoF+xapb7s42YZW0m9YNcq9bo6o4xdvp56IbYNnRHTVzSYZUxvpGKIa1OMjKXb9SbeN4C4VsTI2EitP8FPQxBXe4yMfVLr+Z+iZLDYXGi92ei68tO5v7ySmiGeLd0Zu8ooY5/pvCPA1I94tnZnbKXJDjbdFchNFA1x1Ld2Z+zqSpORv+v6YBtVQxzVPRnTnzUb+Tt1UDbEH8dyA5nB82Of6znzKBvij2O54BgsLz6vOchgO44ZPc9/TW8eKRzij2NaXxv9ytfev91O5WDqC/qYqFcRXHfsT7m0hEWr1Pp642OMHRlsWmXODaERm5v/pyz7YahDF/hiSMQWFP4pdy1hZos2Ddl1Cwv/koMMZrZqw5AVR0zrLVQPcUf+bjsCI3bjopI/1KuoH+KO/D1rsp2lEbtBB2ARCwNrg7Kj5xWl7MaFgX/GHSUYWBEcHj3vS70Ba5nbWuaPOMgQbZcu78s37dixY/dNl4f8CQcZInVoNxxkiLLFMWMcZIiyVXOQQVR9q2vG2JEhXLV7xniLD0LtcY4Ydy0Rrt09YzxHhjDbPUSMqR9hVvvIGK8jg3Cr1LyODMKtkteRQbxV6vlkDLKtUusr+PAIgm3wFDH9FQ4yiI5jWn+VjCFQ6mu+MvZ1MoZAib2+MraGYiLIMKW+4Slj36SaCOqUSqmbF5ExyOl6nd0CPyFbTzlR6uyeN1h4Cdka9mMo7ZRH3/x680IPGfsW15UI7pTdIbvFPWPfJmMo0yl7PkLvfJR9h4yhXKf0c5R9l3EM5Ttlj++5HGXt36eiKBL0yZof2Gfsh8dTUhR1ykTQ68WsG+aV1QOpKQpVl3lPot3sfysFhUmntE7Z8nUUFGad8mjD3B3zN+K3UVAYd0qLsWzNPsqJWJ0yZsrW0CYRu1PGSRkJg12n7E3Zj34cFrBFl/6kittHsOyUvW7ff0fZjK1m1IdLp+yVuPOnwTHjO0koG7EqFdPwO392FxGDsdqEsjD853cXxmw1lUQZk9PKUvqaX1z6y6MPWXDvCOUMU44u3rt37z17fzWHUiJQskH5kUhSTLhfUIZFjEdeEag+TcQgaeO9N11+37ydHiKW5qWcCHL/ga4LwsXz3TM2mmqiVMfSiE84x7CEcqJUwWfdHnCL2CjKiRKriu43thEx+HXwQNGdxgcdBv9D1BPhfbLb4hbbiFVRT0T1yW7Xs96HLw8dCH68cB67V/jeWBS7toWIwdnG0G/UXL+T9T4cbT8Q/pOixTtZ78PpEPt15O/WFl/Ceh8ik1ieHexeYet+w9cI3EDEYNcnHzZ+V4XpUHaIqiLPqqUxXrlj9qwP633k+82BeC922sF6H/EcPBD3BXWR/ZLdK2ym/Rj9kogh30N2LwzewXofshEL7ZejKSvcGuXRkP2W9T4Mxn2nT9HsYPcK30uLkqV/CxFDqFirV8PHfQ5RVuRxjljp5M96H/m2+Phac2HIWO8j3zIvX50vCBm7V/gdxkpCRsRQYLXWnkPGeh8SnTL/B76jqSo8X1MWLWNZ70PsGNP6QXavkD3GtG4hYhA9xnR7+hA1hegxdpiKQvYY03xWF8W2+o0Y39pCsfpWrxFbQ0VRrNprxpbTKVHid16PMb7nhhJJv8cYBUWJCq8ZW0lBUaLGa8auoqAoUUfGIGyP15H/agqKEiv8bmA7qCiKPeI3Y9s2UlIU8XxDnG4J8YzpLdQUwhnTv6eokJz5CRlKrF5IyCDr7lZNyCDqDxIZI2TIUyeSMf0oezL0ahfJmL5jFaWF3IVl98afkKHHJqGM6fZNFBdddmkxTP6QbZadNy/pl+jUIZcxvW0z9YXclSX9Er3WSmZMP0q/xIBdogcZ/RLiBxn9EjlHhENGv0SHcMb0Nn5L0u89Jh0y+iVjf7t4yOiX/d128Yxxk7zf2yIfMs1N8n5uxZMQMoayfj6SHXkSQsaTi/3bvicjZAxlhEw+ZNxZImTS2nlHGSETR8j6d8ju0Fxe4hmwJ2NR1s8dbKdd4pkwlPEcRv+W/OPcS1qlry7Zk/X3o+yw/J6MF2L0+6lMvGHy4liIp4yLS0injJEM4imjW6IrZXfRLSFt82GxpWw715bo9qc/twmty/i+PXrtO3yEgwzS1knEjIkMxyQzS4bO3n+ES0s83U4z7o1DOmZM/QhomoMaMuv+csRbs0xSUgTHbPMmP49lb8xQT5RfaPiI2b1kDMIx20/GEBkzt9lsNxmD0ZWm/S3NB8gYjK4Abjto2zPbyBiM9xmWvwGgeogxmVktZwekqBxipGxt/JSNoFlCOGWVZAyxO2a8R8jqyBjiTf+djwA9HiNj66kZbIIW4+HsR2upF6wapvFbsv9Kq4Ql02/J/Y2MwdL9ZhFbTquEnY0PGx5jf+cYg5VVxncvbydjsIrYUtOIraFYkI2YXke1YDOLmUeMYwxWYjxJxjEGGw+ZR+ww1YKFZTHuVe6jXLCY9w/wG3HIMp/39fLbKBdEhzG+ZwOrTqkZ+CFrdYxOycAP4WtKOiWEB342/BA+xtrplBA+xm6lWpA9xuiUED7G6JSQPsbolBA+xh6jWLDRwfYVwvawfYWsVdynhLC1PNGDp8rEzzAG4YmfZ19hyfShnvWUCpbaWVtA1nbWFnhqtMqVVAqyrXI5hYLsVSVPW0C6VfK0Bewt5R4SZG3gHhKELeMeEoTt4R4S+n5zwTAGt83FfdxDgqhNF0V+HOkfVAlO49j8VoYx9O04xi924WYDwxiERW7HLqNGcLOFYQzCVvBAD4TxQA/6duTngR4Ij/zcQ4LwyM/aAtIjP2sLeNDO75AgaxePvkJYB7/YhbBNXFOi7y4ruaaE8GUlxxh8SGUe4RiDpGQiw+MWEDVE/ZMNP0Q7pVL/Ym8BSQml/s1TYxA0TCm1v0zG/kN54KFT5o4x9Th7C8ipzkVMtTLwQ3Lgz7n5FgZ+iB5jwSljNQZ/x1hQyuapFOWBx2OsJGX/VWmqA7/HWHfKdi/sSti1bUqNpDzwfYz1xGzv/HtaOv9HDeWB/2OswEDqA3eVYRlLVFdQIbhKqHDEDI4qVLR0dT2Fgs+JPzBmcyqTFAtW0srYnEo2soivXsUynJhBqFUSM4hdVQbHbBAxg6mUslQ16H9UDwLjWOHi7DhihmiDlRP2s4jUoFyxNUO4KteIDaWGCOd8jDVSQwhnjFYJ4YzRKiGdMVoloqQdM5auZuMP4etKlaCICDXYOWOKIiJUxjlioygiwiUcI3aIEiLCaLeIXUAFEel8l6vKJdQP0ZJzrCM2kr0FzDTazWSJDKWDecqOnx27TXI9idhSOd3dM1WbaawZPPS88jcBRi7hXjj8zGq1mSW5rD1RkK8nhg6mS8J/2FKZTKaxcXSmNsUBBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADx9/B/N4WGat+5ZPAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMi0wNy0wNVQwNDoyNTozMSswMDowMESv7WsAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjItMDctMDVUMDQ6MjU6MzErMDA6MDA18lXXAAAAAElFTkSuQmCC",Traingle:n.p+"static/media/traingle.56b023eb052038f5b535.jpg",Shoulderstand:n.p+"static/media/shoulderstand.734071aefd032d382407.jpg"};function ft(){const{currentPose:e}=(0,E.useContext)(tt);return(0,Je.jsxs)("div",{className:"instructions-container",children:[(0,Je.jsx)("ol",{className:"instructions-list",children:ot[e].map((e=>(0,Je.jsx)("li",{className:"instruction",children:e})))}),(0,Je.jsx)("img",{className:"pose-demo-img",src:pt[e],alt:"pose_images"})]})}function mt(e){let{poseList:t}=e;const{currentPose:n,setCurrentPosefunc:a}=(0,E.useContext)(tt);return(0,Je.jsxs)("div",{className:"dropdown dropdown-container",children:[(0,Je.jsx)("button",{className:"btn btn-secondary dropdown-toggle",type:"button","data-bs-toggle":"dropdown",id:"pose-dropdown-btn","aria-expanded":"false",children:n}),(0,Je.jsx)("ul",{class:"dropdown-menu dropdown-custom-menu","aria-labelledby":"dropdownMenuButton1",children:t.map((e=>(0,Je.jsx)("li",{onClick:()=>a(e),children:(0,Je.jsxs)("div",{class:"dropdown-item-container",children:[(0,Je.jsx)("p",{className:"dropdown-item-1",children:e}),(0,Je.jsx)("img",{src:pt[e],className:"dropdown-img",alt:"yoga_images"})]})})))})]})}let gt=["Tree","Chair","Cobra","Warrior","Dog","Shoulderstand","Traingle"];const yt=function(){const{startYoga:e}=(0,E.useContext)(tt);return(0,Je.jsxs)("div",{className:"yoga-container",children:[(0,Je.jsxs)("div",{className:"yoga-top",children:[(0,Je.jsxs)("svg",{className:"yoga-top-logo",width:"114",height:"110",viewBox:"0 0 114 110",fill:"none",xmlns:"http://www.w3.org/2000/svg",children:[(0,Je.jsx)("path",{d:"M2.196 31.2557C3.604 35.0317 5.444 38.0717 7.716 40.3757C9.988 42.6797 12.324 43.8317 14.724 43.8317C15.972 43.8317 17.108 43.5437 18.132 42.9677C19.188 42.3917 20.02 41.6237 20.628 40.6637C21.268 39.6717 21.588 38.6157 21.588 37.4957C21.588 36.3117 21.044 34.9357 19.956 33.3677C19.188 34.2317 18.356 34.9037 17.46 35.3837C16.564 35.8637 15.7 36.1037 14.868 36.1037C13.812 36.1037 12.676 35.7677 11.46 35.0957C10.276 34.3917 9.268 33.5277 8.436 32.5037C7.636 31.4797 7.236 30.4877 7.236 29.5277C7.236 28.3757 7.764 27.3837 8.82 26.5517C9.876 25.6877 11.092 25.2557 12.468 25.2557C13.3 25.2557 14.164 25.4957 15.06 25.9757C15.988 26.4237 16.836 27.0637 17.604 27.8957C18.18 27.3197 18.628 26.5997 18.948 25.7357C19.268 24.8717 19.428 24.0077 19.428 23.1437C19.428 22.0557 19.092 21.1437 18.42 20.4077C17.748 19.6717 16.868 19.3037 15.78 19.3037C14.404 19.3037 13.012 19.6237 11.604 20.2637C10.196 20.9037 8.884 21.7997 7.668 22.9517L3.444 18.5837C4.5 17.5917 5.78 16.8397 7.284 16.3277C8.82 15.8157 10.5 15.5597 12.324 15.5597C14.212 15.5597 16.036 16.0717 17.796 17.0957C19.588 18.0877 21.028 19.3677 22.116 20.9357C23.236 22.5037 23.796 24.0557 23.796 25.5917C23.796 27.0957 23.412 28.5677 22.644 30.0077C23.22 30.6157 24.036 30.9197 25.092 30.9197C25.924 30.9197 26.74 30.7597 27.54 30.4397C28.372 30.1197 29.092 29.6397 29.7 28.9997V21.8957H25.428L21.06 16.6637H30.612L35.268 21.8957V45.0797C35.268 45.6877 35.716 46.4077 36.612 47.2397C37.508 48.0397 38.548 48.7437 39.732 49.3517C40.948 49.9277 41.972 50.2157 42.804 50.2157C44.02 50.2157 44.98 49.6557 45.684 48.5357L50.58 51.4637C50.068 52.0717 49.46 52.5357 48.756 52.8557C48.052 53.1757 47.332 53.3357 46.596 53.3357C44.676 53.3357 42.372 52.6477 39.684 51.2717C36.996 49.9277 34.66 48.3437 32.676 46.5197C30.692 44.6637 29.7 43.0797 29.7 41.7677V34.0397C28.932 34.3277 28.196 34.4717 27.492 34.4717C25.924 34.4717 24.02 33.4797 21.78 31.4957L21.3 32.0717C22.644 33.5437 23.684 35.0317 24.42 36.5357C25.156 38.0397 25.524 39.4637 25.524 40.8077C25.524 42.2477 25.172 43.5757 24.468 44.7917C23.764 46.0077 22.804 46.9837 21.588 47.7197C20.404 48.4237 19.108 48.7757 17.7 48.7757C15.46 48.7757 13.22 48.0717 10.98 46.6637C8.74 45.2557 6.692 43.2877 4.836 40.7597C2.98 38.2317 1.46 35.3357 0.276 32.0717L2.196 31.2557ZM33.396 16.6637H40.692V21.8957H38.004L33.396 16.6637ZM12.084 32.6957C12.564 32.6957 13.188 32.4397 13.956 31.9277C14.724 31.4157 15.588 30.6317 16.548 29.5757C16.036 28.9037 15.46 28.5677 14.82 28.5677C14.116 28.5677 13.332 28.9357 12.468 29.6717C11.636 30.4077 11.22 31.0957 11.22 31.7357C11.22 31.9917 11.3 32.2157 11.46 32.4077C11.652 32.5997 11.86 32.6957 12.084 32.6957ZM80.2208 51.4637C79.2288 52.7117 77.9168 53.3357 76.2848 53.3357C74.3008 53.3357 71.9808 52.6317 69.3247 51.2237C66.7008 49.8157 64.4128 48.1837 62.4608 46.3277C60.5088 44.4717 59.5328 43.0317 59.5328 42.0077V40.0397C58.7968 40.7757 57.9648 41.3517 57.0368 41.7677C56.1408 42.1837 55.2128 42.3917 54.2528 42.3917C52.3008 42.3917 50.3648 41.8477 48.4448 40.7597C46.5568 39.6397 45.0048 38.2477 43.7888 36.5837C42.6048 34.8877 42.0128 33.2717 42.0128 31.7357C42.0128 30.5197 42.4128 29.3837 43.2127 28.3277C44.0128 27.2717 45.0688 26.4237 46.3807 25.7837C47.6928 25.1437 49.0688 24.8237 50.5088 24.8237C52.1408 24.8237 53.7248 25.2077 55.2608 25.9757C56.8288 26.7437 58.1728 27.8157 59.2928 29.1917V21.8957H39.3247V16.6637H59.7248L64.9088 21.8957V45.0797C64.9088 45.6877 65.3408 46.4077 66.2048 47.2397C67.0688 48.0397 68.0768 48.7437 69.2288 49.3517C70.4128 49.9277 71.4208 50.2157 72.2528 50.2157C73.4368 50.2157 74.4608 49.6397 75.3248 48.4877L80.2208 51.4637ZM67.6448 21.8957L62.4128 16.6637H70.3328V21.8957H67.6448ZM59.2928 31.3997C58.6848 30.5997 57.9968 29.9757 57.2288 29.5277C56.4608 29.0477 55.7088 28.8077 54.9728 28.8077C53.6288 28.8077 52.2848 29.1437 50.9408 29.8157L56.7488 36.2477C57.7088 35.5117 58.5568 34.6637 59.2928 33.7037V31.3997ZM49.8848 38.4557C51.6768 38.4557 53.3568 38.0717 54.9248 37.3037L49.0688 30.9677C48.2368 31.6397 47.5647 32.3757 47.0527 33.1757C46.5727 33.9757 46.3327 34.7597 46.3327 35.5277C46.3327 36.3277 46.6848 37.0157 47.3888 37.5917C48.0928 38.1677 48.9248 38.4557 49.8848 38.4557ZM53.1221 7.11174C53.1221 6.08775 53.4421 5.09575 54.0821 4.13575C54.6901 3.14375 55.5061 2.34375 56.5301 1.73575C57.5221 1.12775 58.5781 0.823746 59.6981 0.823746C60.6901 0.823746 61.7621 1.22375 62.9141 2.02375C64.0661 2.79175 65.1701 3.84775 66.2261 5.19175L64.8341 6.39175C64.5141 6.00775 64.1461 5.70375 63.7301 5.47975C63.2821 5.25575 62.8501 5.14375 62.4341 5.14375C61.4101 5.14375 60.5141 5.63975 59.7461 6.63175C58.9461 7.62375 58.5461 8.74375 58.5461 9.99174C58.5461 12.2957 59.7621 14.5197 62.1941 16.6637H59.9381C57.8901 15.1277 56.2421 13.5117 54.9941 11.8157C53.7461 10.1197 53.1221 8.55175 53.1221 7.11174ZM69.0435 16.6637H93.4275L98.6115 21.8957V45.0797C98.6115 45.6877 99.0435 46.4077 99.9075 47.2397C100.772 48.0397 101.796 48.7437 102.98 49.3517C104.164 49.9277 105.172 50.2157 106.004 50.2157C106.548 50.2157 107.076 50.0557 107.588 49.7357C108.132 49.4477 108.612 49.0317 109.028 48.4877L113.972 51.4637C112.916 52.7117 111.556 53.3357 109.892 53.3357C108.068 53.3357 105.796 52.6477 103.076 51.2717C100.356 49.9277 97.9875 48.3277 95.9715 46.4717C93.9875 44.5837 92.9955 42.8877 92.9955 41.3837V35.0477C90.4675 32.6797 87.7315 31.4957 84.7875 31.4957C83.6995 31.4957 82.9315 31.6077 82.4835 31.8317C84.2755 33.2077 85.6835 34.6477 86.7075 36.1517C87.7315 37.6237 88.2435 38.9837 88.2435 40.2317C88.2435 41.5757 87.7155 42.7117 86.6595 43.6397C85.6355 44.5677 84.4355 45.0317 83.0595 45.0317C81.4915 45.0317 79.8115 44.4077 78.0195 43.1597C76.2595 41.9117 74.7715 40.3917 73.5555 38.5997C72.3715 36.7757 71.7795 35.0637 71.7795 33.4637C71.7795 32.2157 72.1955 31.0477 73.0275 29.9597C73.8915 28.8717 75.0435 28.0077 76.4835 27.3677C77.9235 26.6957 79.4595 26.3597 81.0915 26.3597C83.1395 26.3597 85.1875 26.9037 87.2355 27.9917C89.2835 29.0477 91.2035 30.5517 92.9955 32.5037V21.8957H69.0435V16.6637ZM96.1635 16.6637H104.036V21.8957H101.396L96.1635 16.6637ZM78.8355 40.6157C80.0835 40.6157 81.1715 40.2317 82.0995 39.4637C83.0595 38.6957 83.5395 37.7677 83.5395 36.6797C83.5395 36.0717 83.2835 35.3997 82.7715 34.6637C82.2915 33.8957 81.6195 33.1597 80.7555 32.4557C79.2515 32.9677 78.0355 33.7037 77.1075 34.6637C76.2115 35.5917 75.7635 36.5677 75.7635 37.5917C75.7635 38.3277 76.0835 39.0157 76.7235 39.6557C77.3955 40.2957 78.0995 40.6157 78.8355 40.6157Z",fill:"#78290F"}),(0,Je.jsx)("path",{d:"M22.5675 87.8637C20.7755 93.1117 17.6715 95.7357 13.2555 95.7357C11.2395 95.7357 9.7035 95.0797 8.6475 93.7677C7.5915 92.4237 7.0635 90.7437 7.0635 88.7277V66.5517C7.0635 65.9117 6.9195 65.3837 6.6315 64.9677C6.3755 64.5197 5.9435 64.2957 5.3355 64.2957C4.8235 64.2957 4.3115 64.4557 3.7995 64.7757C3.3195 65.0637 2.9195 65.4317 2.5995 65.8797L1.4955 64.9197C3.0635 62.5197 5.0795 61.3197 7.5435 61.3197C9.3035 61.3197 10.6635 61.8957 11.6235 63.0477C12.6155 64.1997 13.1115 65.7517 13.1115 67.7037V87.1917C13.1115 88.8877 13.2715 90.2797 13.5915 91.3677C13.9435 92.4557 14.6955 92.9997 15.8475 92.9997C17.3835 92.9997 18.6635 92.1677 19.6875 90.5037C20.7435 88.8077 21.5275 86.8717 22.0395 84.6957C22.5515 82.4877 22.8075 80.6477 22.8075 79.1757V62.7597L28.8075 60.8397V94.4397C28.8075 96.5837 28.2795 98.5677 27.2235 100.392C26.1675 102.216 24.7275 103.672 22.9035 104.76C21.1115 105.848 19.1435 106.392 16.9995 106.392C15.3035 106.392 13.8155 106.168 12.5355 105.72C11.2555 105.272 10.0875 104.6 9.0315 103.704L13.5915 99.7677C14.1035 100.856 14.8075 101.816 15.7035 102.648C16.6315 103.512 17.6235 103.944 18.6795 103.944C20.0235 103.944 21.0475 103.448 21.7515 102.456C22.4555 101.496 22.8075 100.312 22.8075 98.9037V87.8637H22.5675ZM46.1468 72.3117C44.0348 73.8157 42.3708 75.5277 41.1548 77.4477C39.9708 79.3357 39.3788 81.5597 39.3788 84.1197C39.3788 85.5277 39.6508 86.9517 40.1948 88.3917C40.7388 89.8317 41.5388 91.0317 42.5948 91.9917C43.6508 92.9197 44.9148 93.3837 46.3868 93.3837C48.2428 93.3837 49.7308 92.7117 50.8508 91.3677C52.0028 90.0237 52.5788 88.3597 52.5788 86.3757C52.5788 84.8717 52.1788 83.3517 51.3788 81.8157C50.6108 80.2477 49.5708 78.9357 48.2588 77.8797C46.9468 76.7917 45.5388 76.1837 44.0348 76.0557C44.7068 75.3197 45.4268 74.6477 46.1948 74.0397C46.9948 73.4317 47.9868 72.6957 49.1708 71.8317C51.4748 72.5997 53.2988 74.0237 54.6428 76.1037C56.0188 78.1837 56.7068 80.4717 56.7068 82.9677C56.7068 85.1757 56.2108 87.3197 55.2188 89.3997C54.2588 91.4797 52.8508 93.1757 50.9948 94.4877C49.1708 95.7677 47.0428 96.4077 44.6108 96.4077C42.5948 96.4077 40.7388 95.9437 39.0428 95.0157C37.3788 94.0557 36.0508 92.7597 35.0588 91.1277C34.0668 89.4637 33.5707 87.6397 33.5707 85.6557C33.5707 82.2317 34.6428 79.2237 36.7868 76.6317C38.9628 74.0397 41.7788 72.2317 45.2348 71.2077L46.1468 72.3117ZM73.7284 71.3037C75.3924 71.3037 76.9604 71.7037 78.4324 72.5037C79.9364 73.3037 81.0564 74.4237 81.7924 75.8637L77.1364 77.7837C76.6564 76.6957 76.0164 75.8637 75.2164 75.2877C74.4484 74.6797 73.6004 74.3757 72.6724 74.3757C71.2964 74.3757 70.0804 74.9037 69.0244 75.9597C67.9684 76.9837 67.1524 78.2637 66.5764 79.7997C66.0324 81.3357 65.7604 82.8397 65.7604 84.3117C65.7604 86.5837 66.1604 88.5677 66.9604 90.2637C67.7604 91.9277 69.0404 92.7597 70.8004 92.7597C72.8164 92.7597 74.2084 91.7037 74.9764 89.5917C75.7764 87.4797 76.1764 85.2077 76.1764 82.7757V80.6637L81.8404 78.6477V93.3837C81.8404 95.8477 81.2004 98.3597 79.9204 100.92C78.6404 103.512 76.9124 105.64 74.7364 107.304C72.5604 109 70.2084 109.848 67.6804 109.848C65.8884 109.848 64.4164 109.256 63.2644 108.072L67.3444 104.184C68.3684 105.528 69.5684 106.2 70.9444 106.2C73.0884 106.2 74.4964 105.384 75.1684 103.752C75.8724 102.152 76.2244 100.024 76.2244 97.3677L76.1764 94.0077C76.1764 92.5677 76.3044 91.3997 76.5604 90.5037H76.1764C75.2484 92.2317 74.2084 93.6397 73.0564 94.7277C71.9044 95.7837 70.5124 96.3117 68.8804 96.3117C66.2564 96.3117 64.2244 95.3997 62.7844 93.5757C61.3444 91.7517 60.6244 89.4477 60.6244 86.6637C60.6244 84.0397 61.1684 81.5437 62.2564 79.1757C63.3764 76.8077 64.9284 74.9037 66.9124 73.4637C68.9284 72.0237 71.2004 71.3037 73.7284 71.3037ZM93.534 66.6957L90.51 67.6557L88.542 57.6237L95.214 55.3677L93.534 66.6957ZM95.07 91.3197C95.07 91.7997 95.182 92.1837 95.406 92.4717C95.63 92.7597 95.934 92.9037 96.318 92.9037C97.118 92.9037 97.934 92.3437 98.766 91.2237L99.63 92.1357C98.926 93.4157 98.014 94.3917 96.894 95.0637C95.806 95.7357 94.718 96.0717 93.63 96.0717C90.718 96.0717 89.262 94.3917 89.262 91.0317V73.7517L95.07 71.7357V91.3197Z",fill:"#1B7E8D"})]}),(0,Je.jsx)(mt,{poseList:gt})]}),(0,Je.jsx)(ft,{}),(0,Je.jsxs)("div",{className:"button-container",children:[(0,Je.jsx)("button",{onClick:e(!0),className:"secondary-btn",children:(0,Je.jsx)(Ye,{to:"/yoga",children:"Start Pose"})}),(0,Je.jsx)("button",{className:"secondary-btn",children:(0,Je.jsx)(Ye,{to:"/",children:"Home"})})]})]})};function bt(){return(0,Je.jsxs)("div",{className:"about-container",children:[(0,Je.jsx)("h1",{className:"about-heading",children:"About"}),(0,Je.jsxs)("div",{className:"about-main",children:[(0,Je.jsx)("p",{className:"about-content",children:"Yoga has been the way of life for centuries. By building Urban Yogi we have built a Yoga trainer website where learners can select the pose that they intend to do and then our unique pose detection and pose correction software shall help them navigate their learning experience. This is an open source project by a bunch of third year students."}),(0,Je.jsx)("p",{className:"about-content",children:"This AI first predicts keypoints or coordinates of different parts of the body(basically where they are present in an image) and then it use another classification model to classify the poses if someone is doing a pose and if AI detects that pose more than 95% probability and then it will notify you are doing correctly(by making virtual skeleton green). We have used Tensorflow pretrained Movenet Model To Predict the Keypoints and building a neural network top of that which uses these coordinates and classify a yoga pose. We have trained the model in python because of tensorflowJS we can leverage the support of browser so I converted the keras/tensorflow model to tensorflowJS."})]})]})}function vt(){return(0,Je.jsxs)("div",{className:"tutorials-container",children:[(0,Je.jsx)("h1",{className:"tutorials-heading",children:"Basic Tutorials"}),(0,Je.jsx)("div",{className:"tutorials-content-container",children:it.map((e=>(0,Je.jsx)("p",{className:"tutorials-content",children:e})))}),(0,Je.jsx)("h1",{className:"tutorials-heading",children:"Camera Not Working?"}),(0,Je.jsx)("div",{className:"tutorials-content-container",children:ct.map((e=>(0,Je.jsx)("p",{className:"tutorials-content",children:e})))})]})}var xt=n(232);class wt{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class kt{refCount(e){return St("refCount")}incRef(e){return St("incRef")}timerAvailable(){return!0}time(e){return St("time")}read(e){return St("read")}readSync(e){return St("readSync")}readToGPU(e,t){return St("readToGPU")}numDataIds(){return St("numDataIds")}disposeData(e,t){return St("disposeData")}write(e,t,n){return St("write")}move(e,t,n,a,r){return St("move")}memory(){return St("memory")}floatPrecision(){return St("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return St("dispose")}}function St(e){throw new Error("'".concat(e,"' not yet implemented or not found in the registry. ")+"This kernel may not be supported by the tfjs backend you have chosen")}function It(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Tt(e,t,n)}function Nt(e,t,n){return Math.max(e,Math.min(t,n))}function Ct(e){return e%2===0?e:e+1}function Tt(e,t,n){const a=e[t];e[t]=e[n],e[n]=a}function Et(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function Rt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";Et(Ot(e,t),(()=>n+" Shapes ".concat(e," and ").concat(t," must match")))}function At(e){Et(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function _t(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),Array.isArray(e)||jt(e)&&!n)for(let a=0;a<e.length;++a)_t(e[a],t,n);else t.push(e);return t}function Ft(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function Ot(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Dt(e){return e%1===0}function Mt(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Lt(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Pt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:setTimeout;return new Promise(((r,s)=>{let o=0;const i=()=>{if(e())return void r();o++;const c=t(o);null!=n&&o>=n?s():a(i,c)};i()}))}function zt(e,t){let n=1,a=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(-1===e[s]){if(-1!==a)throw Error("Shapes can only have 1 implicit size. "+"Found -1 at dim ".concat(a," and dim ").concat(s));a=s}else if(e[s]<0)throw Error("Shapes can not be < 0. Found ".concat(e[s]," at dim ").concat(s));if(-1===a){if(t>0&&t!==n)throw Error("Size(".concat(t,") must match the product of shape ").concat(e));return e}if(0===n)throw Error("Cannot infer the missing size in [".concat(e,"] when ")+"there are 0 elements");if(t%n!==0)throw Error("The implicit shape can't be a fractional number. "+"Got ".concat(t," / ").concat(n));const r=e.slice();return r[a]=t/n,r}function Bt(e,t){const n=t.length;return Et((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>"All values in axis param must be in range [-".concat(n,", ").concat(n,") but ")+"got axis ".concat(e))),Et(e.every((e=>Dt(e))),(()=>"All values in axis param must be integers but "+"got axis ".concat(e))),e.map((e=>e<0?n+e:e))}function Wt(e,t){const n=[],a=[],r=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||r?null:Bt(t,e).sort();let o=0;for(let i=0;i<e.length;++i){if(null!=s){if(s[o]===i&&1!==e[i])throw new Error("Can't squeeze axis ".concat(i," since its dim '").concat(e[i],"' is not 1"));(null==s[o]||s[o]>i)&&1===e[i]&&(n.push(e[i]),a.push(i)),s[o]<=i&&o++}1!==e[i]&&(n.push(e[i]),a.push(i))}return{newShape:n,keptDims:a}}function Ut(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error("Unknown data type ".concat(e));n=new Uint8Array(t)}return n}function Vt(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error("Unknown data type ".concat(e));n=new Array(t)}return n}function Gt(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function jt(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function Ht(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error("Unknown dtype ".concat(e))}function Kt(e){return"string"===typeof e||e instanceof String}function qt(e){return"number"===typeof e}function Xt(e){return Array.isArray(e)?Xt(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":qt(e)?"float32":Kt(e)?"string":"boolean"===typeof e?"bool":"float32"}function Yt(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Zt(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function Qt(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let a=t-3;a>=0;--a)n[a]=n[a+1]*e[a+1];return n}function Jt(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=new Array;if(1===t.length){const s=t[0]*(a?2:1);for(let t=0;t<s;t++)r[t]=n[e+t]}else{const s=t[0],o=t.slice(1),i=o.reduce(((e,t)=>e*t))*(a?2:1);for(let t=0;t<s;t++)r[t]=Jt(e+t*i,o,n,a)}return r}function $t(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];const a=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===a)return[];if(a!==t.length)throw new Error("[".concat(e,"] does not match the input size ").concat(t.length).concat(n?" for a complex tensor":"","."));return Jt(0,e,t,n)}function en(e,t){const n=tn(e,t);for(let a=0;a<n.length;a++)n[a]=1;return n}function tn(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error("Unknown data type ".concat(t))}function nn(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return $t(e,new Float32Array(n));if("int32"===t)return $t(e,new Int32Array(n));if("bool"===t)return $t(e,new Uint8Array(n));throw new Error("Unknown data type ".concat(t))}function an(e){e.forEach((t=>{Et(Number.isInteger(t)&&t>=0,(()=>"Tensor must have a shape comprised of positive integers but got "+"shape [".concat(e,"].")))}))}function rn(e,t,n){if(0===t)return 0;if(1===t)return e[0];let a=e[e.length-1];for(let r=0;r<e.length-1;++r)a+=n[r]*e[r];return a}function sn(e,t,n){if(0===t)return[];if(1===t)return[e];const a=new Array(t);for(let r=0;r<a.length-1;++r)a[r]=Math.floor(e/n[r]),e-=a[r]*n[r];return a[a.length-1]=e,a}function on(e){return e&&e.then&&"function"===typeof e.then}const cn="tfjsflags";class ln{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=un,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(hn().getBool("IS_TEST")||hn().getBool("PROD")||console.warn("Platform ".concat(this.platformName," has already been set. ")+"Overwriting the platform with ".concat(e,"."))),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];hn().getBool("IS_TEST")||hn().getBool("PROD")||console.warn("Setting feature override from URL ".concat(e,": ").concat(t,".")),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(on(t))throw new Error("Flag ".concat(e," cannot be synchronously evaluated. ")+"Please use getAsync() instead.");return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error("Cannot set flag ".concat(e," as it has not been registered."));this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error("Cannot evaluate flag '".concat(e,"': no evaluation function found."));return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(cn in e){e[cn].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if("".concat(+t)===t)return+t;throw new Error("Could not parse value flag value ".concat(t," for flag ").concat(e,"."))}(t,n)}))}}}function un(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,a=new Array(n>1?n-1:0),r=1;r<n;r++)a[r-1]=arguments[r];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,a[0],a[1]),a.join("=")})),t}function hn(){return pn}let dn,pn=null;function fn(){if(null==dn){let e;if("undefined"!==typeof window)e=window;else if("undefined"!==typeof n.g)e=n.g;else if("undefined"!==typeof process)e=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");e=self}dn=e}return dn}function mn(e,t){const n=function(){const e=fn();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const a=t();return n.set(e,a),n.get(e)}}const gn="Abs",yn="Acos",bn="Acosh",vn="Add",xn="AddN",wn="All",kn="Any",Sn="ArgMax",In="ArgMin",Nn="Asin",Cn="Asinh",Tn="Atan",En="Atanh",Rn="Atan2",An="AvgPool",_n="AvgPoolGrad",Fn="AvgPool3D",On="AvgPool3DGrad",Dn="BatchMatMul",Mn="BatchToSpaceND",Ln="Bincount",Pn="BroadcastArgs",zn="Cast",Bn="Ceil",Wn="ClipByValue",Un="Complex",Vn="ComplexAbs",Gn="Concat",jn="Conv2D",Hn="Conv2DBackpropFilter",Kn="Conv2DBackpropInput",qn="Conv3D",Xn="Conv3DBackpropFilterV2",Yn="Conv3DBackpropInputV2",Zn="Cos",Qn="Cosh",Jn="Cumprod",$n="Cumsum",ea="CropAndResize",ta="DenseBincount",na="DepthToSpace",aa="DepthwiseConv2dNative",ra="DepthwiseConv2dNativeBackpropFilter",sa="DepthwiseConv2dNativeBackpropInput",oa="Diag",ia="Dilation2D",ca="Dilation2DBackpropInput",la="Dilation2DBackpropFilter",ua="RealDiv",ha="Einsum",da="Elu",pa="EluGrad",fa="Erf",ma="Equal",ga="Exp",ya="ExpandDims",ba="Expm1",va="FFT",xa="Fill",wa="FlipLeftRight",ka="Floor",Sa="FloorDiv",Ia="FusedBatchNorm",Na="GatherV2",Ca="GatherNd",Ta="Greater",Ea="GreaterEqual",Ra="Identity",Aa="IFFT",_a="Imag",Fa="IsFinite",Oa="IsInf",Da="IsNan",Ma="LeakyRelu",La="Less",Pa="LessEqual",za="LinSpace",Ba="Log",Wa="Log1p",Ua="LogicalAnd",Va="LogicalNot",Ga="LogicalOr",ja="LRN",Ha="LRNGrad",Ka="Max",qa="Maximum",Xa="MaxPool",Ya="MaxPoolGrad",Za="MaxPool3D",Qa="MaxPool3DGrad",Ja="MaxPoolWithArgmax",$a="Mean",er="Min",tr="Minimum",nr="MirrorPad",ar="Mod",rr="Multinomial",sr="Multiply",or="Neg",ir="NotEqual",cr="NonMaxSuppressionV3",lr="NonMaxSuppressionV4",ur="NonMaxSuppressionV5",hr="OnesLike",dr="OneHot",pr="Pack",fr="PadV2",mr="Pow",gr="Prelu",yr="Prod",br="RaggedGather",vr="RaggedTensorToTensor",xr="Range",wr="Real",kr="Reciprocal",Sr="Relu",Ir="Reshape",Nr="ResizeNearestNeighbor",Cr="ResizeNearestNeighborGrad",Tr="ResizeBilinear",Er="ResizeBilinearGrad",Rr="Relu6",Ar="Reverse",_r="Round",Fr="Rsqrt",Or="ScatterNd",Dr="SearchSorted",Mr="Select",Lr="Selu",Pr="Slice",zr="Sin",Br="Sinh",Wr="Sign",Ur="Sigmoid",Vr="Softplus",Gr="Sqrt",jr="Sum",Hr="SpaceToBatchND",Kr="SplitV",qr="Softmax",Xr="SparseFillEmptyRows",Yr="SparseReshape",Zr="SparseSegmentMean",Qr="SparseSegmentSum",Jr="SparseToDense",$r="SquaredDifference",es="Square",ts="StridedSlice",ns="StringNGrams",as="StringSplit",rs="StringToHashBucketFast",ss="Sub",os="Tan",is="Tanh",cs="Tile",ls="TopK",us="Transform",hs="Transpose",ds="Unique",ps="Unpack",fs="UnsortedSegmentSum",ms="ZerosLike",gs="Step",ys="FromPixels",bs="RotateWithOffset",vs="_FusedMatMul",xs="FusedConv2D",ws="FusedDepthwiseConv2D";function ks(){hn().getBool("IS_TEST")||hn().getBool("PROD")||console.warn(...arguments)}function Ss(){hn().getBool("IS_TEST")||hn().getBool("PROD")||console.log(...arguments)}const Is=mn("kernelRegistry",(()=>new Map)),Ns=mn("gradRegistry",(()=>new Map));function Cs(e,t){const n=_s(e,t);return Is.get(n)}function Ts(e){return Ns.get(e)}function Es(e){const t=Is.entries(),n=[];for(;;){const{done:a,value:r}=t.next();if(a)break;const[s,o]=r,[i]=s.split("_");i===e&&n.push(o)}return n}function Rs(e){const{kernelName:t,backendName:n}=e,a=_s(t,n);Is.has(a)&&ks("The kernel '".concat(t,"' for backend ")+"'".concat(n,"' is already registered")),Is.set(a,e)}function As(e){const{kernelName:t}=e;Ns.has(t)&&hn().getBool("DEBUG")&&ks("Overriding the gradient for '".concat(t,"'")),Ns.set(t,e)}function _s(e,t){return"".concat(t,"_").concat(e)}var Fs=n(16);const Os=n.n(Fs)()||Fs;function Ds(e){return Os.fromString(e,!0,16)}const Ms=Ds("c3a5c85c97cb3127"),Ls=Ds("b492b66fbe98f273"),Ps=Ds("9ae16a3b2f90404f");function zs(e){return e.xor(e.shru(47))}function Bs(e,t,n){const a=e.slice(t,t+n);return Os.fromBytes(Array.from(a),!0,!0)}function Ws(e,t){return Bs(e,t,8)}function Us(e,t){return Bs(e,t,4)}function Vs(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function Gs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Ds("9ddfea08eb382d69"),a=e.xor(t).mul(n);a=a.xor(a.shru(47));let r=t.xor(a).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function js(e,t,n,a){return function(e,t,n,a,r,s){r=r.add(e),s=Vs(s.add(r).add(a),21);const o=r;return r=(r=r.add(t)).add(n),s=s.add(Vs(r,44)),[r.add(a),s.add(o)]}(Ws(e,t),Ws(e,t+8),Ws(e,t+16),Ws(e,t+24),n,a)}function Hs(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Os.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){const n=Ps.add(2*t),a=Ws(e,0).add(Ps),r=Ws(e,t-8);return Gs(Vs(r,37).mul(n).add(a),Vs(a,25).add(r).mul(n),n)}if(t>=4){const n=Ps.add(2*t);return Gs(Us(e,0).shl(3).add(t),Us(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),a=t+(e[t-1]<<2);return zs(Ps.mul(n).xor(Ms.mul(a))).mul(Ps)}return Ps}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Ps.add(2*t),a=Ws(e,0).mul(Ls),r=Ws(e,8),s=Ws(e,t-8).mul(n),o=Ws(e,t-16).mul(Ps);return Gs(Vs(a.add(r),43).add(Vs(s,30)).add(o),a.add(Vs(r.add(Ps),18)).add(s),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Ps.add(2*t),a=Ws(e,0).mul(Ps),r=Ws(e,8),s=Ws(e,t-8).mul(n),o=Ws(e,t-16).mul(Ps),i=Vs(a.add(r),43).add(Vs(s,30)).add(o),c=Gs(i,a.add(Vs(r.add(Ps),18)).add(s),n),l=Ws(e,16).mul(n),u=Ws(e,24),h=i.add(Ws(e,t-32)).mul(n),d=c.add(Ws(e,t-24)).mul(n);return Gs(Vs(l.add(u),43).add(Vs(h,30)).add(d),l.add(Vs(u.add(a),18)).add(h),n)}(e,t);let a=n,r=n.mul(Ls).add(113),s=zs(r.mul(Ps).add(113)).mul(Ps),o=[Os.UZERO,Os.UZERO],i=[Os.UZERO,Os.UZERO];a=a.mul(Ps).add(Ws(e,0));let c=0;const l=64*(t-1>>6),u=l+(t-1&63)-63;do{a=Vs(a.add(r).add(o[0]).add(Ws(e,c+8)),37).mul(Ls),r=Vs(r.add(o[1]).add(Ws(e,c+48)),42).mul(Ls),a=a.xor(i[1]),r=r.add(o[0]).add(Ws(e,c+40)),s=Vs(s.add(i[0]),33).mul(Ls),o=js(e,c,o[1].mul(Ls),a.add(i[0])),i=js(e,c+32,s.add(i[1]),r.add(Ws(e,c+16))),[s,a]=[a,s],c+=64}while(c!==l);const h=Ls.add(s.and(255).shl(1));return c=u,i[0]=i[0].add(t-1&63),o[0]=o[0].add(i[0]),i[0]=i[0].add(o[0]),a=Vs(a.add(r).add(o[0]).add(Ws(e,c+8)),37).mul(h),r=Vs(r.add(o[1]).add(Ws(e,c+48)),42).mul(h),a=a.xor(i[1].mul(9)),r=r.add(o[0].mul(9).add(Ws(e,c+40))),s=Vs(s.add(i[0]),33).mul(h),o=js(e,c,o[1].mul(h),a.add(i[0])),i=js(e,c+32,s.add(i[1]),r.add(Ws(e,c+16))),[s,a]=[a,s],Gs(Gs(o[0],i[0],h).add(zs(r).mul(Ms)).add(s),Gs(o[1],i[1],h).add(a),h)}function Ks(e,t){return"string"===t?Ys(e):qs([e],t)}function qs(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=_t(e)),hn().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const a=e[n];if(isNaN(a)||!isFinite(a))throw Error("A tensor of type ".concat(t," being uploaded contains ").concat(a,"."))}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error("Unknown data type ".concat(t))}function Xs(){return hn().platform.now()}function Ys(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",hn().platform.encode(e,t)}function Zs(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",hn().platform.decode(e,t)}class Qs{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new $s)}profileKernel(e,t,n){let a;const r=()=>{a=n()};let s;const o=Xs();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(r);else{r();for(const e of a)e.dataSync();s=Promise.resolve({kernelMs:Xs()-o})}if(hn().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let i=0;i<a.length;i++){const t=a[i];t.data().then((n=>{Js(n,t.dtype,e)}))}return{kernelName:e,outputs:a,inputs:t,timeMs:s.then((e=>e.kernelMs)),extraInfo:s.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:a,inputs:r,extraInfo:s}=e;n.forEach((e=>{Promise.all([e.data(),a,s]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],r,n[2])}))}))}}function Js(e,t,n){if("float32"!==t)return!1;for(let a=0;a<e.length;a++){const t=e[a];if(isNaN(t)||!isFinite(t))return console.warn("Found ".concat(t," in the result of '").concat(n,"'")),!0}return!1}class $s{logKernelProfile(e,t,n,a,r,s){const o="number"===typeof a?Lt("".concat(a,"ms"),9):a.error,i=Lt(e,25),c=t.rank,l=t.size,u=Lt(t.shape.toString(),14);let h="";for(const d in r){const e=r[d];if(null!=e){const n=e.shape||t.shape,a=n.length;h+="".concat(d,": ").concat(a,"D ").concat(a>0?n:""," ")}}console.log("%c".concat(i,"\t%c").concat(o,"\t%c").concat(c,"D ").concat(u,"\t%c").concat(l,"\t%c").concat(h,"\t%c").concat(s),"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const eo=20,to=3,no=7;function ao(e,t,n,a){const r=Qt(t),s=function(e,t,n,a){const r=Ft(t),s=a[a.length-1],o=new Array(s).fill(0),i=t.length,c="complex64"===n?io(e):e;if(i>1)for(let l=0;l<r/s;l++){const e=l*s;for(let t=0;t<s;t++)o[t]=Math.max(o[t],ro(c[e+t],0,n).length)}return o}(e,t,n,r),o=t.length,i=oo(e,t,n,r,s),c=["Tensor"];return a&&(c.push("  dtype: ".concat(n)),c.push("  rank: ".concat(o)),c.push("  shape: [".concat(t,"]")),c.push("  values:")),c.push(i.map((e=>"    "+e)).join("\n")),c.join("\n")}function ro(e,t,n){let a;return a=Array.isArray(e)?"".concat(parseFloat(e[0].toFixed(no))," + ")+"".concat(parseFloat(e[1].toFixed(no)),"j"):Kt(e)?"'".concat(e,"'"):"bool"===n?so(e):parseFloat(e.toFixed(no)).toString(),Lt(a,t)}function so(e){return 0===e?"false":"true"}function oo(e,t,n,a,r){let s=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const o="complex64"===n?2:1,i=t[0],c=t.length;if(0===c){if("complex64"===n){return[ro(io(e)[0],0,n)]}return"bool"===n?[so(e[0])]:[e[0].toString()]}if(1===c){if(i>eo){const t=to*o;let a=Array.from(e.slice(0,t)),s=Array.from(e.slice((i-to)*o,i*o));return"complex64"===n&&(a=io(a),s=io(s)),["["+a.map(((e,t)=>ro(e,r[t],n))).join(", ")+", ..., "+s.map(((e,t)=>ro(e,r[i-to+t],n))).join(", ")+"]"]}return["["+("complex64"===n?io(e):Array.from(e)).map(((e,t)=>ro(e,r[t],n))).join(", ")+"]"]}const l=t.slice(1),u=a.slice(1),h=a[0]*o,d=[];if(i>eo){for(let t=0;t<to;t++){const a=t*h,s=a+h;d.push(...oo(e.slice(a,s),l,n,u,r,!1))}d.push("...");for(let t=i-to;t<i;t++){const a=t*h,s=a+h;d.push(...oo(e.slice(a,s),l,n,u,r,t===i-1))}}else for(let m=0;m<i;m++){const t=m*h,a=t+h;d.push(...oo(e.slice(t,a),l,n,u,r,m===i-1))}const p=2===c?",":"";d[0]="["+d[0]+p;for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=",\n";for(let m=2;m<c;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":f),d}function io(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class co{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Ft(e),null!=n){const e=n.length;Et(e===this.size,(()=>"Length of values '".concat(e,"' does not match the size ")+"inferred by the shape '".concat(this.size,"'.")))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Vt(t,this.size),this.strides=Qt(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];0===n.length&&(n=[0]),Et(n.length===this.rank,(()=>"The number of provided coordinates (".concat(n.length,") must ")+"match the rank (".concat(this.rank,")")));const r=this.locToIndex(n);this.values[r]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let a=0;for(const s of t){if(s<0||s>=this.shape[a]){const e="Requested out of range element at ".concat(t,". ")+"  Buffer shape=".concat(this.shape);throw new Error(e)}a++}let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=this.strides[s]*t[s];return this.values[r]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return lo().makeTensor(this.values,this.shape,this.dtype)}}let lo=null,uo=null,ho=null;class po{constructor(e,t,n,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Ft(e),this.strides=Qt(e),this.dataId=n,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return uo.buffer(this.shape,this.dtype,e)}bufferSync(){return uo.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return $t(this.shape,e,"complex64"===this.dtype)}arraySync(){return $t(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=lo().read(this.dataId);if("string"===this.dtype){const n=await e;try{return n.map((e=>Zs(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),lo().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=lo().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>Zs(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await lo().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(lo().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return uo.print(this,e)}clone(){return this.throwIfDisposed(),uo.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return ao(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),uo.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),lo().makeVariable(this,e,t,n)}}function fo(){return mn("Tensor",(()=>po))}Object.defineProperty(po,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),fo();class mo extends po{constructor(e,t,n,a){super(e.shape,e.dtype,e.dataId,a),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error("dtype of the new value (".concat(e.dtype,") and ")+"previous value (".concat(this.dtype,") must match"));if(!Ot(e.shape,this.shape))throw new Error("shape of the new value (".concat(e.shape,") and ")+"previous value (".concat(this.shape,") must match"));lo().disposeTensor(this),this.dataId=e.dataId,lo().incRef(this,null)}dispose(){lo().disposeVariable(this),this.isDisposedInternal=!0}}var go,yo,bo,vo,xo;Object.defineProperty(mo,Symbol.hasInstance,{value:e=>e instanceof po&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(go||(go={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(yo||(yo={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(bo||(bo={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(vo||(vo={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(xo||(xo={}));const wo={float32:vo,int32:yo,bool:bo,complex64:xo};function ko(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error("Can not upcast ".concat(e," with ").concat(t))}return wo[e][t]}function So(e){return ko(e,"int32")}function Io(e,t){if(e.dtype===t.dtype)return[e,t];const n=ko(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function No(e,t){return t.some((t=>t.id===e.id))}function Co(e){const t=[];return To(e,t,new Set),t}function To(e,t,n){if(null==e)return;if(e instanceof po)return void t.push(e);if(a=e,!Array.isArray(a)&&"object"!==typeof a)return;var a;const r=e;for(const s in r){const e=r[s];n.has(e)||(n.add(e),To(e,t,n))}}function Eo(e){return null!=e.kernelName}class Ro{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Ao{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Ro}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error("Backend '".concat(this.backendName,"' has not yet been initialized. Make ")+"sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error("The highest priority backend '".concat(e,"' has not yet been ")+"initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(ks("".concat(e," backend was already registered. ")+"Reusing existing backend factory."),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error("Backend name '".concat(e,"' not found in registry"));if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Qs(this.backendInstance),!0}setupRegisteredKernels(){Es(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){Es(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error("Cannot initialize backend ".concat(e,", no registration found."));try{const n=t.factory();if(!n||n instanceof kt||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,a=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,ks("Initialization of backend ".concat(e," failed")),ks(n.stack||n.message)),!1)));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}}catch(n){return ks("Initialization of backend ".concat(e," failed")),ks(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error("".concat(e," backend not found in registry"));this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:a,asyncInit:r}=this.initializeBackend(n);if(r||a)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),a=n.backend,r=this.readSync(t),s=a.refCount(t);a.disposeData(t,!0),n.backend=e,e.move(t,r,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,a=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");a=e}return this.scopedRun((()=>this.startScope(a)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(a){throw t(),a}}nextTensorId(){return Ao.nextTensorId++}nextVariableId(){return Ao.nextVariableId++}clone(e){const t=Fo.runKernel(Ra,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return Fo.runKernel(zn,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=Cs(e,this.backendName)))throw new Error("Kernel '".concat(e,"' not registered for backend '").concat(this.backendName,"'"));return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const a=this.backend.numDataIds();let r=0;n.forEach((e=>{r+="complex64"===e.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=a-t-r-s;if(o>0)throw new Error("Backend '".concat(this.backendName,"' has an internal memory leak ")+"(".concat(o," data ids) after running '").concat(e,"'"))}runKernelFunc(e){let t,n=[];const a=this.isTapeOn(),r=this.state.numBytes,s=this.state.numTensors;let o,i;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const c=Eo(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Eo(e)){const{kernelName:t,inputs:r,attrs:s}=e;null==this.backendName&&this.backend;const c=Cs(t,this.backendName);Et(null!=c,(()=>"Cannot find registered kernel '".concat(t,"' for backend '").concat(this.backendName,"'"))),o=()=>{const e=this.backend.numDataIds();i=c.kernelFunc({inputs:r,attrs:s,backend:this.backend});const o=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,o);const l=o.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(a){const e=this.getTensorsForGradient(t,r,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,r=e=>{a&&(n=e.map((e=>this.keep(this.clone(e)))))};o=()=>{const e=this.backend.numDataIds();i=this.tidy((()=>t(this.backend,r)));const n=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,e,n),n}}const{inputs:l,attrs:u}=e,h=Eo(e)?null:e.backwardsFunc;let d;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(c,l,(()=>o())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs):t=o()})),a&&this.addTapeNode(c,l,t,h,n,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map((e=>null!=l[e]?l[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(i)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map((e=>this.keep(this.clone(e))));return t}getTensorsForGradient(e,t,n){const a=Ts(e);if(null!=a){const e=a.inputsToSave||[],r=a.outputsToSave||[];let s;a.saveAllInputs?(Et(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(t).map((e=>t[e]))):s=e.map((e=>t[e]));const o=n.filter(((e,t)=>r[t]));return s.concat(o)}return[]}makeTensor(e,t,n,a){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",a=a||this.backend;let r=e;"string"===n&&Kt(e[0])&&(r=e.map((e=>Ys(e))));const s=a.write(r,t,n),o=new po(t,n,s,this.nextTensorId());if(this.trackTensor(o,a),"string"===n){const e=this.state.tensorInfo.get(s),t=function(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}(r);this.state.numBytes+=t-e.bytes,e.bytes=t}return o}makeTensorFromDataId(e,t,n,a){const r={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(r,a)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:a,dtype:r}=e,s=new po(a,r,n,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=a&&a!==e.dtype&&(e=e.cast(a));const r=new mo(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[r.name])throw new Error("Variable with name ".concat(r.name," was already registered"));return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*Ht(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof mo||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*Ht(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const a of this.state.activeProfile.kernels)a.kernelTimeMs=await a.kernelTimeMs,a.extraInfo=await a.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,a,r,s){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:r},i=Ts(e);null!=i&&(a=i.gradFunc),null!=a&&(o.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],a=tn(e.size,e.dtype);return this.makeTensor(a,e.shape,e.dtype)}return e})),a(e.length>1?e:e[0],r,s))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Co(e),n=new Set(t.map((e=>e.id)));for(let r=0;r<this.state.activeScope.track.length;r++){const e=this.state.activeScope.track[r];e.kept||n.has(e.id)||e.dispose()}const a=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==a.id||this.track(e)}))}gradients(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(Et(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype,"'"));const r=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));Et(r instanceof po,(()=>"The result y returned by f() must be a tensor."));const s=function(e,t,n){const a={},r={};for(let c=0;c<t.length;c++)a[t[c].id]=!0;for(let c=0;c<e.length;c++){const n=e[c],s=n.inputs;for(const e in s){const o=s[e];let i=!1;for(let e=0;e<t.length;e++)if(a[o.id]){n.outputs.forEach((e=>a[e.id]=!0)),i=!0,r[n.id]=!0;break}if(i)break}}const s={};s[n.id]=!0;const o={};for(let c=e.length-1;c>=0;c--){const t=e[c],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(s[t.outputs[e].id]){for(const e in n)s[n[e].id]=!0,o[t.id]=!0;break}}const i=[];for(let c=0;c<e.length;c++){const t=e[c];if(r[t.id]&&o[t.id]){const e={};for(const r in t.inputs){const n=t.inputs[r];a[n.id]&&(e[r]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,i.push(n)}}return i}(this.state.activeTape,t,r);if(!a&&0===s.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[r.id]=null==n?function(e){const t=en(Ft(e),"float32");return Fo.makeTensor(t,e,"float32")}(r.shape):n,function(e,t,n,a){for(let r=t.length-1;r>=0;r--){const s=t[r],o=[];if(s.outputs.forEach((t=>{const n=e[t.id];null!=n?o.push(n):o.push(null)})),null==s.gradient)throw new Error("Cannot compute gradient: gradient function not found "+"for ".concat(s.kernelName,"."));const i=s.gradient(o);for(const t in s.inputs){if(!(t in i))throw new Error("Cannot backprop through input ".concat(t,". ")+"Available gradients found: ".concat(Object.keys(i),"."));const r=n((()=>i[t]()));if("float32"!==r.dtype)throw new Error("Error in gradient for op ".concat(s.kernelName,". The gradient of input ")+"".concat(t," must have 'float32' dtype, but has '").concat(r.dtype,"'"));const o=s.inputs[t];if(!Ot(r.shape,o.shape))throw new Error("Error in gradient for op ".concat(s.kernelName,". The gradient of input ")+"'".concat(t,"' has shape '").concat(r.shape,"', which does not match ")+"the shape of the input '".concat(o.shape,"'"));if(null==e[o.id])e[o.id]=r;else{const t=e[o.id];e[o.id]=a(t,r),t.dispose()}}}}(e,s,(e=>this.tidy(e)),Oo);const a=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:r,grads:a}}))}customGrad(e){var t=this;return Et(Yt(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,a=new Array(n),r=0;r<n;r++)a[r]=arguments[r];let s;Et(a.every((e=>e instanceof po)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const o={};a.forEach(((e,t)=>{o[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(s=e(...a,n),Et(s.value instanceof po,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),Et(Yt(s.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),s.value),backwardsFunc:(e,t)=>{const n=s.gradFunc(e,t),r=Array.isArray(n)?n:[n];Et(r.length===a.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),Et(r.every((e=>e instanceof po)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const o={};return r.forEach(((e,t)=>{o[t]=()=>e})),o},inputs:o})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Xs(),n=await this.backend.time(e);return n.wallMs=Xs()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Ro;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function _o(){const e=fn();if(null==e._tfengine){const t=new ln(e);e._tfengine=new Ao(t)}var t;return t=e._tfengine.ENV,pn=t,lo=()=>e._tfengine,e._tfengine}Ao.nextTensorId=0,Ao.nextVariableId=0;const Fo=_o();function Oo(e,t){const n={a:e,b:t};return Fo.runKernel(vn,n)}let Do;function Mo(e){if(void 0!==Do)return Do;if(e||"undefined"!==typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Lo(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}const Po=hn();function zo(e,t){let n=e;if(jt(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];const a=[];for(;Array.isArray(n)||jt(n)&&"string"!==t;)a.push(n.length),n=n[0];return Array.isArray(e)&&hn().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Bo(e,a,[]),a}function Bo(e,t,n){if(n=n||[],!Array.isArray(e)&&!jt(e))return void Et(0===t.length,(()=>"Element arr[".concat(n.join("]["),"] is a primitive, ")+"but should be an array/TypedArray of ".concat(t[0]," elements")));Et(t.length>0,(()=>"Element arr[".concat(n.join("]["),"] should be a primitive, ")+"but is an array of ".concat(e.length," elements"))),Et(e.length===t[0],(()=>"Element arr[".concat(n.join("]["),"] should have ").concat(t[0]," ")+"elements, but has ".concat(e.length," elements")));const a=t.slice(1);for(let r=0;r<e.length;++r)Bo(e[r],a,n.concat(r))}function Wo(e,t,n,a){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error("Argument '".concat(n,"' passed to '").concat(a,"' must ")+"be ".concat(e," tensor, but got ").concat(t," tensor"))}}function Uo(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof po)return Wo(a,e.dtype,t,n),e;let r=Xt(e);if("string"!==r&&["bool","int32","float32"].indexOf(a)>=0&&(r=a),Wo(a,r,t,n),null==e||!jt(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const a=null==e?"null":e.constructor.name;throw new Error("Argument '".concat(t,"' passed to '").concat(n,"' must be a ")+"Tensor or TensorLike, but got '".concat(a,"'"))}const s=zo(e,r);jt(e)||Array.isArray(e)||(e=[e]);const o="string"!==r?qs(e,r):_t(e,[],!0);return Fo.makeTensor(o,s,r)}function Vo(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error("Argument ".concat(t," passed to ").concat(n," must be a ")+"`Tensor[]` or `TensorLike[]`");return e.map(((e,r)=>Uo(e,"".concat(t,"[").concat(r,"]"),n,a)))}Po.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Po.registerFlag("IS_BROWSER",(()=>Lo())),Po.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),Po.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Po.registerFlag("PROD",(()=>!1)),Po.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Po.getBool("DEBUG"))),Po.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Po.registerFlag("IS_TEST",(()=>!1)),Po.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>!0)),Po.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Po.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1)),Po.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),Po.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));const Go="__op";function jo(e){const t=Object.keys(e);if(1!==t.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+"".concat(t.length," keys."));let n=t[0];const a=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=Go;const r=function(){Fo.startScope(n);try{const e=a(...arguments);return on(e)&&console.error("Cannot return a Promise inside of tidy."),Fo.endScope(e),e}catch(e){throw Fo.endScope(null),e}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}const Ho=jo({complex_:function(e,t){const n=Uo(e,"real","complex"),a=Uo(t,"imag","complex");Rt(n.shape,a.shape,"real and imag shapes, ".concat(n.shape," and ").concat(a.shape,", ")+"must match in call to tf.complex().");const r={real:n,imag:a};return Fo.runKernel(Un,r)}});function Ko(e,t,n,a){if(null==a&&(a=Xt(e)),"complex64"===a)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!jt(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){an(t);const e=Ft(t),a=Ft(n);Et(e===a,(()=>"Based on the provided shape, [".concat(t,"], the tensor should have ")+"".concat(e," values but has ").concat(a)));for(let r=0;r<n.length;++r){const e=n[r],a=r!==n.length-1||e!==Ft(t.slice(r));Et(n[r]===t[r]||!a,(()=>"Error creating a new Tensor. Inferred shape "+"(".concat(n,") does not match the provided ")+"shape (".concat(t,"). ")))}}return jt(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==a?qs(e,a):_t(e,[],!0),Fo.makeTensor(e,t,a)}function qo(e,t,n){return Ko(e,t,zo(e,n),n)}const Xo={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Yo=4;async function Zo(e,t){const n=[],a=[],r=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let s=0;s<r.length;++s){const o=r[s],i=Array.isArray(e)?e[s].tensor:e[o];if("float32"!==i.dtype&&"int32"!==i.dtype&&"bool"!==i.dtype&&"string"!==i.dtype&&"complex64"!==i.dtype)throw new Error("Unsupported dtype in weight '".concat(o,"': ").concat(i.dtype));const c={name:o,shape:i.shape,dtype:i.dtype};if("string"===i.dtype){const e=new Promise((async e=>{const t=await i.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+Yo*t.length,a=new Uint8Array(n);let r=0;for(let s=0;s<t.length;s++){const e=t[s],n=new Uint8Array(new Uint32Array([e.length]).buffer);a.set(n,r),r+=Yo,a.set(e,r),r+=e.length}e(a)}));a.push(e)}else a.push(i.data());null!=t&&(c.group=t),n.push(c)}return{data:Jo(await Promise.all(a)),specs:n}}function Qo(e,t){const n={};let a,r=0;for(const s of t){const t=s.name,o=s.dtype,i=s.shape,c=Ft(i);let l;if("quantization"in s){const n=s.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error("Weight ".concat(s.name," with quantization ").concat(n.dtype," ")+"doesn't have corresponding metadata min and scale.")}else{if("float16"!==n.dtype)throw new Error("Weight ".concat(s.name," has unknown ")+"quantization dtype ".concat(n.dtype,". ")+"Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");if("float32"!==o)throw new Error("Weight ".concat(s.name," is quantized with ").concat(n.dtype," ")+"which only supports weights of type float32 not ".concat(o,"."))}const i=Xo[n.dtype],u=e.slice(r,r+c*i),h="uint8"===n.dtype?new Uint8Array(u):new Uint16Array(u);if("float32"===o)if("uint8"===n.dtype||"uint16"===n.dtype){l=new Float32Array(h.length);for(let e=0;e<h.length;e++){const t=h[e];l[e]=t*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error("Unsupported quantization type ".concat(n.dtype," ")+"for weight type float32.");void 0===a&&(a=ci()),l=a(h)}else{if("int32"!==o)throw new Error("Unsupported dtype in weight '".concat(t,"': ").concat(o));if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error("Unsupported quantization type ".concat(n.dtype," ")+"for weight type int32.");l=new Int32Array(h.length);for(let e=0;e<h.length;e++){const t=h[e];l[e]=Math.round(t*n.scale+n.min)}}r+=c*i}else if("string"===o){const t=Ft(s.shape);l=[];for(let n=0;n<t;n++){const t=new Uint32Array(e.slice(r,r+Yo))[0];r+=Yo;const n=new Uint8Array(e.slice(r,r+t));l.push(n),r+=t}}else{const a=Xo[o],s=e.slice(r,r+c*a);if("float32"===o)l=new Float32Array(s);else if("int32"===o)l=new Int32Array(s);else if("bool"===o)l=new Uint8Array(s);else{if("complex64"!==o)throw new Error("Unsupported dtype in weight '".concat(t,"': ").concat(o));{l=new Float32Array(s);const e=new Float32Array(l.length/2),a=new Float32Array(l.length/2);for(let t=0;t<e.length;t++)e[t]=l[2*t],a[t]=l[2*t+1];const r=qo(e,i,"float32"),o=qo(a,i,"float32");n[t]=Ho(r,o),r.dispose(),o.dispose()}}r+=c*a}"complex64"!==o&&(n[t]=qo(l,i,o))}return n}function Jo(e){if(null===e)throw new Error("Invalid input value: ".concat(JSON.stringify(e)));let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: ".concat(e.constructor.name))}));const a=new Uint8Array(t);let r=0;return n.forEach((e=>{a.set(new Uint8Array(e.buffer),r),r+=e.byteLength})),a.buffer}const $o="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function ei(e){return $o?Buffer.byteLength(e):new Blob([e]).size}function ti(e){if(1===e.length)return e[0];let t=0;e.forEach((e=>{t+=e.byteLength}));const n=new Uint8Array(t);let a=0;return e.forEach((e=>{n.set(new Uint8Array(e),a),a+=e.byteLength})),n.buffer}function ni(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function ai(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function ri(e,t,n){const a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(a.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");a.weightSpecs=t,a.weightData=n}return null!=e.signature&&(a.signature=e.signature),null!=e.userDefinedMetadata&&(a.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(a.modelInitializer=e.modelInitializer),a}async function si(e,t){let n,a;return null!=e.weightsManifest&&([n,a]=await t(e.weightsManifest)),ri(e,n,a)}function oi(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:ei(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:ei(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function ii(e){const t=[];for(const n of e)t.push(...n.weights);return t}function ci(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0===(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return a=>{const r=new ArrayBuffer(4*a.length),s=new Uint32Array(r);for(let o=0;o<a.length;o++){const r=a[o],i=e[n[r>>10]+(1023&r)]+t[r>>10];s[o]=i}return new Float32Array(r)}}class li{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==li.instance&&(li.instance=new li),li.instance}static registerSaveRouter(e){li.getInstance().saveRouters.push(e)}static registerLoadRouter(e){li.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return li.getHandlers(e,"save")}static getLoadHandlers(e,t){return li.getHandlers(e,"load",t)}static getHandlers(e,t,n){const a=[];return("load"===t?li.getInstance().loadRouters:li.getInstance().saveRouters).forEach((t=>{const r=t(e,n);null!==r&&a.push(r)})),a}}const ui=e=>li.registerSaveRouter(e),hi=e=>li.registerLoadRouter(e),di=e=>li.getSaveHandlers(e),pi=(e,t)=>li.getLoadHandlers(e,t),fi="tensorflowjs",mi="models_store",gi="model_info_store";function yi(){if(!hn().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function bi(e){const t=e.result;t.createObjectStore(mi,{keyPath:"modelPath"}),t.createObjectStore(gi,{keyPath:"modelPath"})}class vi{constructor(e){if(this.indexedDB=yi(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const a=this.indexedDB.open(fi,1);a.onupgradeneeded=()=>bi(a),a.onsuccess=()=>{const r=a.result;if(null==t){const t=r.transaction(mi,"readonly"),a=t.objectStore(mi).get(this.modelPath);a.onsuccess=()=>{if(null==a.result)return r.close(),n(new Error("Cannot find model with path '".concat(this.modelPath,"' ")+"in IndexedDB."));e(a.result.modelArtifacts)},a.onerror=e=>(r.close(),n(a.error)),t.oncomplete=()=>r.close()}else{const a=oi(t),s=r.transaction(gi,"readwrite");let o=s.objectStore(gi);const i=o.put({modelPath:this.modelPath,modelArtifactsInfo:a});let c;i.onsuccess=()=>{c=r.transaction(mi,"readwrite");const i=c.objectStore(mi).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a});i.onsuccess=()=>e({modelArtifactsInfo:a}),i.onerror=e=>{o=s.objectStore(gi);const t=o.delete(this.modelPath);t.onsuccess=()=>(r.close(),n(i.error)),t.onerror=e=>(r.close(),n(i.error))}},i.onerror=e=>(r.close(),n(i.error)),s.oncomplete=()=>{null==c?r.close():c.oncomplete=()=>r.close()}}},a.onerror=e=>n(a.error)}))}}vi.URL_SCHEME="indexeddb://";const xi=e=>{return hn().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(vi.URL_SCHEME)?(t=e.slice(vi.URL_SCHEME.length),new vi(t)):null;var t};li.registerSaveRouter(xi),li.registerLoadRouter(xi);class wi{constructor(){this.indexedDB=yi()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(fi,1);n.onupgradeneeded=()=>bi(n),n.onsuccess=()=>{const a=n.result,r=a.transaction(gi,"readonly"),s=r.objectStore(gi).getAll();s.onsuccess=()=>{const t={};for(const e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(a.close(),t(s.error)),r.oncomplete=()=>a.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(vi.URL_SCHEME)?t.slice(vi.URL_SCHEME.length):t,new Promise(((t,n)=>{const a=this.indexedDB.open(fi,1);a.onupgradeneeded=()=>bi(a),a.onsuccess=()=>{const r=a.result,s=r.transaction(gi,"readwrite"),o=s.objectStore(gi),i=o.get(e);let c;i.onsuccess=()=>{if(null==i.result)return r.close(),n(new Error("Cannot find model with path '".concat(e,"' ")+"in IndexedDB."));{const a=o.delete(e),s=()=>{c=r.transaction(mi,"readwrite");const a=c.objectStore(mi).delete(e);a.onsuccess=()=>t(i.result.modelArtifactsInfo),a.onerror=e=>n(i.error)};a.onsuccess=s,a.onerror=e=>(s(),r.close(),n(i.error))}},i.onerror=e=>(r.close(),n(i.error)),s.oncomplete=()=>{null==c?r.close():c.oncomplete=()=>r.close()}},a.onerror=e=>n(a.error)}))}}const ki="/",Si="tensorflowjs_models",Ii="info",Ni="model_topology",Ci="weight_specs",Ti="weight_data",Ei="model_metadata";function Ri(e){return{info:[Si,e,Ii].join(ki),topology:[Si,e,Ni].join(ki),weightSpecs:[Si,e,Ci].join(ki),weightData:[Si,e,Ti].join(ki),modelMetadata:[Si,e,Ei].join(ki)}}function Ai(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function _i(e){const t=e.split(ki);if(t.length<3)throw new Error("Invalid key format: ".concat(e));return t.slice(1,t.length-1).join(ki)}class Fi{constructor(e){if(!hn().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Ri(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),a=JSON.stringify(e.weightSpecs),r=oi(e);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,a),this.LS.setItem(this.keys.weightData,function(e){if($o)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let a=0,r=t.length;a<r;a++)n+=String.fromCharCode(t[a]);return btoa(n)}(e.weightData));const t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:r}}catch(t){throw Ai(this.keys),new Error("Failed to save model '".concat(this.modelPath,"' to local storage: ")+"size quota being exceeded is a possible cause of this failure: "+"modelTopologyBytes=".concat(r.modelTopologyBytes,", ")+"weightSpecsBytes=".concat(r.weightSpecsBytes,", ")+"weightDataBytes=".concat(r.weightDataBytes,"."))}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error("In local storage, there is no model with name '".concat(this.modelPath,"'"));if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error("In local storage, the topology of model '".concat(this.modelPath,"' ")+"is missing.");t.modelTopology=n;const a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==a)throw new Error("In local storage, the weight specs of model '".concat(this.modelPath,"' ")+"are missing.");t.weightSpecs=a;const r=this.LS.getItem(this.keys.modelMetadata);if(null!=r){const e=JSON.parse(r);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error("In local storage, the binary weight values of model "+"'".concat(this.modelPath,"' are missing."));return t.weightData=function(e){if($o){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let a=0;a<t.length;++a)n.set([t.charCodeAt(a)],a);return n.buffer}(s),t}}Fi.URL_SCHEME="localstorage://";const Oi=e=>{return hn().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Fi.URL_SCHEME)?(t=e.slice(Fi.URL_SCHEME.length),new Fi(t)):null;var t};li.registerSaveRouter(Oi),li.registerLoadRouter(Oi);class Di{constructor(){Et(hn().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Et("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=Si+ki,n=ki+Ii;for(let a=0;a<this.LS.length;++a){const r=this.LS.key(a);if(r.startsWith(t)&&r.endsWith(n)){e[_i(r)]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){var t;const n=Ri(e=(t=e).startsWith(Fi.URL_SCHEME)?t.slice(Fi.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error("Cannot find model at path '".concat(e,"'"));const a=JSON.parse(this.LS.getItem(n.info));return Ai(n),a}}const Mi="://";class Li{constructor(){this.managers={}}static getInstance(){return null==Li.instance&&(Li.instance=new Li),Li.instance}static registerManager(e,t){Et(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(Mi)&&(e=e.slice(0,e.indexOf(Mi))),Et(e.length>0,(()=>"scheme must not be an empty string."));const n=Li.getInstance();Et(null==n.managers[e],(()=>"A model store manager is already registered for scheme '".concat(e,"'."))),n.managers[e]=t}static getManager(e){const t=Li.getInstance().managers[e];if(null==t)throw new Error("Cannot find model manager for scheme '".concat(e,"'"));return t}static getSchemes(){return Object.keys(Li.getInstance().managers)}}function Pi(e){if(-1===e.indexOf(Mi))throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+"".concat(Li.getSchemes().join(",")));return{scheme:e.split(Mi)[0],path:e.split(Mi)[1]}}async function zi(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];Et(e!==t,(()=>"Old path and new path are the same: '".concat(e,"'")));const a=li.getLoadHandlers(e);Et(a.length>0,(()=>"Copying failed because no load handler is found for source URL ".concat(e,"."))),Et(a.length<2,(()=>"Copying failed because more than one (".concat(a.length,") ")+"load handlers for source URL ".concat(e,".")));const r=a[0],s=li.getSaveHandlers(t);Et(s.length>0,(()=>"Copying failed because no save handler is found for destination "+"URL ".concat(t,"."))),Et(s.length<2,(()=>"Copying failed because more than one (".concat(a.length,") ")+"save handlers for destination URL ".concat(t,".")));const o=s[0],i=Pi(e).scheme,c=Pi(e).path,l=i===Pi(e).scheme,u=await r.load();n&&l&&await Li.getManager(i).removeModel(c);const h=await o.save(u);return n&&!l&&await Li.getManager(i).removeModel(c),h.modelArtifactsInfo}async function Bi(){const e=Li.getSchemes(),t={};for(const n of e){const e=await Li.getManager(n).listModels();for(const a in e){t[n+Mi+a]=e[a]}}return t}async function Wi(e){const t=Pi(e);return Li.getManager(t.scheme).removeModel(t.path)}async function Ui(e,t){return zi(e,t,!1)}async function Vi(e,t){return zi(e,t,!0)}class Gi{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Browser's encoder only supports utf-8, but got ".concat(t));return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){window&&hn().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}}if(hn().get("IS_BROWSER")){hn().setPlatform("browser",new Gi);try{Li.registerManager(Fi.URL_SCHEME,new Di)}catch(XV){}try{Li.registerManager(vi.URL_SCHEME,new wi)}catch(XV){}}const ji=()=>n(748);let Hi;class Ki{constructor(){this.util=n(688),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=hn().global.fetch?hn().global.fetch(e,t):(null==Hi&&(Hi=ji()),Hi(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Node built-in encoder only supports utf-8, but got ".concat(t));return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}}function qi(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",an(e),new co(e,t,n)}hn().get("IS_NODE")&&!hn().get("IS_BROWSER")&&hn().setPlatform("node",new Ki);const Xi=jo({cast_:function(e,t){const n=Uo(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error("Failed to cast to unknown dtype ".concat(t));if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const a={x:n},r={dtype:t};return Fo.runKernel(zn,a,r)}});const Yi=jo({clone_:function(e){const t={x:Uo(e,"x","clone","string_or_numeric")};return Fo.runKernel(Ra,t)}});function Zi(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}_o();uo={buffer:qi,cast:Xi,clone:Yi,print:Zi};function Qi(e){return new Promise((e=>setTimeout(e))).then(e)}class Ji{constructor(e){if(!hn().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Ji.URL_SCHEME)&&(e=e.slice(Ji.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=ai(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),r=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(r.download=this.modelJsonFileName,r.href=a,await Qi((()=>r.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=t,await Qi((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:oi(e)}}}}Ji.URL_SCHEME="downloads://";class $i{constructor(e){if(null==e||e.length<1)throw new Error("When calling browserFiles, at least 1 file is required, "+"but received ".concat(e));this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{const n=new FileReader;n.onload=n=>{const a=JSON.parse(n.target.result),r=a.modelTopology;if(null==r)return void t(new Error("modelTopology field is missing from file ".concat(this.jsonFile.name)));if(null==a.weightsManifest)return void t(new Error("weightManifest field is missing from file ".concat(this.jsonFile.name)));if(0===this.weightsFiles.length)return void e({modelTopology:r});const s=si(a,(e=>this.loadWeights(e)));e(s)},n.onerror=e=>t("Failed to read model topology and weights manifest JSON "+"from file '".concat(this.jsonFile.name,"'. BrowserFiles supports loading ")+"Keras-style tf.Model artifacts only."),n.readAsText(this.jsonFile)}))}loadWeights(e){const t=[],n=[];for(const s of e)t.push(...s.weights),n.push(...s.paths);const a=this.checkManifestAndWeightFiles(e),r=n.map((e=>this.loadWeightsFile(e,a[e])));return Promise.all(r).then((e=>[t,ti(e)]))}loadWeightsFile(e,t){return new Promise(((n,a)=>{const r=new FileReader;r.onload=e=>{const t=e.target.result;n(t)},r.onerror=t=>a("Failed to weights data from file of path '".concat(e,"'.")),r.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map((e=>ni(e.name))),a={};for(const r of e)r.paths.forEach((e=>{const r=ni(e);if(-1!==t.indexOf(r))throw new Error("Duplicate file basename found in weights manifest: "+"'".concat(r,"'"));if(t.push(r),-1===n.indexOf(r))throw new Error("Weight file with basename '".concat(r,"' is not provided."));a[e]=this.weightsFiles[n.indexOf(r)]}));if(t.length!==this.weightsFiles.length)throw new Error("Mismatch in the number of files in weights manifest "+"(".concat(t.length,") and the number of weight files provided ")+"(".concat(this.weightsFiles.length,")."));return a}}function ec(e){return new $i(e)}function tc(e,t,n,a){!function(e){Et(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){Et(e>=0&&e<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got startFraction ".concat(e))),Et(t>=0&&t<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got endFraction ".concat(t))),Et(t>=e,(()=>"startFraction must be no more than endFraction, but "+"got startFraction ".concat(e," and endFraction ")+"".concat(t)))}(n=null==n?0:n,a=null==a?1:a);let r=0;return Promise.all(e.map((s=>(s.then((s=>{const o=n+ ++r/e.length*(a-n);return t(o),s})),s))))}async function nc(e,t){null==t&&(t={});const n=null==t.fetchFunc?hn().platform.fetch:t.fetchFunc,a=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),r=(null==t.onProgress?await Promise.all(a):await tc(a,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(r):await tc(r,t.onProgress,.5,1)}async function ac(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return rc((e=>nc(e,{requestInit:a})))(e,t,n)}function rc(e){return async function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",a=arguments.length>2?arguments[2]:void 0;const r=t.map((()=>!1)),s={},o=null!=a?a.map((()=>!1)):[],i=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{const c="quantization"in e?e.quantization.dtype:e.dtype,l=Xo[c]*Ft(e.shape),u=()=>{r[t]=!0,null==s[t]&&(s[t]=[]),s[t].push({manifestEntry:e,groupOffset:n,sizeBytes:l})};null!=a?a.forEach(((t,n)=>{t===e.name&&(u(),o[n]=!0)})):u(),i.push(e.name),n+=l}))})),!o.every((e=>e))){const e=a.filter(((e,t)=>!o[t]));throw new Error("Could not find weights in manifest with names: "+"".concat(e.join(", "),". \n")+"Manifest JSON has weights with names: "+"".concat(i.join(", "),"."))}const c=r.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),l=[];c.forEach((e=>{t[e].paths.forEach((e=>{const t=n+(n.endsWith("/")?"":"/")+e;l.push(t)}))}));const u=await e(l),h={};let d=0;return c.forEach((e=>{const n=t[e].paths.length;let a=0;for(let t=0;t<n;t++)a+=u[d+t].byteLength;const r=new ArrayBuffer(a),o=new Uint8Array(r);let i=0;for(let t=0;t<n;t++){const e=new Uint8Array(u[d+t]);o.set(e,i),i+=e.byteLength}s[e].forEach((e=>{const t=Qo(r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(const n in t)h[n]=t[n]})),d+=n})),h}}li.registerSaveRouter((e=>hn().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ji.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new Ji(e)}(e.slice(Ji.URL_SCHEME.length)):null));class sc{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Et("function"===typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=hn().platform.fetch,Et(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&Et(2===e.length,(()=>"URL paths for http must have a length of 2, "+"(actual length is ".concat(e.length,")."))),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=ai(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:oi(e),responses:[a]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+"".concat(a.status,"."))}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error("Request to ".concat(this.path," failed with status code ")+"".concat(e.status,". Please verify this URL points to ")+"the model JSON of the model to load.");let t;try{t=await e.json()}catch(qV){let t="Failed to parse model JSON of response from ".concat(this.path,".");throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,a=t.weightsManifest;if(null==n&&null==a)throw new Error("The JSON from HTTP path ".concat(this.path," contains neither model ")+"topology or manifest for weights.");return si(t,(e=>this.loadWeights(e)))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,a]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),a=e.substring(0,t),r=n>t?e.substring(n):"";return[a+"/",r]}(t),r=this.weightPathPrefix||n,s=ii(e),o=[],i=[];for(const c of e)for(const e of c.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):o.push(r+e+a);this.weightUrlConverter&&o.push(...await Promise.all(i));return[s,ti(await nc(o,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function oc(e){return null!=e.match(sc.URL_SCHEME_REGEX)}sc.URL_SCHEME_REGEX=/^https?:\/\//;const ic=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>oc(e))):oc(e),n)return cc(e,t)}return null};function cc(e,t){return new sc(e,t)}function lc(e,t){return cc(e,t)}li.registerSaveRouter(ic),li.registerLoadRouter(ic);class uc{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class hc{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class dc{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function pc(e,t,n,a){return new dc(fc(...arguments))}function fc(e,t,n,a){if(1===arguments.length){return null!=e.modelTopology||null!=e.weightSpecs?new uc(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new uc({modelTopology:e}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new uc({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:a})}function mc(e){return new hc(e)}function gc(e){return new hc(e)}function yc(e,t){const n=e.length,a=[];for(let r=0;r<n;r++){const s=n-1-r,o=e[s]||1;(t[t.length-1-r]||1)>1&&1===o&&a.unshift(s)}return a}function bc(e,t){const n=[];for(let a=0;a<t.length;a++){const r=e[e.length-a-1],s=t.length-a-1,o=t[s];(null==r||1===r&&o>1)&&n.unshift(s)}return n}function vc(e,t){const n=[],a=Math.max(e.length,t.length);for(let r=0;r<a;r++){let a=e[e.length-r-1];null==a&&(a=1);let s=t[t.length-r-1];if(null==s&&(s=1),1===a)n.unshift(s);else if(1===s)n.unshift(a);else{if(a!==s){const n="Operands could not be broadcast together with shapes "+"".concat(e," and ").concat(t,".");throw Error(n)}n.unshift(a)}}return n}function xc(e,t,n){if(At(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const a=zo(e,n);if(3!==a.length&&1!==a.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Ko(e,t,a,n)}let wc;function kc(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,a=!1,r=!1,s=!1,o=!1,i=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!==typeof ImageData&&e instanceof ImageData)a=!0;else if("undefined"!==typeof HTMLVideoElement&&e instanceof HTMLVideoElement)r=!0;else if("undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement)s=!0;else if(null!=e.getContext)o=!0;else{if(!("undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, "+"but was ".concat(e.constructor.name));i=!0}if(null!=Cs(ys,Fo.backendName)){const n={pixels:e},a={numChannels:t};return Fo.runKernel(ys,n,a)}const[c,l]=r?[e.videoWidth,e.videoHeight]:[e.width,e.height];let u,h;if(o)u=e.getContext("2d").getImageData(0,0,c,l).data;else if(a||n)u=e.data;else if(s||r||i){if(null==wc)if("undefined"===typeof document){if("undefined"===typeof OffscreenCanvas||"undefined"===typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");wc=new OffscreenCanvas(1,1).getContext("2d")}else wc=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});wc.canvas.width=c,wc.canvas.height=l,wc.drawImage(e,0,0,c,l),u=wc.getImageData(0,0,c,l).data}if(4===t)h=new Int32Array(u);else{const e=c*l;h=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)h[n*t+e]=u[4*n+e]}return xc(h,[l,c,t],"int32")}const Sc=jo({fromPixels_:kc}),Ic=-2,Nc=-1;function Cc(e,t,n){const a=e.shape.length;Et(a===t.length,(()=>"Error in slice".concat(a,"D: Length of begin ").concat(t," must ")+"match the rank of the array (".concat(a,")."))),Et(a===n.length,(()=>"Error in slice".concat(a,"D: Length of size ").concat(n," must ")+"match the rank of the array (".concat(a,").")));for(let r=0;r<a;++r)Et(t[r]+n[r]<=e.shape[r],(()=>"Error in slice".concat(a,"D: begin[").concat(r,"] + size[").concat(r,"] ")+"(".concat(t[r]+n[r],") would overflow input.shape[").concat(r,"] (").concat(e.shape[r],")")))}function Tc(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function Ec(e,t,n){const a=[];for(let r=0;r<e.length;r++)a[r]=Math.ceil((t[r]-e[r])/n[r]);return a}function Rc(e,t,n,a){const r=[...e];for(let s=r.length;s<a.length;s++)r.push(1);for(let s=0;s<n;s++)0===s?r[t]=1:(r.splice(t,0,1),r.pop());return r}function Ac(e,t,n){return n<=e?n:n-(t-1)}function _c(e,t){const n=[];for(let a=0;a<e;a++)n.push(t+a);return n}function Fc(e,t,n,a,r,s,o,i,c){const l=e.length;let u=new Array(l),h=new Array(l),d=new Array(l);if(t.length&&n>0){const c=t[0],l=n+1;u=Oc(o,c,l,a,e),h=Dc(i,c,l,r,e),d=Rc(s,c,l,e)}else for(let p=0;p<l;p++)u[p]=Lc(o,a,s,e,p,c),h[p]=Pc(i,r,s,e,p,c),d[p]=Mc(s,p,c);return{begin:u,end:h,strides:d}}function Oc(e,t,n,a,r){const s=[...r],o=_c(n,t);for(let i=0;i<s.length;i++)if(o.indexOf(i)>-1)s[i]=0;else{const r=Ac(t,n,i);let o=a[r];e&1<<r&&(o=0),s[i]=o}return s}function Dc(e,t,n,a,r){const s=[...r],o=_c(n,t);for(let i=0;i<s.length;i++)if(o.indexOf(i)>-1)s[i]=Number.MAX_SAFE_INTEGER;else{const r=Ac(t,n,i);let o=a[r];e&1<<r&&(o=Number.MAX_SAFE_INTEGER),s[i]=o}for(let i=0;i<s.length;i++){const e=r[i];s[i]<0&&(s[i]+=e),s[i]=Nt(0,s[i],r[i])}return s}function Mc(e,t,n){let a=e[t];return(n&1<<t||null==a)&&(a=1),a}function Lc(e,t,n,a,r,s){let o=t[r];const i=n[r]||1;(e&1<<r||s&1<<r||null==o)&&(o=i>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const c=a[r];return o<0&&(o+=c),o=Nt(0,o,c-1),o}function Pc(e,t,n,a,r,s){let o=t[r];const i=n[r]||1;(e&1<<r||s&1<<r||null==o)&&(o=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const c=a[r];return o<0&&(o+=c),o=i>0?Nt(0,o,c):Nt(-1,o,c-1),o}function zc(e,t,n){let a=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){a=r;break}for(let r=a+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function Bc(e,t){let n=e.length>0?e[e.length-1]:1;for(let a=0;a<e.length-1;a++)n+=e[a]*t[a];return n}function Wc(e,t,n){let a;const r=e.shape.length;let s;return a="number"===typeof t?[t,...new Array(r-1).fill(0)]:t.length<r?t.concat(new Array(r-t.length).fill(0)):t.slice(),a.forEach((e=>{Et(-1!==e,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(r).fill(-1):"number"===typeof n?[n,...new Array(r-1).fill(-1)]:n.length<r?n.concat(new Array(r-n.length).fill(-1)):n,s=s.map(((t,n)=>t>=0?t:(Et(-1===t,(()=>"Negative size values should be exactly -1 but got "+"".concat(t," for the slice() size at index ").concat(n,"."))),e.shape[n]-a[n]))),[a,s]}function Uc(e,t,n,a,r,s,o,i,c){let l;if(null==a?(l=new Array(t.length),l.fill(1)):l=a,null!=o&&0!==(o&o-1))throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const h={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:l.slice(),beginMask:r,endMask:s,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:c};for(let b=0;b<h.dims;b++)u&&0!==(1<<b&i)&&h.numAddAxisAfterEllipsis++,1<<b&o&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let a=0;a<e.dims;a++)if(1<<a&e.ellipsisMask){const r=Math.min(t.dims-(e.dims-a)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=a}else if(1<<a&e.newAxisMask)t.finalShapeGatherIndices.push(Ic),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error("Index out of range using input dim ".concat(n,"; input ")+"has only ".concat(t.dims," dims, ").concat(t.begin.length,"."));null!=e.begin&&(t.begin[n]=e.begin[a]),null!=e.end&&(t.end[n]=e.end[a]),t.strides[n]=e.strides[a],e.beginMask&1<<a&&(t.beginMask|=1<<n),e.endMask&1<<a&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<a?(t.finalShapeGatherIndices.push(Nc),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(a)),t.inputShapeGatherIndicesSparse[n]=a,n++}}(h,d);let p=!0,f=!0,m=!0;const g=[],y=[];for(let b=0;b<e.length;++b){if(0===d.strides[b])throw Error("strides[".concat(b,"] must be non-zero"));const t=!!(d.shrinkAxisMask&1<<b),n=e[b];if(-1===n){g.push(t?1:-1);continue}const a=[d.beginMask&1<<b,d.endMask&1<<b],r=[d.strides[b]>0?0:-1,d.strides[b]>0?n:n-1];if(t&&d.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===d.strides[b];const s=!!(d.beginMask&1<<b&&d.endMask&1<<b);if(d.beginValid&&d.endValid){if(t){const e=d.begin[b]<0?n+d.begin[b]:d.begin[b];if(d.begin[b]=e,d.end[b]=d.begin[b]+1,e<0||e>=n)throw Error("slice index ".concat(d.begin[b]," of dimension ").concat(b," out of bounds."))}else d.begin[b]=Vc(d.begin[b],0,d.strides[b],n,a,r),d.end[b]=Vc(d.end[b],1,d.strides[b],n,a,r);const e=1===d.strides[b]&&0===d.begin[b]&&d.end[b]===n;p=p&&e,f=f&&(0===b&&1===d.strides[b]||e)}else p=p&&1===d.strides[b]&&s,f=f&&(0===b&&1===d.strides[b]||s);let o,i=!1;if(d.beginValid&&d.endValid?(o=d.end[b]-d.begin[b],i=!0):t?(o=1,i=!0):s&&n>=0&&(o=d.strides[b]<0?-n:n,i=!0),i){let e;e=0===o||o<0!==d.strides[b]<0?0:Math.trunc(o/d.strides[b])+(o%d.strides[b]!==0?1:0),g.push(e)}else g.push(-1)}for(let b=0;b<d.finalShapeGatherIndices.length;++b){const e=d.finalShapeGatherIndices[b];e>=0?y.push(g[e]):e===Ic&&y.push(1)}return{finalShapeSparse:y.filter(((e,t)=>d.finalShapeGatherIndices[t]!==Ic)),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function Vc(e,t,n,a,r,s){if(r[t])return n>0?s[t]:s[t+1&1];{const t=e<0?a+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}class Gc{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class jc{constructor(){this.classNameMap={}}static getMap(){return null==jc.instance&&(jc.instance=new jc),jc.instance}static register(e){jc.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Hc(e){Et(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),Et("string"===typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),Et(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),jc.register(e)}function Kc(){return Fo}function qc(){return Fo.memory()}function Xc(e,t){return Fo.tidy(e,t)}function Yc(e){Co(e).forEach((e=>e.dispose()))}function Zc(e){return Fo.keep(e)}function Qc(){return Fo.backendName}function Jc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Fo.registerBackend(e,t,n)}function $c(e){return Fo.customGrad(e)}function el(e,t){if((jt(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&jt(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Ko(e,[],[],t)}ho=function(e){hn().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};class tl extends Gc{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:a,grads:r}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:r[e.name]})));this.applyGradients(e)}else this.applyGradients(r);return Yc(r),t?a:(a.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){Et(Yt(e),(()=>"The f passed in variableGrads(f) must be a function")),Et(null==t||Array.isArray(t)&&t.every((e=>e instanceof mo)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in Fo.registeredVariables)t.push(Fo.registeredVariables[e])}const a=n?t.filter((e=>!e.trainable)):null,r=t.length;t=t.filter((e=>e.trainable)),Et(t.length>0,(()=>"variableGrads() expects at least one of the input variables to "+"be trainable, but none of the ".concat(r," variables is ")+"trainable."));const{value:s,grads:o}=Fo.gradients(e,t,null,!0);Et(o.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),Et(0===s.rank,(()=>"The f passed in variableGrads(f) must return a scalar, but it "+"returned a rank-".concat(s.rank," tensor")));const i={};return t.forEach(((e,t)=>{null!=o[t]&&(i[e.name]=o[t])})),null!=a&&a.forEach((e=>i[e.name]=null)),{value:s,grads:i}}(e,t)}dispose(){null!=this.iterations_&&Yc(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:el(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for this optimizer class "+"".concat(this.getClassName()))}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(tl,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});const nl=jo({abs_:function(e){const t=Uo(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return Fo.runKernel(Vn,e)}{const e={x:t};return Fo.runKernel(gn,e)}}});const al=jo({acos_:function(e){const t={x:Uo(e,"x","acos")};return Fo.runKernel(yn,t)}});const rl=jo({acosh_:function(e){const t={x:Uo(e,"x","acosh")};return Fo.runKernel(bn,t)}});const sl=jo({add_:function(e,t){let n=Uo(e,"a","add"),a=Uo(t,"b","add");[n,a]=Io(n,a);const r={a:n,b:a};return Fo.runKernel(vn,r)}});const ol=jo({addN_:function(e){Et(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),Et(e.length>=1,(()=>"Must pass at least one tensor to tf.addN(), but got "+"".concat(e.length)));const t=e.map(((e,t)=>Uo(e,"tensors".concat(t),"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!Ot(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const a=t;return Fo.runKernel(xn,a)}});const il=jo({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Uo(e,"x","all","bool")},r={axis:t,keepDims:n};return Fo.runKernel(wn,a,r)}});const cl=jo({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Uo(e,"x","any","bool")},r={axis:t,keepDims:n};return Fo.runKernel(kn,a,r)}});const ll=jo({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Uo(e,"x","argMax")},a={axis:t};return Fo.runKernel(Sn,n,a)}});const ul=jo({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Uo(e,"x","argMin")},a={axis:t};return Fo.runKernel(In,n,a)}});const hl=jo({asin_:function(e){const t={x:Uo(e,"x","asin")};return Fo.runKernel(Nn,t)}});const dl=jo({asinh_:function(e){const t={x:Uo(e,"x","asinh")};return Fo.runKernel(Cn,t)}});const pl=jo({atan_:function(e){const t={x:Uo(e,"x","atan")};return Fo.runKernel(Tn,t)}});const fl=jo({atan2_:function(e,t){let n=Uo(e,"a","atan2"),a=Uo(t,"b","atan2");[n,a]=Io(n,a);const r={a:n,b:a};return Fo.runKernel(Rn,r)}});const ml=jo({atanh_:function(e){const t={x:Uo(e,"x","atanh")};return Fo.runKernel(En,t)}});function gl(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5?arguments[5]:void 0;return vl(e,[...t,e[3]],n,s,a,null,null,El(r))}function yl(e,t,n,a,r,s){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[i,c]=kl(t);let l;if("channelsLast"===o)l=[i,c,e[3],e[3]];else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat ".concat(o));l=[i,c,e[1],e[1]]}return vl(e,l,n,a,r,s,!1,o)}function bl(e,t,n,a,r,s){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[i,c,l]=Sl(t);let u,h;if("NDHWC"===o)h="channelsLast",u=[i,c,l,e[4],e[4]];else{if("NCDHW"!==o)throw new Error("Unknown dataFormat ".concat(o));h="channelsFirst",u=[i,c,l,e[1],e[1]]}return xl(e,u,n,a,r,!1,h,s)}function vl(e,t,n,a,r,s){let o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[c,l,u,h]=[-1,-1,-1,-1];if("channelsLast"===i)[c,l,u,h]=e;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));[c,h,l,u]=e}const[d,p,,f]=t,[m,g]=kl(n),[y,b]=kl(a),v=Il(d,y),x=Il(p,b),{padInfo:w,outHeight:k,outWidth:S}=function(e,t,n,a,r,s,o,i,c){let l,u,h;if("number"===typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const r=function(e,t,n,a,r){null==a&&(a=wl(e,t,n));const s=e[0],o=e[1],i=Nl((s-t+2*a)/n+1,r),c=Nl((o-t+2*a)/n+1,r);return[i,c]}([t,n],s,a,e,i);u=r[0],h=r[1]}else if("same"===e){u=Math.ceil(t/a),h=Math.ceil(n/r);const e=Math.max(0,(u-1)*a+s-t),i=Math.max(0,(h-1)*r+o-n),c=Math.floor(e/2),d=e-c,p=Math.floor(i/2);l={top:c,bottom:d,left:p,right:i-p,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-s+1)/a),h=Math.ceil((n-o+1)/r);else{if("object"!==typeof e)throw Error("Unknown padding parameter: ".concat(e));{const d="channelsLast"===c?e[1][0]:e[2][0],p="channelsLast"===c?e[1][1]:e[2][1],f="channelsLast"===c?e[2][0]:e[3][0],m="channelsLast"===c?e[2][1]:e[3][1];l={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},u=Nl((t-s+d+p)/a+1,i),h=Nl((n-o+f+m)/r+1,i)}}return{padInfo:l,outHeight:u,outWidth:h}}(r,l,u,m,g,v,x,s,i),I=o?f*h:f;let N;return"channelsFirst"===i?N=[c,I,k,S]:"channelsLast"===i&&(N=[c,k,S,I]),{batchSize:c,dataFormat:i,inHeight:l,inWidth:u,inChannels:h,outHeight:k,outWidth:S,outChannels:I,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:x,dilationHeight:y,dilationWidth:b,inShape:e,outShape:N,filterShape:t}}function xl(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",i=arguments.length>7?arguments[7]:void 0,[c,l,u,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[c,l,u,h,d]=e;else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat ".concat(o));[c,d,l,u,h]=e}const[p,f,m,,g]=t,[y,b,v]=Sl(n),[x,w,k]=Sl(a),S=Il(p,x),I=Il(f,w),N=Il(m,k),{padInfo:C,outDepth:T,outHeight:E,outWidth:R}=function(e,t,n,a,r,s,o,i,c,l,u){let h,d,p,f;if("number"===typeof e){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,a,r,s){null==r&&(r=wl(e,t,a));const o=e[0],i=e[1],c=e[2],l=Nl((o-t+2*r)/a+1,s),u=Nl((i-t+2*r)/a+1,s),h=Nl((c-t+2*r)/a+1,s);return[l,u,h,n]}([t,n,a,1],i,1,r,e,u);d=s[0],p=s[1],f=s[2]}else if("same"===e){d=Math.ceil(t/r),p=Math.ceil(n/s),f=Math.ceil(a/o);const e=(d-1)*r+i-t,u=(p-1)*s+c-n,m=(f-1)*o+l-a,g=Math.floor(e/2),y=e-g,b=Math.floor(u/2),v=u-b,x=Math.floor(m/2);h={top:b,bottom:v,left:x,right:m-x,front:g,back:y,type:"SAME"}}else{if("valid"!==e)throw Error("Unknown padding parameter: ".concat(e));h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((t-i+1)/r),p=Math.ceil((n-c+1)/s),f=Math.ceil((a-l+1)/o)}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(r,l,u,h,y,b,v,S,I,N,i),A=s?g*d:g;let _;return"channelsFirst"===o?_=[c,A,T,E,R]:"channelsLast"===o&&(_=[c,T,E,R,A]),{batchSize:c,dataFormat:o,inDepth:l,inHeight:u,inWidth:h,inChannels:d,outDepth:T,outHeight:E,outWidth:R,outChannels:A,padInfo:C,strideDepth:y,strideHeight:b,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:S,effectiveFilterHeight:I,effectiveFilterWidth:N,dilationDepth:x,dilationHeight:w,dilationWidth:k,inShape:e,outShape:_,filterShape:t}}function wl(e,t,n){const a=Il(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+a)/2)}function kl(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function Sl(e){return"number"===typeof e?[e,e,e]:e}function Il(e,t){return t<=1?e:e+(e-1)*(t-1)}function Nl(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error("Unknown roundingMode ".concat(t))}}function Cl(e){const[t,n,a]=kl(e);return 1===t&&1===n&&1===a}function Tl(e,t){return Cl(e)||Cl(t)}function El(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error("Unknown dataFormat ".concat(e))}function Rl(e,t,n){if(null!=n){if("string"===typeof t)throw Error("Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,"."));if("number"===typeof t)Et(Dt(t),(()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,".")));else{if("object"!==typeof t)throw Error("Error in ".concat(e,": Unknown padding parameter: ").concat(t));t.forEach((t=>{t.forEach((t=>{Et(Dt(t),(()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,".")))}))}))}}}const Al=jo({reshape_:function(e,t){const n={x:Uo(e,"x","reshape","string_or_numeric")},a={shape:t};return Fo.runKernel(Ir,n,a)}});const _l=jo({avgPool_:function(e,t,n,a,r){const s=Uo(e,"x","avgPool","float32");Et(Tl(n,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'")));let o=s,i=!1;3===s.rank&&(i=!0,o=Al(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Et(4===o.rank,(()=>"Error in avgPool: x must be rank 4 but got rank ".concat(o.rank,"."))),Rl("avgPool",a,r);const c={x:o},l={filterSize:t,strides:n,pad:a,dimRoundingMode:r};let u=Fo.runKernel(An,c,l);return u=Xi(u,s.dtype),i?Al(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const Fl=jo({avgPool3d_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const o=Uo(e,"x","avgPool3d","float32");let i=o,c=!1;4===o.rank&&(c=!0,i=Al(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Et(5===i.rank,(()=>"Error in avgPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),Et("NDHWC"===s,(()=>"Error in avgPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(s))),Rl("avgPool3d",a,r);const l={x:i},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s};let h=Fo.runKernel(Fn,l,u);return h=Xi(h,i.dtype),c?Al(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const Ol=jo({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;Et(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=Vo(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(e.dtype,". "))})),1===n.length)return Yi(n[0]);const a=n,r={axis:t};return Fo.runKernel(Gn,a,r)}});const Dl=jo({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=Uo(e,"a","matMul"),s=Uo(t,"b","matMul");[r,s]=Io(r,s);const o={a:r,b:s},i={transposeA:n,transposeB:a};return Fo.runKernel(Dn,o,i)}});const Ml=jo({mul_:function(e,t){let n=Uo(e,"a","mul"),a=Uo(t,"b","mul");[n,a]=Io(n,a);const r={a:n,b:a};return Fo.runKernel(sr,r)}});const Ll=jo({sigmoid_:function(e){const t={x:Uo(e,"x","sigmoid","float32")};return Fo.runKernel(Ur,t)}});const Pl=jo({slice_:function(e,t,n){const a=Uo(e,"x","slice","string_or_numeric");if(0===a.rank)throw new Error("Slicing scalar is not possible");const r={x:a},s={begin:t,size:n};return Fo.runKernel(Pr,r,s)}});const zl=jo({tanh_:function(e){const t={x:Uo(e,"x","tanh","float32")};return Fo.runKernel(is,t)}});const Bl=jo({basicLSTMCell_:function(e,t,n,a,r,s){const o=Uo(e,"forgetBias","basicLSTMCell"),i=Uo(t,"lstmKernel","basicLSTMCell"),c=Uo(n,"lstmBias","basicLSTMCell"),l=Uo(a,"data","basicLSTMCell"),u=Uo(r,"c","basicLSTMCell"),h=Uo(s,"h","basicLSTMCell"),d=Ol([l,h],1),p=Dl(d,i),f=sl(p,c),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=Pl(f,[0,0],y),v=Pl(f,[0,g],y),x=Pl(f,[0,2*g],y),w=Pl(f,[0,3*g],y),k=sl(Ml(Ll(b),zl(v)),Ml(u,Ll(sl(o,x))));return[k,Ml(zl(k),Ll(w))]}});const Wl=jo({batchToSpaceND_:function(e,t,n){const a=Uo(e,"x","batchToSpaceND"),r=t.reduce(((e,t)=>e*t));Et(a.rank>=1+t.length,(()=>"input rank is ".concat(a.rank," but should be > than blockShape.length ").concat(t.length))),Et(n.length===t.length,(()=>"crops.length is ".concat(n.length," but should be equal to blockShape.length  ").concat(t.length))),Et(a.shape[0]%r===0,(()=>"input tensor batch is ".concat(a.shape[0]," but is not divisible by the product of ")+"the elements of blockShape ".concat(t.join(" * ")," === ").concat(r)));const s={x:a},o={blockShape:t,crops:n};return Fo.runKernel(Mn,s,o)}});const Ul=jo({batchNorm_:function(e,t,n,a,r,s){null==s&&(s=.001);const o=Uo(e,"x","batchNorm"),i=Uo(t,"mean","batchNorm"),c=Uo(n,"variance","batchNorm");let l,u;null!=r&&(l=Uo(r,"scale","batchNorm")),null!=a&&(u=Uo(a,"offset","batchNorm")),Et(i.rank===c.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Et(null==u||i.rank===u.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Et(null==l||i.rank===l.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const h={x:function(e){let t;return t=0===e.rank||1===e.rank?Al(e,[1,1,1,e.size]):2===e.rank?Al(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Al(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(o),scale:l,offset:u,mean:i,variance:c},d={varianceEpsilon:s},p=Fo.runKernel(Ia,h,d);return Al(p,o.shape)}});const Vl=jo({batchNorm2d_:function(e,t,n,a,r,s){const o=Uo(e,"x","batchNorm"),i=Uo(t,"mean","batchNorm"),c=Uo(n,"variance","batchNorm");let l,u;return null!=r&&(l=Uo(r,"scale","batchNorm")),null!=a&&(u=Uo(a,"offset","batchNorm")),Et(2===o.rank,(()=>"Error in batchNorm2D: x must be rank 2 but got rank "+"".concat(o.rank,"."))),Et(2===i.rank||1===i.rank,(()=>"Error in batchNorm2D: mean must be rank 2 or rank 1 but "+"got rank ".concat(i.rank,"."))),Et(2===c.rank||1===c.rank,(()=>"Error in batchNorm2D: variance must be rank 2 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&Et(2===l.rank||1===l.rank,(()=>"Error in batchNorm2D: scale must be rank 2 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&Et(2===u.rank||1===u.rank,(()=>"Error in batchNorm2D: offset must be rank 2 or rank 1 "+"but got rank ".concat(u.rank,"."))),Ul(o,i,c,u,l,s)}});const Gl=jo({batchNorm3d_:function(e,t,n,a,r,s){const o=Uo(e,"x","batchNorm"),i=Uo(t,"mean","batchNorm"),c=Uo(n,"variance","batchNorm");let l,u;return null!=r&&(l=Uo(r,"scale","batchNorm")),null!=a&&(u=Uo(a,"offset","batchNorm")),Et(3===o.rank,(()=>"Error in batchNorm3D: x must be rank 3 but got rank "+"".concat(o.rank,"."))),Et(3===i.rank||1===i.rank,(()=>"Error in batchNorm3D: mean must be rank 3 or rank 1 but "+"got rank ".concat(i.rank,"."))),Et(3===c.rank||1===c.rank,(()=>"Error in batchNorm3D: variance must be rank 3 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&Et(3===l.rank||1===l.rank,(()=>"Error in batchNorm3D: scale must be rank 3 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&Et(3===u.rank||1===u.rank,(()=>"Error in batchNorm3D: offset must be rank 3 or rank 1 "+"but got rank ".concat(u.rank,"."))),Ul(o,i,c,u,l,s)}});const jl=jo({batchNorm4d_:function(e,t,n,a,r,s){const o=Uo(e,"x","batchNorm"),i=Uo(t,"mean","batchNorm"),c=Uo(n,"variance","batchNorm");let l,u;return null!=r&&(l=Uo(r,"scale","batchNorm")),null!=a&&(u=Uo(a,"offset","batchNorm")),Et(4===o.rank,(()=>"Error in batchNorm4D: x must be rank 4 but got rank "+"".concat(o.rank,"."))),Et(4===i.rank||1===i.rank,(()=>"Error in batchNorm4D: mean must be rank 4 or rank 1 but "+"got rank ".concat(i.rank,"."))),Et(4===c.rank||1===c.rank,(()=>"Error in batchNorm4D: variance must be rank 4 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&Et(4===l.rank||1===l.rank,(()=>"Error in batchNorm4D: scale must be rank 4 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&Et(4===u.rank||1===u.rank,(()=>"Error in batchNorm4D: offset must be rank 4 or rank 1 "+"but got rank ".concat(u.rank,"."))),Ul(o,i,c,u,l,s)}});const Hl=jo({bincount_:function(e,t,n){const a=Uo(e,"x","bincount"),r=Uo(t,"weights","bincount");Et("int32"===a.dtype,(()=>"Error in bincount: input "+"dtype must be int32, but got ".concat(a.dtype))),Et(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),Et(r.size===a.size||0===r.size,(()=>"Error in bincount: weights must have the same size as input or"+"0-length, but got input shape: ".concat(a.shape,", weights shape: ")+"".concat(r.shape,".")));const s={x:a,weights:r},o={size:n};return Fo.runKernel(Ln,s,o)}});const Kl=jo({broadcastArgs_:function(e,t){const n=Uo(e,"s0","broadcastArgs","int32"),a=Uo(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error("broadcastArgs(): first input must be a vector (rank=1). "+"Has rank ".concat(n.rank));if(1!==a.rank)throw new Error("broadcastArgs(): second input must be a vector (rank=1). "+"Has rank ".concat(a.rank));const r={s0:n,s1:a};return Fo.runKernel(Pn,r)}});const ql=jo({broadcastTo_:function(e,t){let n=Uo(e,"broadcastTo","x");const a=n.shape;if(t.some((e=>!(e>0)||e%1!==0)))throw new Error("broadcastTo(): Invalid broadcast shape [".concat(t,"]."));if(t.length<n.rank)throw new Error("broadcastTo(): shape.length=".concat(t.length," < input.rank=").concat(n.rank,"."));if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Al(n,e)}const r=n.shape,s=Array.from(t);for(let c=t.length-1;c>=0;c--)if(r[c]===t[c])s[c]=1;else if(1!==n.shape[c])throw new Error("broadcastTo(): [".concat(a,"] cannot be broadcast to [").concat(t,"]."));if(0===s.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return Yi(n);const o={x:n},i={reps:s};return Fo.runKernel(cs,o,i)}});const Xl=jo({ceil_:function(e){const t={x:Uo(e,"x","ceil","float32")};return Fo.runKernel(Bn,t)}});function Yl(e,t,n){const a={shape:e,value:t,dtype:n};return Fo.runKernel(xa,{},a)}const Zl=jo({clipByValue_:function(e,t,n){const a=Uo(e,"x","clipByValue");if(Et(t<=n,(()=>"Error in clip: min (".concat(t,") must be ")+"less than or equal to max (".concat(n,")."))),t===n)return Yl(a.shape,t,a.dtype);const r={x:a},s={clipValueMin:t,clipValueMax:n};return Fo.runKernel(Wn,r,s)}});const Ql=jo({concat1d_:function(e){return Ol(e,0)}});const Jl=jo({concat2d_:function(e,t){return Ol(e,t)}});const $l=jo({concat3d_:function(e,t){return Ol(e,t)}});const eu=jo({concat4d_:function(e,t){return Ol(e,t)}});const tu=jo({conv2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0;const i=Uo(e,"x","conv2d","float32"),c=Uo(t,"filter","conv2d","float32");let l=i,u=!1;3===i.rank&&(u=!0,l=Al(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Et(4===l.rank,(()=>"Error in conv2d: input must be rank 4, but got rank ".concat(l.rank,"."))),Et(4===c.rank,(()=>"Error in conv2d: filter must be rank 4, but got rank "+"".concat(c.rank,"."))),Rl("conv2d",a,o);const h="NHWC"===r?l.shape[3]:l.shape[1];Et(h===c.shape[2],(()=>"Error in conv2d: depth of input (".concat(h,") must match ")+"input depth for filter ".concat(c.shape[2],"."))),Et(Tl(n,s),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(s,"'")));const d={x:l,filter:c},p={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:o},f=Fo.runKernel(jn,d,p);return u?Al(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const nu=jo({conv1d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,o=arguments.length>6?arguments[6]:void 0;const i=Uo(e,"x","conv1d"),c=Uo(t,"filter","conv1d");let l=i,u=!1;2===i.rank&&(u=!0,l=Al(i,[1,i.shape[0],i.shape[1]])),Et(3===l.rank,(()=>"Error in conv1d: input must be rank 3, but got rank ".concat(l.rank,"."))),Et(3===c.rank,(()=>"Error in conv1d: filter must be rank 3, but got rank "+"".concat(c.rank,"."))),Rl("conv1d",a,o),Et(l.shape[2]===c.shape[1],(()=>"Error in conv1d: depth of input (".concat(l.shape[2],") must match ")+"input depth for filter ".concat(c.shape[1],"."))),Et(Tl(n,s),(()=>"Error in conv1D: Either stride or dilation must be 1. "+"Got stride ".concat(n," and dilation '").concat(s,"'"))),Et("NWC"===r,(()=>"Error in conv1d: got dataFormat of ".concat(r," but only NWC is currently supported.")));const h=Al(c,[1,c.shape[0],c.shape[1],c.shape[2]]),d=Al(l,[l.shape[0],1,l.shape[1],l.shape[2]]),p=tu(d,h,[1,n],a,"NHWC",[1,s],o);return Al(p,u?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const au=jo({conv2DBackpropInput_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",o=arguments.length>6?arguments[6]:void 0;Et(e.length===t.rank,(()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match")));let i=e,c=t,l=!1;3===t.rank&&(l=!0,c=Al(t,[1,t.shape[0],t.shape[1],t.shape[2]]),i=[1,e[0],e[1],e[2]]),Et(4===i.length,(()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+"".concat(i.length,"."))),Et(4===c.rank,(()=>"Error in conv2dDerInput: dy must be rank 4, but got "+"rank ".concat(c.rank))),Et(4===n.rank,(()=>"Error in conv2dDerInput: filter must be rank 4, but got "+"rank ".concat(n.rank)));const u="NHWC"===s?i[3]:i[1],h="NHWC"===s?c.shape[3]:c.shape[1];Et(u===n.shape[2],(()=>"Error in conv2dDerInput: depth of input (".concat(u,") must ")+"match input depth for filter ".concat(n.shape[2],"."))),Et(h===n.shape[3],(()=>"Error in conv2dDerInput: depth of output (".concat(h,") must ")+"match output depth for filter ".concat(n.shape[3],"."))),Rl("conv2dDerInput",r,o);const d={dy:c,filter:n},p={strides:a,pad:r,dataFormat:s,dimRoundingMode:o,inputShape:i},f=Fo.runKernel(Kn,d,p);return l?Al(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const ru=jo({conv2dTranspose_:function(e,t,n,a,r,s){const o=Uo(e,"x","conv2dTranspose"),i=Uo(t,"filter","conv2dTranspose");return au(n,o,i,a,r,"NHWC",s)}});const su=jo({conv3d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const o=Uo(e,"x","conv3d"),i=Uo(t,"filter","conv3d");let c=o,l=!1;4===o.rank&&(l=!0,c=Al(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Et(5===c.rank,(()=>"Error in conv3d: input must be rank 5, but got rank ".concat(c.rank,"."))),Et(5===i.rank,(()=>"Error in conv3d: filter must be rank 5, but got rank "+"".concat(i.rank,"."))),Et(c.shape[4]===i.shape[3],(()=>"Error in conv3d: depth of input (".concat(c.shape[4],") must match ")+"input depth for filter ".concat(i.shape[3],"."))),Et(Tl(n,s),(()=>"Error in conv3D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(s,"'"))),Et("NDHWC"===r,(()=>"Error in conv3d: got dataFormat of ".concat(r," but only NDHWC is currently supported.")));const u={x:c,filter:i},h={strides:n,pad:a,dataFormat:r,dilations:s},d=Fo.runKernel(qn,u,h);return l?Al(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const ou=jo({conv3DBackpropInput_:function(e,t,n,a,r){Et(e.length===t.rank,(()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match")));let s=e,o=t,i=!1;4===t.rank&&(i=!0,o=Al(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);const c=s[4],l=o.shape[4];Et(5===s.length,(()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+"".concat(s.length,"."))),Et(5===o.rank,(()=>"Error in conv3dDerInput: dy must be rank 5, but got "+"rank ".concat(o.rank))),Et(5===n.rank,(()=>"Error in conv3dDerInput: filter must be rank 5, but got "+"rank ".concat(n.rank))),Et(c===n.shape[3],(()=>"Error in conv3dDerInput: depth of input (".concat(c,") must ")+"match input depth for filter ".concat(n.shape[3],"."))),Et(l===n.shape[4],(()=>"Error in conv3dDerInput: depth of output (".concat(l,") must ")+"match output depth for filter ".concat(n.shape[4],".")));const u={dy:o,filter:n},h={pad:r,strides:a,inputShape:s},d=Fo.runKernel(Yn,u,h);return i?Al(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const iu=jo({conv3dTranspose_:function(e,t,n,a,r){const s=Uo(e,"x","conv3dTranspose"),o=Uo(t,"filter","conv3dTranspose");return ou(n,s,o,a,r)}});const cu=jo({cos_:function(e){const t={x:Uo(e,"x","cos","float32")};return Fo.runKernel(Zn,t)}});const lu=jo({cosh_:function(e){const t={x:Uo(e,"x","cosh","float32")};return Fo.runKernel(Qn,t)}});const uu=jo({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={x:Uo(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:a};return Fo.runKernel(Jn,r,s)}});const hu=jo({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={x:Uo(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:a};return Fo.runKernel($n,r,s)}});const du=jo({denseBincount_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Uo(e,"x","denseBincount"),s=Uo(t,"weights","denseBincount");Et("int32"===r.dtype,(()=>"Error in denseBincount: input "+"dtype must be int32, but got ".concat(r.dtype))),Et(r.rank<=2,(()=>"Error in denseBincount: input must be at most rank 2, but got "+"rank ".concat(r.rank,"."))),Et(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),Et(s.size===r.size||0===s.size,(()=>"Error in denseBincount: weights must have the same shape as x or "+"0-length, but got x shape: ".concat(r.shape,", weights shape: ")+"".concat(s.shape,".")));const o={x:r,weights:s},i={size:n,binaryOutput:a};return Fo.runKernel(ta,o,i)}});const pu=jo({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const a=Uo(e,"x","depthToSpace","float32"),r="NHWC"===n?a.shape[1]:a.shape[2],s="NHWC"===n?a.shape[2]:a.shape[3],o="NHWC"===n?a.shape[3]:a.shape[1];Et(t>1,(()=>"blockSize should be > 1 for depthToSpace, but was: ".concat(t))),Et(r*t>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(r," and ").concat(t,"  for depthToSpace with input shape\n    ").concat(a.shape))),Et(s*t>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(s," and ").concat(t," for depthToSpace with input shape\n        ").concat(a.shape))),Et(o%(t*t)===0,(()=>"Dimension size must be evenly divisible by ".concat(t*t," but is ").concat(o," for depthToSpace with input shape ").concat(a.shape)));const i={x:a},c={blockSize:t,dataFormat:n};return Fo.runKernel(na,i,c)}});const fu=jo({depthwiseConv2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0;const i=Uo(e,"x","depthwiseConv2d","float32"),c=Uo(t,"filter","depthwiseConv2d","float32");let l=i,u=!1;3===i.rank&&(u=!0,l=Al(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Et(4===l.rank,(()=>"Error in depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(l.rank,"."))),Et(4===c.rank,(()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+"".concat(c.rank,".")));const h="NHWC"===r?l.shape[3]:l.shape[1];Et(h===c.shape[2],(()=>"Error in depthwiseConv2d: number of input channels "+"(".concat(h,") must match the inChannels dimension in ")+"filter ".concat(c.shape[2],"."))),Rl("depthwiseConv2d",a,o);const d={x:l,filter:c},p={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:o},f=Fo.runKernel(aa,d,p);return u?Al(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const mu=jo({diag_:function(e){const t={x:Uo(e,"x","diag")};return Fo.runKernel(oa,t)}});const gu=jo({dilation2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const o=Uo(e,"x","dilation2d"),i=Uo(t,"filter","dilation2d");Et(3===o.rank||4===o.rank,(()=>"Error in dilation2d: input must be rank 3 or 4, but got rank "+"".concat(o.rank,"."))),Et(3===i.rank,(()=>"Error in dilation2d: filter must be rank 3, but got rank "+"".concat(i.rank,"."))),Et("NHWC"===s,(()=>"Error in dilation2d: Only NHWC is currently supported, "+"but got dataFormat of ".concat(s)));let c=o,l=!1;3===o.rank&&(c=Al(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=!0);const u={x:c,filter:i},h={strides:n,pad:a,dilations:r},d=Fo.runKernel(ia,u,h);return l?Al(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});const yu=jo({floorDiv_:function(e,t){let n=Uo(e,"a","floorDiv"),a=Uo(t,"b","floorDiv");[n,a]=Io(n,a);const r={a:n,b:a};return Fo.runKernel(Sa,r)}});const bu=jo({div_:function(e,t){let n=Uo(e,"a","div"),a=Uo(t,"b","div");if([n,a]=Io(n,a),"int32"===n.dtype&&"int32"===a.dtype)return yu(n,a);const r={a:n,b:a};return Fo.runKernel(ua,r,{})}});const vu=jo({equal_:function(e,t){let n=Uo(e,"a","equal","string_or_numeric"),a=Uo(t,"b","equal","string_or_numeric");[n,a]=Io(n,a),vc(n.shape,a.shape);const r={a:n,b:a};return Fo.runKernel(ma,r)}});const xu=jo({where_:function(e,t,n){const a=Uo(t,"a","where"),r=Uo(n,"b","where"),s=Uo(e,"condition","where","bool"),o=vc(vc(s.shape,a.shape),r.shape),i={condition:ql(s,o),t:ql(a,o),e:ql(r,o)};return Fo.runKernel(Mr,i)}});const wu=jo({zerosLike_:function(e){const t={x:Uo(e,"x","zerosLike")};return Fo.runKernel(ms,t)}});const ku=jo({divNoNan_:function(e,t){let n=Uo(e,"a","div"),a=Uo(t,"b","div");[n,a]=Io(n,a);const r=bu(n,a),s=wu(r),o=vu(a,s);return xu(o,s,r)}});const Su=jo({dot_:function(e,t){const n=Uo(e,"t1","dot"),a=Uo(t,"t2","dot");Et((1===n.rank||2===n.rank)&&(1===a.rank||2===a.rank),(()=>"Error in dot: inputs must all be rank 1 or 2, but got ranks "+"".concat(n.rank," and ").concat(a.rank,".")));const r=1===n.rank?n.size:n.shape[1],s=1===a.rank?a.size:a.shape[0];if(Et(r===s,(()=>"Error in dot: inner dimensions of inputs must match, but got "+"".concat(r," and ").concat(s,"."))),1===n.rank&&1===a.rank){const e=Al(n,[1,-1]),t=Al(a,[-1,1]),r=Dl(e,t);return Al(r,[])}if(1===n.rank&&2===a.rank){const e=Al(n,[1,-1]),t=Al(a,[a.shape[0],a.shape[1]]),r=Dl(e,t);return Al(r,[r.size])}if(2===n.rank&&1===a.rank){const e=Al(a,[-1,1]),t=Dl(n,e);return Al(t,[t.size])}{const e=Al(a,[a.shape[0],a.shape[1]]);return Dl(n,e)}}});const Iu=jo({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];const r=n.map(((e,t)=>Uo(e,"tensors".concat(t),"einsum"))),s={equation:e};return Fo.runKernel(ha,r,s)}});const Nu=jo({elu_:function(e){const t={x:Uo(e,"x","elu","float32")};return Fo.runKernel(da,t)}});const Cu=jo({erf_:function(e){let t=Uo(e,"x","erf");Et("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=Xi(t,"float32"));const n={x:t};return Fo.runKernel(fa,n)}});function Tu(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Eu(e,t,n){const a=e.length+t.length,r=[];let s=0,o=0;for(let i=0;i<a;i++)-1===n.indexOf(i)?r.push(e[s++]):r.push(t[o++]);return r}function Ru(e,t){const n=[],a=e.length;for(let r=0;r<a;r++)-1===t.indexOf(r)&&n.push(e[r]);return[n,t.map((t=>e[t]))]}function Au(e,t){return Eu(e,t.map((e=>1)),t)}function _u(e,t,n){Et(Tu(t,n),(()=>"".concat(e," supports only inner-most axes for now. ")+"Got axes ".concat(t," and rank-").concat(n," input.")))}function Fu(e,t){if(Tu(e,t))return null;const n=[];for(let a=0;a<t;++a)-1===e.indexOf(a)&&n.push(a);return e.forEach((e=>n.push(e))),n}function Ou(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function Du(e,t){const n=[];for(let a=t-e;a<t;++a)n.push(a);return n}const Mu=jo({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Uo(e,"x","max")},r={reductionIndices:t,keepDims:n};return Fo.runKernel(Ka,a,r)}});const Lu=jo({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Uo(e,"x","min")},r={axis:t,keepDims:n};return Fo.runKernel(er,a,r)}});const Pu=jo({pow_:function(e,t){let n=Uo(e,"base","pow"),a=Uo(t,"exp","pow");[n,a]=Io(n,a);const r={a:n,b:a};return Fo.runKernel(mr,r)}});const zu=jo({sqrt_:function(e){const t={x:Uo(e,"x","sqrt","float32")};return Fo.runKernel(Gr,t)}});const Bu=jo({square_:function(e){const t=Uo(e,"x","square");return Fo.runKernel("Square",{x:t},{})}});const Wu=jo({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=Uo(e,"x","sum");"bool"===a.dtype&&(a=Xi(a,"int32"));const r={x:a},s={axis:t,keepDims:n};return Fo.runKernel(jr,r,s)}});function Uu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return nl(e);if(1!==e.rank&&null===n)return Uu(Al(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return Wu(nl(e),n);if(t===1/0)return Mu(nl(e),n);if(t===-1/0)return Lu(nl(e),n);if("euclidean"===t||2===t)return zu(Wu(Pu(nl(e),el(2,"int32")),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}if(Array.isArray(n)&&2===n.length){if(1===t)return Mu(Wu(nl(e),n[0]),n[1]-1);if(t===1/0)return Mu(Wu(nl(e),n[1]),n[0]);if(t===-1/0)return Lu(Wu(nl(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return zu(Wu(Bu(e),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}throw new Error("Error in norm: invalid axis: ".concat(n))}const Vu=jo({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Uu(e=Uo(e,"x","norm"),t,n);let s=r.shape;if(a){const t=Bt(n,e.shape);s=Au(r.shape,t)}return Al(r,s)}});const Gu=jo({euclideanNorm_:function(e){return Vu(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});const ju=jo({exp_:function(e){const t={x:Uo(e,"x","exp")};return Fo.runKernel(ga,t)}});const Hu=jo({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Uo(e,"x","expandDims","string_or_numeric");Et(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const a={input:n},r={dim:t};return Fo.runKernel(ya,a,r)}});const Ku=jo({expm1_:function(e){const t={x:Uo(e,"x","expm1")};return Fo.runKernel(ba,t)}});const qu=jo({tile_:function(e,t){const n=Uo(e,"x","tile","string_or_numeric");Et(n.rank===t.length,(()=>"Error in transpose: rank of input ".concat(n.rank," ")+"must match length of reps ".concat(t,".")));const a={x:n},r={reps:t};return Fo.runKernel(cs,a,r)}});const Xu=jo({eye_:function(e,t,n){null==t&&(t=e);const a=qi([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),r=e<=t?e:t;for(let o=0;o<r;++o)a.set(1,o,o);const s=Al(a.toTensor(),[e,t]);if(null==n)return s;if(1===n.length)return qu(Hu(s,0),[n[0],1,1]);if(2===n.length)return qu(Hu(Hu(s,0),0),[n[0],n[1],1,1]);if(3===n.length)return qu(Hu(Hu(Hu(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D "+"batchShapes, but received ".concat(n.length,"D."))}});const Yu=jo({floor_:function(e){const t={x:Uo(e,"x","floor","float32")};return Fo.runKernel(ka,t)}});const Zu=jo({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const r={x:Uo(e,"x","gather"),indices:Uo(t,"indices","gather","int32")},s={axis:n,batchDims:a};return Fo.runKernel(Na,r,s)}});const Qu=jo({greater_:function(e,t){let n=Uo(e,"a","greater","string_or_numeric"),a=Uo(t,"b","greater","string_or_numeric");[n,a]=Io(n,a),vc(n.shape,a.shape);const r={a:n,b:a};return Fo.runKernel(Ta,r)}});const Ju=jo({greaterEqual_:function(e,t){let n=Uo(e,"a","greaterEqual","string_or_numeric"),a=Uo(t,"b","greaterEqual","string_or_numeric");[n,a]=Io(n,a),vc(n.shape,a.shape);const r={a:n,b:a};return Fo.runKernel(Ea,r)}});const $u=jo({imag_:function(e){const t={input:Uo(e,"input","imag")};return Fo.runKernel(_a,t)}});const eh=jo({isFinite_:function(e){const t={x:Uo(e,"x","isFinite")};return Fo.runKernel(Fa,t)}});const th=jo({isInf_:function(e){const t={x:Uo(e,"x","isInf")};return Fo.runKernel(Oa,t)}});const nh=jo({isNaN_:function(e){const t={x:Uo(e,"x","isNaN")};return Fo.runKernel(Da,t)}});const ah=jo({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:Uo(e,"x","leakyRelu")},a={alpha:t};return Fo.runKernel(Ma,n,a)}});const rh=jo({less_:function(e,t){let n=Uo(e,"a","less","string_or_numeric"),a=Uo(t,"b","less","string_or_numeric");[n,a]=Io(n,a),vc(n.shape,a.shape);const r={a:n,b:a};return Fo.runKernel(La,r)}});const sh=jo({lessEqual_:function(e,t){let n=Uo(e,"a","lessEqual","string_or_numeric"),a=Uo(t,"b","lessEqual","string_or_numeric");[n,a]=Io(n,a),vc(n.shape,a.shape);const r={a:n,b:a};return Fo.runKernel(Pa,r)}});function oh(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const a={start:e,stop:t,num:n};return Fo.runKernel(za,{},a)}const ih=jo({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const s=Uo(e,"x","localResponseNormalization");Et(4===s.rank||3===s.rank,(()=>"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ".concat(s.rank,"."))),Et(Dt(t),(()=>"Error in localResponseNormalization: depthRadius must be an "+"integer but got depthRadius ".concat(t,".")));let o=s,i=!1;3===s.rank&&(i=!0,o=Al(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const c={x:o},l={depthRadius:t,bias:n,alpha:a,beta:r},u=Fo.runKernel(ja,c,l);return i?Al(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const ch=jo({log_:function(e){const t={x:Uo(e,"x","log","float32")};return Fo.runKernel(Ba,t)}});const lh=jo({log1p_:function(e){const t={x:Uo(e,"x","log1p")};return Fo.runKernel(Wa,t)}});const uh=jo({neg_:function(e){const t={x:Uo(e,"x","neg")};return Fo.runKernel(or,t)}});const hh=jo({softplus_:function(e){const t={x:Uo(e,"x","softplus")};return Fo.runKernel(Vr,t)}});const dh=jo({logSigmoid_:function(e){const t=Uo(e,"x","logSigmoid");return $c((e=>({value:uh(hh(uh(e))),gradFunc:t=>Ml(t,Ll(uh(e)))})))(t)}});const ph=jo({sub_:function(e,t){let n=Uo(e,"a","sub"),a=Uo(t,"b","sub");[n,a]=Io(n,a);const r={a:n,b:a};return Fo.runKernel(ss,r)}});const fh=jo({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Uo(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and axis was ").concat(t));const a=$c(((e,n)=>{const a=Mu(e,t,!0),r=ph(e,a),s=ph(Xi(r,"float32"),ch(Wu(ju(r),t,!0)));n([s]);return{value:s,gradFunc:(e,n)=>{const[a]=n,r=ju(a);return ph(e,Ml(Wu(e,t,!0),r))}}}));return a(n)}});const mh=jo({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a=Uo(e,"x","logSumExp"),r=Bt(t,a.shape),s=Mu(a,r,!0),o=ph(a,s),i=ju(o),c=Wu(i,r),l=ch(c),u=sl(Al(s,l.shape),l);if(n){const e=Au(u.shape,r);return Al(u,e)}return u}});const gh=jo({logicalAnd_:function(e,t){const n=Uo(e,"a","logicalAnd","bool"),a=Uo(t,"b","logicalAnd","bool");vc(n.shape,a.shape);const r={a:n,b:a};return Fo.runKernel(Ua,r)}});const yh=jo({logicalNot_:function(e){const t={x:Uo(e,"x","logicalNot","bool")};return Fo.runKernel(Va,t)}});const bh=jo({logicalOr_:function(e,t){const n=Uo(e,"a","logicalOr","bool"),a=Uo(t,"b","logicalOr","bool");vc(n.shape,a.shape);const r={a:n,b:a};return Fo.runKernel(Ga,r)}});const vh=jo({logicalXor_:function(e,t){const n=Uo(e,"a","logicalXor","bool"),a=Uo(t,"b","logicalXor","bool");return vc(n.shape,a.shape),gh(bh(e,t),yh(gh(e,t)))}}),xh=2147483648;const wh=jo({searchSorted_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"left";const a=Uo(e,"sortedSequence","searchSorted"),r=Uo(t,"values","searchSorted"),s=a.shape[a.shape.length-1],o=r.shape[r.shape.length-1],i=Al(a,[-1,s]),c=Al(r,[-1,o]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==c.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Ft(c.shape)>=xh)throw new Error("values tensor size must less than ".concat(xh));if(i.shape[1]>=xh)throw new Error("trailing dim_size must less than ".concat(xh," for int32 output type, was ").concat(i.shape[1]));const l={sortedSequence:i,values:c},u={side:n};return Fo.runKernel(Dr,l,u)}});function kh(e,t){return wh(e,t,"left")}const Sh=jo({maxPool_:function(e,t,n,a,r){const s=Uo(e,"x","maxPool");let o=s,i=!1;3===s.rank&&(i=!0,o=Al(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Et(4===o.rank,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(o.rank,"."))),Et(Tl(n,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'"))),Rl("maxPool",a,r);const c={x:o},l={filterSize:t,strides:n,pad:a,dimRoundingMode:r},u=Fo.runKernel(Xa,c,l);return i?Al(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const Ih=jo({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const o=Uo(e,"x","maxPool3d");let i=o,c=!1;4===o.rank&&(c=!0,i=Al(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Et(5===i.rank,(()=>"Error in maxPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),Et("NDHWC"===s,(()=>"Error in maxPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(s))),Rl("maxPool3d",a,r);const l={x:i},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s},h=Fo.runKernel(Za,l,u);return c?Al(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const Nh=jo({maxPoolWithArgmax_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const s={x:Uo(e,"x","maxPoolWithArgmax")},o={filterSize:t,strides:n,pad:a,includeBatchInIndex:r},i=Fo.runKernel(Ja,s,o);return{result:i[0],indexes:i[1]}}});const Ch=jo({maximum_:function(e,t){let n=Uo(e,"a","maximum"),a=Uo(t,"b","maximum");[n,a]=Io(n,a),"bool"===n.dtype&&(n=Xi(n,"int32"),a=Xi(a,"int32")),vc(n.shape,a.shape);const r={a:n,b:a};return Fo.runKernel(qa,r)}});const Th=jo({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Uo(e,"x","mean")},r={axis:t,keepDims:n};return Fo.runKernel($a,a,r)}});function Eh(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if("complex64"===t){const t=Eh(e,"float32"),n=Eh(e,"float32");return Ho(t,n)}const n=tn(Ft(e),t);return Fo.makeTensor(n,e,t)}function Rh(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if("complex64"===t){const t=Rh(e,"float32"),n=Eh(e,"float32");return Ho(t,n)}const n=en(Ft(e),t);return Fo.makeTensor(n,e,t)}function Ah(e,t){let{indexing:n="xy"}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("xy"!==n&&"ij"!==n)throw new TypeError("".concat(n," is not a valid third argument to meshgrid"));if(void 0===e)return[];let a=Uo(e,"x","meshgrid",e instanceof po?e.dtype:"float32");if(void 0===t)return[a];let r=Uo(t,"y","meshgrid",t instanceof po?t.dtype:"float32");const s=Ft(a.shape),o=Ft(r.shape);return"xy"===n?(a=Al(a,[1,-1]),r=Al(r,[-1,1]),[Dl(Rh([o,1],a.dtype),a),Dl(r,Rh([1,s],r.dtype))]):(a=Al(a,[-1,1]),r=Al(r,[1,-1]),[Dl(a,Rh([1,o],a.dtype)),Dl(Rh([s,1],r.dtype),r)])}const _h=jo({minimum_:function(e,t){let n=Uo(e,"a","minimum"),a=Uo(t,"b","minimum");[n,a]=Io(n,a),"bool"===n.dtype&&(n=Xi(n,"int32"),a=Xi(a,"int32")),vc(n.shape,a.shape);const r={a:n,b:a};return Fo.runKernel(tr,r)}});const Fh=jo({mirrorPad_:function(e,t,n){Et("reflect"===n||"symmetric"===n,(()=>"Invalid mode. Mode must be either reflect or symmetric. "+"Got ".concat(n,".")));const a=Uo(e,"x","mirrorPad");if(0===a.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Et(t.length===a.rank,(()=>"Padding doesn't match input. Must be ".concat(a.rank,". ")+"Got ".concat(t.length,".")));const r="reflect"===n?1:0;for(let i=0;i<a.rank;i++)Et(2===t[i].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Et(t[i][0]>=0&&t[i][0]<=a.shape[i]-r&&t[i][1]>=0&&t[i][1]<=a.shape[i]-r,(()=>"Padding in dimension ".concat(i," cannot be greater than or equal ")+"to ".concat(a.shape[i]-r," or less than 0 for input of ")+"shape ".concat(a.shape)));const s={paddings:t,mode:n},o={x:a};return Fo.runKernel(nr,o,s)}});const Oh=jo({mod_:function(e,t){let n=Uo(e,"a","mod"),a=Uo(t,"b","mod");[n,a]=Io(n,a);const r={a:n,b:a};return Fo.runKernel(ar,r)}});const Dh=jo({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=Bt(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=Uo(e,"x","moments")).shape),a=Th(e,n,t);let r=a.shape;t||(r=Au(a.shape,n));const s=Bu(ph(Xi(e,"float32"),Al(a,r)));return{mean:a,variance:Th(s,n,t)}}});const Mh=jo({multiRNNCell_:function(e,t,n,a){const r=Uo(t,"data","multiRNNCell"),s=Vo(n,"c","multiRNNCell"),o=Vo(a,"h","multiRNNCell");let i=r;const c=[];for(let h=0;h<e.length;h++){const t=e[h](i,s[h],o[h]);c.push(t[0]),c.push(t[1]),i=t[1]}const l=[],u=[];for(let h=0;h<c.length;h+=2)l.push(c[h]),u.push(c[h+1]);return[l,u]}});const Lh=jo({multinomial_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Uo(e,"logits","multinomial"),s=r.size,o=r.rank;if(s<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+"".concat(s,"."));if(o>2)throw new Error("Rank of probabilities must be 1 or 2, but is ".concat(o));n=n||Math.random();const i={logits:1===o?Al(r,[1,-1]):r},c={numSamples:t,seed:n,normalized:a},l=Fo.runKernel(rr,i,c);return 1===o?Al(l,[l.size]):l}});const Ph=jo({notEqual_:function(e,t){let n=Uo(e,"a","notEqual","string_or_numeric"),a=Uo(t,"b","notEqual","string_or_numeric");[n,a]=Io(n,a),vc(n.shape,a.shape);const r={a:n,b:a};return Fo.runKernel(ir,r)}});const zh=jo({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(t));const s={indices:Uo(e,"indices","oneHot","int32")},o={dtype:r,depth:t,onValue:n,offValue:a};return Fo.runKernel(dr,s,o)}});const Bh=jo({onesLike_:function(e){const t={x:Uo(e,"x","onesLike")};return Fo.runKernel(hr,t)}});const Wh=jo({outerProduct_:function(e,t){const n=Uo(e,"v1","outerProduct"),a=Uo(t,"v2","outerProduct");Et(1===n.rank&&1===a.rank,(()=>"Error in outerProduct: inputs must be rank 1, but got ranks "+"".concat(n.rank," and ").concat(a.rank,".")));const r=Al(n,[-1,1]),s=Al(a,[1,-1]);return Dl(r,s)}});const Uh=jo({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a=Uo(e,"x","pad");if(0===a.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:t,constantValue:n},s={x:a};return Fo.runKernel(fr,s,r)}});const Vh=jo({pad1d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Et(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),Uh(e,[t],n)}});const Gh=jo({pad2d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Et(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Uh(e,t,n)}});const jh=jo({pad3d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Et(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Uh(e,t,n)}});const Hh=jo({pad4d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Et(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Uh(e,t,n)}});const Kh=jo({spaceToBatchND_:function(e,t,n){const a=Uo(e,"x","spaceToBatchND");Et(a.rank>=1+t.length,(()=>"input rank ".concat(a.rank," should be > than [blockShape] ").concat(t.length))),Et(n.length===t.length,(()=>"paddings.shape[0] ".concat(n.length," must be equal to [blockShape] ").concat(t.length))),Et(a.shape.reduce(((e,a,r)=>r>0&&r<=t.length?e&&(a+n[r-1][0]+n[r-1][1])%t[r-1]===0:e),!0),(()=>"input spatial dimensions ".concat(a.shape.slice(1)," with paddings ").concat(n.toString()," must be divisible by blockShapes ").concat(t.toString())));const r={x:a},s={blockShape:t,paddings:n};return Fo.runKernel(Hr,r,s)}});const qh=jo({pool_:function(e,t,n,a,r,s,o){null==r&&(r=[1,1]),null==s&&(s=1),0===a&&(a="valid");const i=Uo(e,"x","maxPool");let c=i,l=!1;3===i.rank&&(l=!0,c=Al(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Et(Tl(s,r),(()=>"Error in pool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(r,"'")));const u=yl(c.shape,t,s,r,a),h=[u.dilationHeight,u.dilationWidth];let d;d="same"===a?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))),a=n.map((e=>e-1)),r=a.map((e=>Math.floor(e/2))),s=a.map(((e,t)=>e-r[t]));return a.map(((e,t)=>[r[t],s[t]]))}([u.filterHeight,u.filterWidth],h):[[0,0],[0,0]];const p=1===h[0]&&1===h[1],[f,m]=function(e,t,n){const a=n.map((e=>e[0])),r=n.map((e=>e[1])),s=e.concat(a,r),o=t.map(((e,t)=>(e-s[t]%e)%e)),i=r.map(((e,t)=>e+o[t])),c=t.map(((e,t)=>[a[t],i[t]])),l=t.map(((e,t)=>[0,o[t]]));return[c,l]}([u.inHeight,u.inWidth],h,d),g=p?a:"valid",y=p?c:Kh(c,h,f),b=("avg"===n?()=>_l(y,t,s,g,o):()=>Sh(y,t,s,g,o))(),v=p?b:Wl(b,h,m);return l?Al(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});const Xh=jo({prelu_:function(e,t){const n={x:Uo(e,"x","prelu"),alpha:Uo(t,"alpha","prelu")};return Fo.runKernel(gr,n)}});const Yh=jo({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=Uo(e,"x","prod");"bool"===a.dtype&&(a=Xi(a,"int32"));const r={x:a},s={axis:t,keepDims:n};return Fo.runKernel(yr,r,s)}});const Zh=jo({raggedGather_:function(e,t,n,a){const r={paramsNestedSplits:e.map(((e,t)=>Uo(e,"tensors".concat(t),"raggedGather","int32"))),paramsDenseValues:Uo(t,"paramsDenseValues","raggedGather"),indices:Uo(n,"indices","raggedGather","int32")},s={outputRaggedRank:a},o=Fo.runKernel(br,r,s);return{outputNestedSplits:o.slice(0,o.length-1),outputDenseValues:o[o.length-1]}}});const Qh=jo({raggedTensorToTensor_:function(e,t,n,a,r){const s=Uo(e,"shape","raggedTensorToTensor","int32"),o=Uo(t,"values","raggedTensorToTensor"),i={shape:s,values:o,defaultValue:Uo(n,"defaultValue","raggedTensorToTensor",o.dtype),rowPartitionTensors:a.map(((e,t)=>Uo(e,"tensors".concat(t),"raggedTensorToTensor","int32")))},c={rowPartitionTypes:r};return Fo.runKernel(vr,i,c)}});const Jh=jo({rand_:function(e,t,n){const a=Ft(e);let r=null;if(null==n||"float32"===n)r=new Float32Array(a);else if("int32"===n)r=new Int32Array(a);else{if("bool"!==n)throw new Error("Unknown data type ".concat(n));r=new Uint8Array(a)}for(let s=0;s<a;s++)r[s]=t();return Fo.makeTensor(r,e,n)}});var $h=n(928);class ed{constructor(e,t,n,a,r){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=r||Math.random();this.random=$h.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let a,r,s;do{a=2*this.random()-1,r=2*this.random()-1,s=a*a+r*r}while(s>=1||0===s);const o=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*a*o,t=this.mean+this.stdDev*r*o,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class td{constructor(e,t,n,a){this.alpha=e,this.beta=1/t,this.dtype=n;const r=a||Math.random();this.randu=$h.alea(r.toString()),this.randn=new ed(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,a,r,s;for(;;){do{a=this.randn.nextValue(),s=1+this.c*a}while(s<=0);if(s*=s*s,e=a*a,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),r=this.randu(),r<t||Math.log(r)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class nd{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==a&&(a=Math.random()),"number"===typeof a&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between ".concat(e," - ").concat(t," <= 1 and dtype is not float"));this.random=$h.alea(a)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const ad=jo({randomGamma_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",r=arguments.length>4?arguments[4]:void 0;if(null==n&&(n=1),null==a&&(a="float32"),"float32"!==a&&"int32"!==a)throw new Error("Unsupported data type ".concat(a));const s=new td(t,n,a,r),o=qi(e,a);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});const rd=jo({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(null!=a&&"bool"===a)throw new Error("Unsupported data type ".concat(a));const s=new ed(t,n,a,!1,r),o=qi(e,a);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});const sd=jo({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error("Unsupported data type ".concat(t));return rd(e,0,1,t,n)}});const od=jo({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>4?arguments[4]:void 0;const r=qi(e,arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),s=new nd(t,n,null,a);for(let o=0;o<r.values.length;o++)r.values[o]=s.nextValue();return r.toTensor()}});function id(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const r={start:e,stop:t,step:n,dtype:a};return Fo.runKernel(xr,{},r)}const cd=jo({real_:function(e){const t={input:Uo(e,"input","real")};return Fo.runKernel(wr,t)}});const ld=jo({reciprocal_:function(e){const t={x:Uo(e,"x","reciprocal")};return Fo.runKernel(kr,t)}});const ud=jo({relu_:function(e){const t={x:Uo(e,"x","relu")};return Fo.runKernel(Sr,t)}});const hd=jo({relu6_:function(e){const t={x:Uo(e,"x","relu6")};return Fo.runKernel(Rr,t)}});const dd=jo({reverse_:function(e,t){const n={x:Uo(e,"x","reverse")},a={dims:t};return Fo.runKernel(Ar,n,a)}});const pd=jo({reverse1d_:function(e){const t=Uo(e,"x","reverse");return Et(1===t.rank,(()=>"Error in reverse1D: x must be rank 1 but got rank ".concat(t.rank,"."))),dd(t,0)}});const fd=jo({reverse2d_:function(e,t){const n=Uo(e,"x","reverse");return Et(2===n.rank,(()=>"Error in reverse2D: x must be rank 2 but got rank ".concat(n.rank,"."))),dd(n,t)}});const md=jo({reverse3d_:function(e,t){const n=Uo(e,"x","reverse");return Et(3===n.rank,(()=>"Error in reverse3D: x must be rank 3 but got rank ".concat(n.rank,"."))),dd(n,t)}});const gd=jo({reverse4d_:function(e,t){const n=Uo(e,"x","reverse");return Et(4===n.rank,(()=>"Error in reverse4D: x must be rank 4 but got rank ".concat(n.rank,"."))),dd(n,t)}});const yd=jo({round_:function(e){const t={x:Uo(e,"x","round")};return Fo.runKernel(_r,t)}});const bd=jo({rsqrt_:function(e){const t={x:Uo(e,"x","rsqrt","float32")};return Fo.runKernel(Fr,t)}});const vd=jo({selu_:function(e){const t={x:Uo(e,"x","selu")};return Fo.runKernel(Lr,t)}});const xd=jo({separableConv2d_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const i=Uo(e,"x","separableConv2d"),c=Uo(t,"depthwiseFilter","separableConv2d"),l=Uo(n,"pointwiseFilter","separableConv2d");let u=i,h=!1;if(3===i.rank&&(h=!0,u=Al(i,[1,i.shape[0],i.shape[1],i.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Et(4===u.rank,(()=>"Error in separableConv2d: input must be rank 4, but got "+"rank ".concat(u.rank,"."))),Et(4===c.rank,(()=>"Error in separableConv2d: depthwise filter must be rank 4, but "+"got rank ".concat(c.rank,"."))),Et(4===l.rank,(()=>"Error in separableConv2d: pointwise filter must be rank 4, but "+"got rank ".concat(c.rank,"."))),Et(1===l.shape[0],(()=>"Error in separableConv2d: the first dimension of pointwise filter "+" must be 1, but got ".concat(l.shape[0],"."))),Et(1===l.shape[1],(()=>"Error in separableConv2d: the second dimension of pointwise "+"filter must be 1, but got ".concat(l.shape[1],".")));const d=c.shape[2],p=c.shape[3];Et(l.shape[2]===d*p,(()=>"Error in separableConv2d: the third dimension of pointwise filter "+"must be ".concat(d*p,", ")+"but got ".concat(l.shape[2],".")));const f=fu(u,c,a,r,o,s),m=tu(f,l,1,"valid",o);return h?Al(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});const wd=async function(e,t){const n=Uo(e,"x","setdiff1d"),a=Uo(t,"y","setdiff1d");Et(n.dtype===a.dtype,(()=>"x and y should have the same dtype, but got x (".concat(n.dtype,") and y (").concat(a.dtype,")."))),Et(1===n.rank,(()=>"x should be 1D tensor, but got x (".concat(n.shape,")."))),Et(1===a.rank,(()=>"y should be 1D tensor, but got y (".concat(a.shape,").")));const r=await n.data(),s=await a.data(),o=new Set(s);let i=0;for(let u=0;u<r.length;u++)o.has(r[u])||i++;const c=new co([i],n.dtype),l=new co([i],"int32");for(let u=0,h=0;u<r.length;u++)o.has(r[u])||(c.values[h]=r[u],l.values[h]=u,h++);return[c.toTensor(),l.toTensor()]};const kd=jo({sign_:function(e){const t={x:Uo(e,"x","sign")};return Fo.runKernel(Wr,t)}});const Sd=jo({sin_:function(e){const t={x:Uo(e,"x","sin","float32")};return Fo.runKernel(zr,t)}});const Id=jo({sinh_:function(e){const t={x:Uo(e,"x","sinh")};return Fo.runKernel(Br,t)}});const Nd=jo({slice1d_:function(e,t,n){const a=Uo(e,"x","slice1d");return Et(1===a.rank,(()=>"slice1d expects a rank-1 tensor, but got a rank-".concat(a.rank," tensor"))),Pl(a,[t],[n])}});const Cd=jo({slice2d_:function(e,t,n){const a=Uo(e,"x","slice2d");return Et(2===a.rank,(()=>"slice2d expects a rank-2 tensor, but got a rank-".concat(a.rank," tensor"))),Pl(a,t,n)}});const Td=jo({slice3d_:function(e,t,n){const a=Uo(e,"x","slice3d");return Et(3===a.rank,(()=>"slice3d expects a rank-3 tensor, but got a rank-".concat(a.rank," tensor"))),Pl(a,t,n)}});const Ed=jo({slice4d_:function(e,t,n){const a=Uo(e,"x","slice4d");return Et(4===a.rank,(()=>"slice4d expects a rank-4 tensor, but got a rank-".concat(a.rank," tensor"))),Pl(a,t,n)}});const Rd=jo({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Uo(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and dim was ").concat(t));const a={logits:n},r={dim:t};return Fo.runKernel(qr,a,r)}});const Ad=jo({fft_:function(e){Et("complex64"===e.dtype,(()=>"The dtype for tf.spectral.fft() must be complex64 "+"but got ".concat(e.dtype,".")));const t={input:e};return Fo.runKernel(va,t)}});const _d=jo({ifft_:function(e){Et("complex64"===e.dtype,(()=>"The dtype for tf.spectral.ifft() must be complex64 "+"but got ".concat(e.dtype,".")));const t={input:e};return Fo.runKernel(Aa,t)}});const Fd=jo({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let a;if(t<=2){const r=Al(e,[n,t]);a=_d(r)}else{const r=[n,2*(t-1)],s=Al(cd(e),[n,t]),o=Al($u(e),[n,t]),i=dd(Pl(s,[0,1],[n,t-2]),1),c=Ml(dd(Pl(o,[0,1],[n,t-2]),1),el(-1)),l=Ol([s,i],1),u=Ol([o,c],1),h=Al(Ho(l,u),[r[0],r[1]]);a=_d(h)}if(a=cd(a),3===e.rank&&0!==e.shape[0]){const t=a,n=e.shape[0];a=Al(a,[n,a.shape[0]/n,a.shape[1]]),t.dispose()}return a}});const Od=jo({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a={x:Uo(e,"x","split")},r={numOrSizeSplits:t,axis:n};return Fo.runKernel(Kr,a,r)}});const Dd=jo({rfft_:function(e,t){Et("float32"===e.dtype,(()=>"The dtype for rfft() must be real value but got ".concat(e.dtype)));let n=e.shape[e.shape.length-1];const a=e.size/n;let r;if(null!=t&&t<n){const a=e.shape.map((e=>0)),s=e.shape.map((e=>e));s[e.shape.length-1]=t,r=Pl(e,a,s),n=t}else if(null!=t&&t>n){const a=e.shape.map((e=>e));a[e.shape.length-1]=t-n,r=Ol([e,Eh(a)],e.shape.length-1),n=t}else r=e;const s=wu(r),o=Al(Ho(r,s),[a,n]),i=Ad(o),c=Math.floor(n/2)+1,l=cd(i),u=$u(i),h=Od(l,[c,n-c],l.shape.length-1),d=Od(u,[c,n-c],u.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=c,Al(Ho(h[0],d[0]),p)}});const Md=jo({squaredDifference_:function(e,t){let n=Uo(e,"a","squaredDifference"),a=Uo(t,"b","squaredDifference");[n,a]=Io(n,a),vc(n.shape,a.shape);const r={a:n,b:a};return Fo.runKernel($r,r,{})}});const Ld=jo({squeeze_:function(e,t){const n=Uo(e,"x","squeeze","string_or_numeric");return Al(n,Wt(n.shape,t).newShape)}});const Pd=jo({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Vo(e,"tensors","stack","string_or_numeric");Et(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&Et(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const a=n,r={axis:t};return Fo.runKernel(pr,a,r)}});const zd=jo({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Uo(e,"x","step")},a={alpha:t};return Fo.runKernel(gs,n,a)}});const Bd=jo({stridedSlice_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,c=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const l={x:Uo(e,"x","stridedSlice","string_or_numeric")},u={begin:t,end:n,strides:a,beginMask:r,endMask:s,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:c};return Fo.runKernel(ts,l,u)}});const Wd=jo({tan_:function(e){const t={x:Uo(e,"x","tan","float32")};return Fo.runKernel(os,t)}});function Ud(e,t){At(e);const n=zo(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Ko(e,null,n,t)}function Vd(e,t,n){if(At(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const a=zo(e,n);if(2!==a.length&&1!==a.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Ko(e,t,a,n)}function Gd(e,t,n){if(At(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const a=zo(e,n);if(4!==a.length&&1!==a.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Ko(e,t,a,n)}function jd(e,t,n){if(At(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const a=zo(e,n);if(5!==a.length&&1!==a.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Ko(e,t,a,n)}function Hd(e,t,n){if(At(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const a=zo(e,n);if(6!==a.length&&1!==a.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return Ko(e,t=t||a,a,n)}const Kd=jo({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const a=Uo(e,"x","topk");if(0===a.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const r=a.shape[a.shape.length-1];if(t<0)throw new Error("'k' passed to topk() must be >= 0 but got ".concat(t));if(t>r)throw new Error("'k' passed to topk() must be <= the last dimension (".concat(r,") ")+"but got ".concat(t));const s={x:a},o={k:t,sorted:n},[i,c]=Fo.runKernel(ls,s,o);return{values:i,indices:c}}});const qd=jo({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(null!=a&&"bool"===a)throw new Error("Unsupported data type $ { dtype }");const s=new ed(t,n,a,!0,r),o=qi(e,a);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});const Xd=jo({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Uo(e,"x","unique","string_or_numeric");Et(n.rank>0,(()=>"The input tensor must be at least 1D"));const a={x:n},r={axis:t},[s,o]=Fo.runKernel(ds,a,r);return{values:s,indices:o}}});const Yd=jo({unsortedSegmentSum_:function(e,t,n){const a=Uo(e,"x","unsortedSegmentSum"),r=Uo(t,"segmentIds","unsortedSegmentSum","int32");Et(Dt(n),(()=>"numSegments must be of dtype int"));const s={x:a,segmentIds:r},o={numSegments:n};return Fo.runKernel(fs,s,o)}});const Zd=jo({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Uo(e,"x","unstack","string_or_numeric");Et(t>=-n.shape.length&&t<n.shape.length,(()=>"Axis = ".concat(t," is not in [-").concat(n.shape.length,", ").concat(n.shape.length,")")));const a={value:n},r={axis:t};return Fo.runKernel(ps,a,r)}});function Qd(e,t){return wh(e,t,"right")}function Jd(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return Fo.makeVariable(e,t,n,a)}function $d(e,t){const n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);const a=qi(e,"int32"),r=qi([n.length,e.length],"int32");for(let s=0;s<n.length;s++){const t=a.indexToLoc(n[s]),o=s*e.length;r.values.set(t,o)}return r.toTensor()}const ep=async function(e){const t=Uo(e,"condition","whereAsync","bool"),n=await t.data(),a=$d(t.shape,n);return e!==t&&t.dispose(),a};const tp=async function(e,t,n){const a=Uo(e,"tensor","boolMask"),r=Uo(t,"mask","boolMask","bool"),s=null==n?0:n,o=r.rank,i=a.shape;Et(o>0,(()=>"mask cannot be scalar")),Rt(i.slice(s,s+o),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let c=1;for(let m=s;m<s+o;m++)c*=i[m];const l=i.slice(0,s).concat([c],i.slice(s+o)),u=Al(a,l),h=Al(r,[-1]),d=await ep(h),p=Ld(d,[1]),f=Zu(u,p,s);return e!==a&&a.dispose(),t!==r&&r.dispose(),p.dispose(),u.dispose(),h.dispose(),d.dispose(),f};const np=jo({transpose_:function(e,t,n){const a=Uo(e,"x","transpose");if(null==t&&(t=a.shape.map(((e,t)=>t)).reverse()),Et(a.rank===t.length,(()=>"Error in transpose: rank of input ".concat(a.rank," ")+"must match length of perm ".concat(t,"."))),t.forEach((e=>{Et(e>=0&&e<a.rank,(()=>"All entries in 'perm' must be between 0 and ".concat(a.rank-1)+" but got ".concat(t)))})),a.rank<=1)return a.clone();const r={x:a},s={perm:t};return"complex64"===a.dtype?Xc((()=>{let e=cd(a),t=$u(a);return e=Fo.runKernel(hs,{x:e},s),t=Fo.runKernel(hs,{x:t},s),n&&(t=uh(t)),Ho(e,t)})):Fo.runKernel(hs,r,s)}});const ap=jo({movingAverage_:function(e,t,n,a){let r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];const s=Uo(e,"v","movingAverage"),o=Uo(t,"x","movingAverage"),i=Uo(n,"decay","movingAverage");var c,l;l=o,Et((c=s).dtype===l.dtype,(()=>"The dtypes of the first(".concat(c.dtype,") and")+" second(".concat(l.dtype,") input must match"))),Et(Ot(s.shape,o.shape),(()=>"Shape mismatch in v and x"));const u=el(1),h=ph(u,i);let d=Ml(ph(o,s),h);if(r){Et(null!=a,(()=>"When using zeroDebias: true, step is required."));const e=Uo(a,"step","movingAverage");d=bu(d,ph(u,Pu(i,e)))}return sl(s,d)}});function rp(e,t,n){const a=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,s="Must have updates.shape = indices.shape[:batchDim] + "+"shape[sliceDim:], got updates.shape: ".concat(n.shape)+", indices.shape: ".concat(t.shape,", shape: ").concat(e)+", sliceDim: ".concat(a,", and batchDim: ").concat(r,".");if(n.rank<r)throw new Error(s+" update.rank < ".concat(r,". "));if(e.length<a+(n.rank-r))throw new Error(s+" Output shape length < ".concat(a+(n.rank-r)));if(n.rank!==r+e.length-a)throw new Error(s+" update.rank != ".concat(r+e.length-a));for(let o=0;o<r;++o)if(n.shape[o]!==t.shape[o])throw new Error(s+" updates.shape[".concat(o,"] (").concat(n.shape[o],") != indices.shape[").concat(o,"] (").concat(t.shape[o],")."));for(let o=0;o<n.rank-r;++o)if(n.shape[o+r]!==e[o+a])throw new Error(s+" updates.shape[".concat(o+r,"] (").concat(n.shape[o+r],") != shape[").concat(o+r,"] (").concat(e[o+r],")"))}function sp(e,t,n){if(t.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(t.rank,"."));if(e.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher,"+" but the rank was ".concat(e.rank,"."));if("int32"!==t.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: ".concat(t.dtype));if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: ".concat(n));if(0===n.length){if(0===t.size)throw new Error("Indices specified for empty output. indices shape: ".concat(t.shape));if(0===e.size)throw new Error("Updates specified for empty output. updates shape: ".concat(e.shape))}rp(n,t,e)}function op(e,t,n){const a=t.shape.length,r=a>1?t.shape[a-1]:1,s=n.length;let o=1;for(let c=r;c<s;++c)o*=n[c];const i=r<1?1:r;return{sliceRank:r,numUpdates:Ft(t.shape)/i,sliceSize:o,strides:[...Qt(n.slice(0,r)),1],outputSize:Ft(n)}}const ip=jo({scatterND_:function(e,t,n){const a=Uo(e,"indices","scatterND","int32"),r=Uo(t,"updates","scatterND");sp(r,a,n);const s={indices:a,updates:r},o={shape:n};return Fo.runKernel(Or,s,o)}});const cp=jo({sparseToDense_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const r=Uo(e,"sparseIndices","sparseToDense","int32"),s=Uo(t,"sparseValues","sparseToDense","string_or_numeric"),o=Uo(a,"defaultValue","sparseToDense",s.dtype);!function(e,t,n,a){if("int32"!==e.dtype)throw new Error("tf.sparseToDense() expects the indices to be int32 type,"+" but the dtype was ".concat(e.dtype,"."));if(e.rank>2)throw new Error("sparseIndices should be a scalar, vector, or matrix,"+" but got shape ".concat(e.shape,"."));const r=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error("outputShape has incorrect number of elements:,"+" ".concat(n.length,", should be: ").concat(s,"."));const o=t.size;if(0!==t.rank&&(1!==t.rank||o!==r))throw new Error("sparseValues has incorrect shape "+"".concat(t.shape,", should be [] or [").concat(r,"]"));if(t.dtype!==a.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(r,s,n,o);const i={sparseIndices:r,sparseValues:s,defaultValue:o},c={outputShape:n};return Fo.runKernel(Jr,i,c)}});const lp=jo({gatherND_:function(e,t){const n=Uo(t,"indices","gatherND","int32"),a={params:Uo(e,"x","gatherND","string_or_numeric"),indices:n};return Fo.runKernel(Ca,a)}});const up=jo({dropout_:function(e,t,n,a){const r=Uo(e,"x","dropout");if(Et("float32"===r.dtype,(()=>"x has to be a floating point tensor since it's going to be "+"scaled, but got a ".concat(r.dtype," tensor instead."))),Et(t>=0&&t<1,(()=>"rate must be a float in the range [0, 1), but got ".concat(t,"."))),0===t)return e instanceof po?r.clone():r;const s=function(e,t){if(null==t)return e.shape.slice();if(Ot(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let a=0;a<e.shape.length;a++)null==t[a]&&null!=e.shape[a]?n.push(e.shape[a]):n.push(t[a]);return n}return t}(r,n),o=1-t,i=bu(Yu(sl(od(s,0,1,"float32",a),o)),o);return Ml(r,i)}});function hp(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function dp(e,t,n){const a=1-e%2,r=new Float32Array(e);for(let s=0;s<e;++s){const o=2*Math.PI*s/(e+a-1);r[s]=t-n*Math.cos(o)}return Ud(r,"float32")}const pp=async function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;const a=Uo(e,"predictions","inTopK"),r=Uo(t,"targets","inTopK");Et(a.rank>1,(()=>"inTopK() expects the predictions to be of rank 2 or higher, "+"but got ".concat(a.rank))),Et(a.rank-1===r.rank,(()=>"predictions rank should be 1 larger than targets rank, but got predictions rank "+"".concat(a.rank," and targets rank ").concat(r.rank))),Rt(a.shape.slice(0,a.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const s=a.shape[a.shape.length-1];Et(n>0&&n<=s,(()=>"'k' passed to inTopK() must be > 0 && <= the predictions last "+"dimension (".concat(s,"), but got ").concat(n)));const o=await a.data(),i=await r.data(),[c,l]=[o.length/s,s],u=Ut("bool",c);for(let h=0;h<c;h++){const e=h*l,t=o.subarray(e,e+l),a=[];for(let n=0;n<t.length;n++)a.push({value:t[n],index:n});a.sort(((e,t)=>t.value-e.value)),u[h]=0;for(let r=0;r<n;r++)if(a[r].index===i[h]){u[h]=1;break}}return e!==a&&a.dispose(),t!==r&&r.dispose(),qo(u,r.shape,"bool")};const fp=jo({conv2DBackpropFilter_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",o=arguments.length>6?arguments[6]:void 0,i=e;3===e.rank&&(i=Al(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=Al(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Et(4===i.rank,(()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+"".concat(i.shape,"."))),Et(4===c.rank,(()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+"".concat(c.shape,"."))),Et(4===n.length,(()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+"".concat(n,".")));const l="NHWC"===s?i.shape[3]:i.shape[1],u="NHWC"===s?c.shape[3]:c.shape[1];Et(l===n[2],(()=>"Error in conv2dDerFilter: depth of input ".concat(l,") must ")+"match input depth in filter (".concat(n[2],"."))),Et(u===n[3],(()=>"Error in conv2dDerFilter: depth of dy (".concat(u,") must ")+"match output depth for filter (".concat(n[3],")."))),Rl("conv2dDerFilter",r,o);const h={x:i,dy:c},d={strides:a,pad:r,dataFormat:s,dimRoundingMode:o,filterShape:n};return Fo.runKernel(Hn,h,d)}});function mp(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return Ml(e,zd(t));throw new Error("Cannot compute gradient for fused activation ".concat(n,"."))}function gp(e,t){let n=t;const a=bc(e.shape,t.shape);return a.length>0&&(n=Wu(n,a)),Al(n,e.shape)}function yp(e,t,n,a){if("linear"===t)return e;if("relu"===t)return ud(e);if("elu"===t)return Nu(e);if("relu6"===t)return hd(e);if("prelu"===t)return Xh(e,n);if("leakyrelu"===t)return ah(e,a);if("sigmoid"===t)return Ll(e);throw new Error("Unknown fused activation ".concat(t,"."))}const bp=(e,t)=>!(e>0)||"linear"===t;const vp=jo({fusedConv2d_:function(e){let{x:t,filter:n,strides:a,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:c,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:h}=e;if(l=l||"linear",!1===bp(Fo.state.gradientDepth,l)){Et("NHWC"===s,(()=>"Error in fused conv2d: got dataFormat of ".concat(s," but ")+"only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear."));let e=tu(t,n,a,r,s,o,i);return null!=c&&(e=sl(e,c)),yp(e,l,u,h)}const d=Uo(t,"x","conv2d","float32"),p=Uo(n,"filter","conv2d","float32");let f=d,m=!1;3===d.rank&&(m=!0,f=Al(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Et(4===f.rank,(()=>"Error in fused conv2d: input must be rank 4, but got rank "+"".concat(f.rank,"."))),Et(4===p.rank,(()=>"Error in fused conv2d: filter must be rank 4, but got rank "+"".concat(p.rank,"."))),Rl("fused conv2d",r,i);const g="NHWC"===s?f.shape[3]:f.shape[1];Et(p.shape[2]===g,(()=>"Error in conv2d: depth of input (".concat(g,") must match ")+"input depth for filter ".concat(p.shape[2],"."))),Et(Tl(a,o),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(a," and dilations '").concat(o,"'")));const y=vl(f.shape,p.shape,a,o,r,i);let b,v;if(null!=c&&(b=Uo(c,"bias","fused conv2d"),[b]=Io(b,d),"NHWC"===s?vc(y.outShape,b.shape):(Et(b.shape.length<=1,(()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of "+"rank-".concat(b.shape.length,"."))),Et(0===b.shape.length||b.shape[0]===y.outChannels||1===b.shape[0],(()=>"Error in fused conv2d: bias shape (".concat(b.shape,") is not ")+"compatible with the number of output channels "+"(".concat(y.outChannels,")"))))),null!=u){const e=u.shape;if(Et(e.length<=1||3===e.length,(()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of "+"rank-".concat(e.length,"."))),1===e.length)Et(1===e[0]||e[0]===y.outChannels,(()=>"Error in fused conv2d: PReLU activation weights "+"(".concat(e,") is not compatible with the number of output ")+"channels (".concat(y.outChannels,").")));else if(3===e.length)try{vc(e,y.outShape)}catch(qV){const n="Error in fused conv2d: PReLU activation weights (".concat(e,") ")+"is not compatible with the output shape of the conv2d "+"(".concat(y.outShape,").");throw Error(n)}v=Uo(u,"prelu weights","fused conv2d")}const x=(e,t)=>{Et("NHWC"===s,(()=>"Error in gradient of fused conv2D: got dataFormat of ".concat(s," but only NHWC is currently supported.")));const[n,i,c,u]=t,h=mp(e,c,l);Et(Cl(o),(()=>"Error in gradient of fused conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(o,"'")));const d=[au(i.shape,h,n,a,r),fp(i,h,n.shape,a,r)];if(null!=u){const e=gp(u,h);d.push(e)}return d},w={x:f,filter:p,bias:b,preluActivationWeights:v},k={strides:a,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:h};if(null==c){const e=$c(((e,t,n)=>{let a=Fo.runKernel(xs,w,k);return n([t,e,a]),m&&(a=Al(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}}));return e(f,p)}{const e=$c(((e,t,n,a)=>{let r=Fo.runKernel(xs,w,k);return a([t,e,r,n]),m&&(r=Al(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}));return e(f,p,b)}}});const xp=jo({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0,i=e;3===e.rank&&(i=Al(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=Al(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={x:i,dy:c},u={strides:a,pad:r,dimRoundingMode:o,dilations:s,filterShape:n};return Fo.runKernel(ra,l,u)}});const wp=jo({depthwiseConv2dNativeBackpropInput_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0,i=t,c=!1;3===t.rank&&(c=!0,i=Al(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={dy:i,filter:n},u={strides:a,pad:r,dimRoundingMode:o,dilations:s,inputShape:e},h=Fo.runKernel(sa,l,u);return c?Al(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const kp=jo({fusedDepthwiseConv2d_:function(e){let{x:t,filter:n,strides:a,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:c,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:h}=e;if(!1===bp(Fo.state.gradientDepth,l)){let e=fu(t,n,a,r,s,o,i);return null!=c&&(e=sl(e,c)),yp(e,l,u,h)}const d=Uo(t,"x","depthwiseConv2d","float32"),p=Uo(n,"filter","depthwiseConv2d","float32");let f=d,m=!1;3===d.rank&&(m=!0,f=Al(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Et(4===f.rank,(()=>"Error in fused depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(f.rank,"."))),Et(4===p.rank,(()=>"Error in fused depthwiseConv2d: filter must be rank 4, "+"but got rank ".concat(p.rank,"."))),Et(f.shape[3]===p.shape[2],(()=>"Error in fused depthwiseConv2d: number of input channels "+"(".concat(f.shape[3],") must match the inChannels dimension in ")+"filter ".concat(p.shape[2],"."))),null==o&&(o=[1,1]),Et(Tl(a,o),(()=>"Error in fused depthwiseConv2d: Either strides or dilations must "+"be 1. Got strides ".concat(a," and dilations '").concat(o,"'"))),Rl("fused depthwiseConv2d",r,i);const g=vl(f.shape,p.shape,a,o,r,i,!0);let y,b;null!=c&&(y=Uo(c,"bias","fused conv2d"),[y]=Io(y,d),vc(g.outShape,y.shape)),null!=u&&(b=Uo(u,"prelu weights","fused depthwiseConv2d"));const v=(e,t)=>{Et(Cl(o),(()=>"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(o,"'")));const[n,s,c,u]=t,h=mp(e,c,l),d=wp(s.shape,h,n,a,r,o,i),p=xp(s,h,n.shape,a,r,o,i);if(null!=u){return[d,p,gp(y,h)]}return[d,p]},x={x:f,filter:p,bias:y,preluActivationWeights:b},w={strides:a,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:h};if(null==c){const e=$c(((e,t,n)=>{let a=Fo.runKernel(ws,x,w);return n([t,e,a]),m&&(a=Al(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:v}}));return e(f,p)}{const e=$c(((e,t,n,a)=>{let r=Fo.runKernel(ws,x,w);return a([t,e,r,n]),m&&(r=Al(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}));return e(f,p,y)}}});const Sp=jo({fusedMatMul_:function(e){let{a:t,b:n,transposeA:a=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:c=.2}=e;if(!1===bp(Fo.state.gradientDepth,o)){let e=Dl(t,n,a,r);return null!=s&&(e=sl(e,s)),yp(e,o,i,c)}let l=Uo(t,"a","fused matMul"),u=Uo(n,"b","fused matMul");[l,u]=Io(l,u);const h=a?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],p=a?l.shape[l.rank-1]:l.shape[l.rank-2],f=r?u.shape[u.rank-2]:u.shape[u.rank-1],m=l.shape.slice(0,-2),g=u.shape.slice(0,-2),y=Ft(m),b=Ft(g);Et(h===d,(()=>"Error in fused matMul: inner shapes (".concat(h,") and (")+"".concat(d,") of Tensors with shapes ").concat(l.shape," and ")+"".concat(u.shape," and transposeA=").concat(a)+" and transposeB=".concat(r," must match.")));const v=vc(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,f]),x=Al(l,a?[y,h,p]:[y,p,h]),w=Al(u,r?[b,f,d]:[b,d,f]);let k,S;null!=s&&(k=Uo(s,"bias","fused matMul"),[k]=Io(k,l),vc(v,k.shape)),null!=i&&(S=Uo(i,"prelu weights","fused matMul"));const I=(e,t)=>{const[n,i,c,l]=t,u=mp(Al(e,c.shape),c,o);let h,d;if(a||r?!a&&r?(h=Dl(u,i,!1,!1),d=Dl(u,n,!0,!1)):a&&!r?(h=Dl(i,u,!1,!0),d=Dl(n,u,!1,!1)):(h=Dl(i,u,!0,!0),d=Dl(u,n,!0,!0)):(h=Dl(u,i,!1,!0),d=Dl(n,u,!0,!1)),null!=s){return[h,d,gp(l,u)]}return[h,d]},N={a:x,b:w,bias:k,preluActivationWeights:S},C={transposeA:a,transposeB:r,activation:o,leakyreluAlpha:c};if(null==s){const e=$c(((e,t,n)=>{const a=Fo.runKernel(vs,N,C);return n([e,t,a]),{value:Al(a,v),gradFunc:I}}));return e(x,w)}{const e=$c(((e,t,n,a)=>{const r=Fo.runKernel(vs,N,C);return a([e,t,r,n]),{value:Al(r,v),gradFunc:I}}));return e(x,w,k)}}});const Ip=jo({hammingWindow_:function(e){return dp(e,.54,.46)}});const Np=jo({hannWindow_:function(e){return dp(e,.5,.5)}});const Cp=jo({frame_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=0;const o=[];for(;s+t<=e.size;)o.push(Pl(e,s,t)),s+=n;if(a)for(;s<e.size;){const a=s+t-e.size,i=Ol([Pl(e,s,t-a),Yl([a],r)]);o.push(i),s+=n}return 0===o.length?Vd([],[0,t]):Al(Ol(o),[o.length,t])}});const Tp=jo({stft_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Np;null==a&&(a=hp(t));const s=Cp(e,t,n),o=Ml(s,r(t));return Dd(o,a)}});const Ep=jo({cropAndResize_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=Uo(e,"image","cropAndResize"),i=Uo(t,"boxes","cropAndResize","float32"),c=Uo(n,"boxInd","cropAndResize","int32"),l=i.shape[0];Et(4===o.rank,(()=>"Error in cropAndResize: image must be rank 4,"+"but got rank ".concat(o.rank,"."))),Et(2===i.rank&&4===i.shape[1],(()=>"Error in cropAndResize: boxes must be have size [".concat(l,",4] ")+"but had shape ".concat(i.shape,"."))),Et(1===c.rank&&c.shape[0]===l,(()=>"Error in cropAndResize: boxInd must be have size [".concat(l,"] ")+"but had shape ".concat(i.shape,"."))),Et(2===a.length,(()=>"Error in cropAndResize: cropSize must be of length 2, but got "+"length ".concat(a.length,"."))),Et(a[0]>=1&&a[1]>=1,(()=>"cropSize must be atleast [1,1], but was ".concat(a))),Et("bilinear"===r||"nearest"===r,(()=>"method must be bilinear or nearest, but was ".concat(r)));const u={image:o,boxes:i,boxInd:c},h={method:r,extrapolationValue:s,cropSize:a};return Fo.runKernel(ea,u,h)}});const Rp=jo({flipLeftRight_:function(e){const t=Uo(e,"image","flipLeftRight","float32");Et(4===t.rank,(()=>"Error in flipLeftRight: image must be rank 4,"+"but got rank ".concat(t.rank,".")));const n={image:t};return Fo.runKernel(wa,n,{})}});const Ap=jo({grayscaleToRGB_:function(e){const t=Uo(e,"image","grayscaleToRGB"),n=t.rank-1,a=t.shape[n];Et(t.rank>=2,(()=>"Error in grayscaleToRGB: images must be at least rank 2, "+"but got rank ".concat(t.rank,"."))),Et(1===a,(()=>"Error in grayscaleToRGB: last dimension of a grayscale image "+"should be size 1, but got size ".concat(a,".")));const r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,qu(t,r)}});const _p=jo({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const r=Uo(e,"image","rotateWithOffset","float32");Et(4===r.rank,(()=>"Error in rotateWithOffset: image must be rank 4,"+"but got rank ".concat(r.rank,".")));const s={image:r},o={radians:t,fillValue:n,center:a};return Fo.runKernel(bs,s,o)}});function Fp(e,t,n,a,r,s){null==a&&(a=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==s&&(s=0);const o=e.shape[0];return n=Math.min(n,o),Et(0<=a&&a<=1,(()=>"iouThreshold must be in [0, 1], but was '".concat(a,"'"))),Et(2===e.rank,(()=>"boxes must be a 2D tensor, but was of rank '".concat(e.rank,"'"))),Et(4===e.shape[1],(()=>"boxes must have 4 columns, but 2nd dimension was ".concat(e.shape[1]))),Et(1===t.rank,(()=>"scores must be a 1D tensor")),Et(t.shape[0]===o,(()=>"scores has incompatible shape with boxes. Expected ".concat(o,", ")+"but was ".concat(t.shape[0]))),Et(0<=s&&s<=1,(()=>"softNmsSigma must be in [0, 1], but was '".concat(s,"'"))),{maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s}}const Op=jo({nonMaxSuppression_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=Uo(e,"boxes","nonMaxSuppression","float32"),o=Uo(t,"scores","nonMaxSuppression","float32"),i=Fp(s,o,n,a,r);n=i.maxOutputSize,a=i.iouThreshold,r=i.scoreThreshold;const c={maxOutputSize:n,iouThreshold:a,scoreThreshold:r};return Fo.runKernel(cr,{boxes:s,scores:o},c)}});function Dp(e,t,n){const a=function(e,t,n){return function(e,t,n){let a=0,r=e.length,s=0,o=!1;for(;a<r;){s=a+(r-a>>>1);const i=n(t,e[s]);i>0?a=s+1:(r=s,o=!i)}return o?a:-a-1}(e,t,n||Mp)}(e,t,n),r=a<0?-(a+1):a;e.splice(r,0,t)}function Mp(e,t){return e>t?1:e<t?-1:0}function Lp(e,t,n,a,r){return Bp(e,t,n,a,r,0)}function Pp(e,t,n,a,r,s){return Bp(e,t,n,a,r,0,!1,s,!0)}function zp(e,t,n,a,r,s){return Bp(e,t,n,a,r,s,!0)}function Bp(e,t,n,a,r,s){let o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const l=[];for(let g=0;g<t.length;g++)t[g]>r&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(Vp);const u=s>0?-.5/s:0,h=[],d=[];for(;h.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:s,suppressBeginIndex:o}=t;if(n<r)break;let i=!1;for(let c=h.length-1;c>=o;--c){const n=Wp(e,s,h[c]);if(n>=a){i=!0;break}if(t.score=t.score*Up(a,u,n),t.score<=r)break}t.suppressBeginIndex=h.length,i||(t.score===n?(h.push(s),d.push(t.score)):t.score>r&&Dp(l,t,Vp))}const p=h.length,f=n-p;i&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return o&&(m.selectedScores=d),c&&(m.validOutputs=p),m}function Wp(e,t,n){const a=e.subarray(4*t,4*t+4),r=e.subarray(4*n,4*n+4),s=Math.min(a[0],a[2]),o=Math.min(a[1],a[3]),i=Math.max(a[0],a[2]),c=Math.max(a[1],a[3]),l=Math.min(r[0],r[2]),u=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(i-s)*(c-o),f=(h-l)*(d-u);if(p<=0||f<=0)return 0;const m=Math.max(s,l),g=Math.max(o,u),y=Math.min(i,h),b=Math.min(c,d),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(p+f-v)}function Up(e,t,n){const a=Math.exp(t*n*n);return n<=e?a:0}function Vp(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const Gp=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=Uo(e,"boxes","nonMaxSuppressionAsync"),o=Uo(t,"scores","nonMaxSuppressionAsync"),i=Fp(s,o,n,a,r);n=i.maxOutputSize,a=i.iouThreshold,r=i.scoreThreshold;const c=await Promise.all([s.data(),o.data()]),l=c[0],u=c[1],{selectedIndices:h}=Lp(l,u,n,a,r);return s!==e&&s.dispose(),o!==t&&o.dispose(),Ud(h,"int32")};const jp=jo({nonMaxSuppressionWithScore_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=Uo(e,"boxes","nonMaxSuppression"),i=Uo(t,"scores","nonMaxSuppression"),c=Fp(o,i,n,a,r,s);n=c.maxOutputSize,a=c.iouThreshold,r=c.scoreThreshold,s=c.softNmsSigma;const l={boxes:o,scores:i},u={maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s},h=Fo.runKernel(ur,l,u);return{selectedIndices:h[0],selectedScores:h[1]}}});const Hp=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=Uo(e,"boxes","nonMaxSuppressionAsync"),i=Uo(t,"scores","nonMaxSuppressionAsync"),c=Fp(o,i,n,a,r,s);n=c.maxOutputSize,a=c.iouThreshold,r=c.scoreThreshold,s=c.softNmsSigma;const l=await Promise.all([o.data(),i.data()]),u=l[0],h=l[1],{selectedIndices:d,selectedScores:p}=zp(u,h,n,a,r,s);return o!==e&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:Ud(d,"int32"),selectedScores:Ud(p)}};const Kp=jo({nonMaxSuppressionPadded_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=Uo(e,"boxes","nonMaxSuppression"),i=Uo(t,"scores","nonMaxSuppression"),c=Fp(o,i,n,a,r,null),l={boxes:o,scores:i},u={maxOutputSize:c.maxOutputSize,iouThreshold:c.iouThreshold,scoreThreshold:c.scoreThreshold,padToMaxOutputSize:s},h=Fo.runKernel(lr,l,u);return{selectedIndices:h[0],validOutputs:h[1]}}});const qp=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=Uo(e,"boxes","nonMaxSuppressionAsync"),i=Uo(t,"scores","nonMaxSuppressionAsync"),c=Fp(o,i,n,a,r,null),l=c.maxOutputSize,u=c.iouThreshold,h=c.scoreThreshold,[d,p]=await Promise.all([o.data(),i.data()]),{selectedIndices:f,validOutputs:m}=Pp(d,p,l,u,h,s);return o!==e&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:Ud(f,"int32"),validOutputs:el(m,"int32")}};const Xp=jo({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Uo(e,"images","resizeBilinear");Et(3===r.rank||4===r.rank,(()=>"Error in resizeBilinear: x must be rank 3 or 4, but got "+"rank ".concat(r.rank,"."))),Et(2===t.length,(()=>"Error in resizeBilinear: new shape must 2D, but got shape "+"".concat(t,"."))),Et(!1===a||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=r,o=!1;3===r.rank&&(o=!0,s=Al(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,i={images:s},c={alignCorners:n,halfPixelCenters:a,size:t},l=Fo.runKernel(Tr,i,c);return o?Al(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const Yp=jo({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Uo(e,"images","resizeNearestNeighbor");Et(3===r.rank||4===r.rank,(()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got "+"rank ".concat(r.rank,"."))),Et(2===t.length,(()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+"".concat(t,"."))),Et("float32"===r.dtype||"int32"===r.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),Et(!1===a||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=r,o=!1;3===r.rank&&(o=!0,s=Al(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,i={images:s},c={alignCorners:n,halfPixelCenters:a,size:t},l=Fo.runKernel(Nr,i,c);return o?Al(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const Zp=jo({threshold_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const r=Uo(e,"image","threshold"),s=r.shape[0]*r.shape[1];let o,i,c,l,u=Ml(Ud([a]),255);if(Et(3===r.rank,(()=>"Error in threshold: image must be rank 3,"+"but got rank ".concat(r.rank,"."))),Et(3===r.shape[2]||1===r.shape[2],(()=>"Error in threshold: image color channel must be equal to 3 or 1"+"but got ".concat(r.shape[2],"."))),Et("int32"===r.dtype||"float32"===r.dtype,(()=>"Error in dtype: image dtype must be int32 or float32,"+"but got dtype ".concat(r.dtype,"."))),Et("otsu"===t||"binary"===t,(()=>"Method must be binary or otsu, but was ".concat(t))),3===r.shape[2]){[o,i,c]=Od(r,[1,1,1],-1);const e=Ml(o,.2989),t=Ml(i,.587),n=Ml(c,.114);l=sl(sl(e,t),n)}else l=e;if("otsu"===t){u=function(e,t){let n,a,r,s,o,i,c=Ud([-1]),l=Ud([0]),u=Ud([0]);for(let h=0;h<e.size-1;h++){n=Pl(e,0,h+1),a=Pl(e,h+1),o=bu(Wu(n),t),i=bu(Wu(a),t);const d=Wu(Ml(n,id(0,n.size)));r=bu(d,Wu(n));const p=Yl(a.shape,n.size),f=sl(id(0,a.size),p),m=Ml(a,f);s=bu(Wu(m),Wu(a));const g=ph(r,s),y=ph(r,s),b=Ml(o,i);u=Ml(Ml(b,g),y);const v=Qu(u,l);l=xu(v,u,l),c=xu(v,Ud([h]),c)}return c}(Hl(Xi(yd(l),"int32"),qo([]),256),s)}const h=n?sh(l,u):Qu(l,u);return Xi(Ml(h,255),"int32")}});const Qp=jo({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5?arguments[5]:void 0;const o=Uo(e,"image","transform","float32"),i=Uo(t,"transforms","transform","float32");Et(4===o.rank,(()=>"Error in transform: image must be rank 4,"+"but got rank ".concat(o.rank,"."))),Et(2===i.rank&&(i.shape[0]===o.shape[0]||1===i.shape[0])&&8===i.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),Et(null==s||2===s.length,(()=>"Error in transform: outputShape must be [height, width] or null, "+"but got ".concat(s,".")));const c={image:o,transforms:i},l={interpolation:n,fillMode:a,fillValue:r,outputShape:s};return Fo.runKernel(us,c,l)}});const Jp=jo({bandPart_:function(e,t,n){Et(t%1===0,(()=>"bandPart(): numLower must be an integer, got ".concat(t,"."))),Et(n%1===0,(()=>"bandPart(): numUpper must be an integer, got ".concat(n,".")));const a=Uo(e,"a","bandPart");Et(a.rank>=2,(()=>"bandPart(): Rank must be at least 2, got ".concat(a.rank,".")));const r=a.shape,[s,o]=a.shape.slice(-2);if(!(t<=s))throw new Error("bandPart(): numLower (".concat(t,")")+" must not be greater than the number of rows (".concat(s,")."));if(!(n<=o))throw new Error("bandPart(): numUpper (".concat(n,")")+" must not be greater than the number of columns (".concat(o,")."));t<0&&(t=s),n<0&&(n=o);const i=Al(id(0,s,1,"int32"),[-1,1]),c=id(0,o,1,"int32"),l=ph(i,c),u=gh(sh(l,el(+t,"int32")),Ju(l,el(-n,"int32"))),h=Eh([s,o],a.dtype);return Al(Pd(Zd(Al(a,[-1,s,o])).map((e=>xu(u,e,h)))),r)}});const $p=jo({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Et(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)Et(e[t].shape[0]===n,(()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: "+"(".concat(e[t].shape[0]," vs. ").concat(n,")")))}else t=!0,e=Od(e,e.shape[0],0).map((e=>Ld(e,[0])));Et(e.length<=e[0].shape[0],(()=>"Gram-Schmidt: Number of vectors (".concat(e.length,") exceeds ")+"number of dimensions (".concat(e[0].shape[0],").")));const n=[],a=e;for(let r=0;r<e.length;++r)n.push(Fo.tidy((()=>{let e=a[r];if(r>0)for(let t=0;t<r;++t){const a=Ml(Wu(Ml(n[t],e)),n[t]);e=ph(e,a)}return bu(e,Vu(e,"euclidean"))})));return t?Pd(n,0):n}});function ef(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return Fo.tidy((()=>{Et(2===e.shape.length,(()=>"qr2d() requires a 2D Tensor, but got a ".concat(e.shape.length,"D Tensor.")));const n=e.shape[0],a=e.shape[1];let r=Xu(n),s=Yi(e);const o=Vd([[1]],[1,1]);let i=Yi(o);const c=n>=a?a:n;for(let e=0;e<c;++e){const t=s,c=i,l=r;[i,s,r]=Fo.tidy((()=>{const t=Pl(s,[e,e],[n-e,1]),c=Vu(t),l=Pl(s,[e,e],[1,1]),u=xu(Qu(l,0),Vd([[-1]]),Vd([[1]])),h=ph(l,Ml(u,c)),d=bu(t,h);i=1===d.shape[0]?Yi(o):Ol([o,Pl(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=uh(bu(Dl(u,h),c)),f=Pl(s,[e,0],[n-e,a]),m=Ml(p,i),g=np(i);if(0===e)s=ph(f,Dl(m,Dl(g,f)));else{const t=ph(f,Dl(m,Dl(g,f)));s=Ol([Pl(s,[0,0],[e,a]),t],0)}const y=np(m),b=Pl(r,[0,e],[n,r.shape[1]-e]);if(0===e)r=ph(b,Dl(Dl(b,i),y));else{const t=ph(b,Dl(Dl(b,i),y));r=Ol([Pl(r,[0,0],[n,e]),t],1)}return[i,s,r]})),Yc([t,c,l])}return!t&&n>a&&(r=Pl(r,[0,0],[n,a]),s=Pl(s,[0,0],[a,a])),[r,s]}))}const tf=jo({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(Et(e.rank>=2,(()=>"qr() requires input tensor to have a rank >= 2, but got rank ".concat(e.rank))),2===e.rank)return ef(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),a=Zd(Al(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],s=[];a.forEach((e=>{const[n,a]=ef(e,t);r.push(n),s.push(a)}));return[Al(Pd(r,0),e.shape),Al(Pd(s,0),e.shape)]}}});var nf;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(nf||(nf={}));const af=jo({computeWeightedLoss_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:nf.SUM_BY_NONZERO_WEIGHTS;const a=Uo(e,"losses","computeWeightedLoss");let r=null;null!=t&&(r=Uo(t,"weights","computeWeightedLoss"));const s=null==r?a:Ml(a,r);if(n===nf.NONE)return s;if(n===nf.SUM)return Wu(s);if(n===nf.MEAN){if(null==r)return Th(s);{const e=a.size/r.size,t=bu(Wu(s),Wu(r));return e>1?bu(t,el(e)):t}}if(n===nf.SUM_BY_NONZERO_WEIGHTS){if(null==r)return bu(Wu(s),el(a.size));{const e=Ml(r,Rh(a.shape)),t=Xi(Wu(Ph(e,el(0))),"float32");return bu(Wu(s),t)}}throw Error("Unknown reduction: ".concat(n))}});const rf=jo({absoluteDifference_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:nf.SUM_BY_NONZERO_WEIGHTS;const r=Uo(e,"labels","absoluteDifference"),s=Uo(t,"predictions","absoluteDifference");let o=null;null!=n&&(o=Uo(n,"weights","absoluteDifference")),Rt(r.shape,s.shape,"Error in absoluteDifference: ");const i=nl(ph(r,s));return af(i,o,a)}});const sf=jo({cosineDistance_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:nf.SUM_BY_NONZERO_WEIGHTS;const s=Uo(e,"labels","cosineDistance"),o=Uo(t,"predictions","cosineDistance");let i=null;null!=a&&(i=Uo(a,"weights","cosineDistance")),Rt(s.shape,o.shape,"Error in cosineDistance: ");const c=el(1),l=ph(c,Wu(Ml(s,o),n,!0));return af(l,i,r)}});const of=jo({hingeLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:nf.SUM_BY_NONZERO_WEIGHTS,r=Uo(e,"labels","hingeLoss");const s=Uo(t,"predictions","hingeLoss");let o=null;null!=n&&(o=Uo(n,"weights","hingeLoss")),Rt(r.shape,s.shape,"Error in hingeLoss: ");const i=el(1);r=ph(Ml(el(2),r),i);const c=ud(ph(i,Ml(r,s)));return af(c,o,a)}});const cf=jo({huberLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:nf.SUM_BY_NONZERO_WEIGHTS;const s=Uo(e,"labels","huberLoss"),o=Uo(t,"predictions","huberLoss");let i=null;null!=n&&(i=Uo(n,"weights","huberLoss")),Rt(s.shape,o.shape,"Error in huberLoss: ");const c=el(a),l=nl(ph(o,s)),u=_h(l,c),h=ph(l,u),d=sl(Ml(el(.5),Bu(u)),Ml(c,h));return af(d,i,r)}});const lf=jo({logLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-7,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:nf.SUM_BY_NONZERO_WEIGHTS;const s=Uo(e,"labels","logLoss"),o=Uo(t,"predictions","logLoss");let i=null;null!=n&&(i=Uo(n,"weights","logLoss")),Rt(s.shape,o.shape,"Error in logLoss: ");const c=el(1),l=el(a),u=uh(Ml(s,ch(sl(o,l)))),h=Ml(ph(c,s),ch(sl(ph(c,o),l))),d=ph(u,h);return af(d,i,r)}});const uf=jo({meanSquaredError_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:nf.SUM_BY_NONZERO_WEIGHTS;const r=Uo(e,"labels","meanSquaredError"),s=Uo(t,"predictions","meanSquaredError");let o=null;null!=n&&(o=Uo(n,"weights","meanSquaredError")),Rt(r.shape,s.shape,"Error in meanSquaredError: ");const i=Md(r,s);return af(i,o,a)}});const hf=jo({sigmoidCrossEntropy_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:nf.SUM_BY_NONZERO_WEIGHTS,s=Uo(e,"multiClassLabels","sigmoidCrossEntropy");const o=Uo(t,"logits","sigmoidCrossEntropy");let i=null;if(null!=n&&(i=Uo(n,"weights","sigmoidCrossEntropy")),Rt(s.shape,o.shape,"Error in sigmoidCrossEntropy: "),a>0){const e=el(a),t=el(1),n=el(.5);s=sl(Ml(s,ph(t,e)),Ml(n,e))}const c=function(e,t){const n=Uo(e,"labels","sigmoidCrossEntropyWithLogits"),a=Uo(t,"logits","sigmoidCrossEntropyWithLogits");Rt(n.shape,a.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=ud(a),s=Ml(a,n),o=lh(ju(uh(nl(a))));return sl(ph(r,s),o)}(s,o);return af(c,i,r)}});const df=jo({softmaxCrossEntropy_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:nf.SUM_BY_NONZERO_WEIGHTS,s=Uo(e,"onehotLabels","softmaxCrossEntropy");const o=Uo(t,"logits","softmaxCrossEntropy");let i=null;if(null!=n&&(i=Uo(n,"weights","softmaxCrossEntropy")),Rt(s.shape,o.shape,"Error in softmaxCrossEntropy: "),a>0){const e=el(a),t=el(1),n=el(s.shape[1]);s=sl(Ml(s,ph(t,e)),bu(e,n))}const c=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet "+"supported. Labels / logits was rank ".concat(t.rank," ")+"and dim was ".concat(n));const a=$c(((e,t,a)=>{const r=mh(t,[n],!0),s=ph(Xi(t,"float32"),r);a([e,s]);const o=uh(Ml(s,e));return{value:Wu(o,[n]),gradFunc:(e,t)=>{const[a,r]=t,s=Au(e.shape,[n]);return[Ml(Al(e,s),ph(Xi(a,"float32"),ju(r))),Ml(Al(e,s),ph(ju(r),Xi(a,"float32")))]}}}));return a(e,t)}(s,o);return af(c,i,r)}});const pf=jo({sparseFillEmptyRows_:function(e,t,n,a){const r=Uo(e,"indices","sparseFillEmptyRows","int32"),s=Uo(t,"values","sparseFillEmptyRows"),o=Uo(n,"denseShape","sparseFillEmptyRows","int32"),i=Uo(a,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==r.rank)throw new Error("Indices should be Tensor2D but received shape\n        ".concat(r.shape));if(1!==s.rank)throw new Error("Values should be Tensor1D but received shape ".concat(s.shape));if(1!==o.rank)throw new Error("Dense shape should be Tensor1D but received shape ".concat(o.shape));if(0!==i.rank)throw new Error("Default value should be a scalar but received shape ".concat(i.shape));const c={indices:r,values:s,denseShape:o,defaultValue:i},l=Fo.runKernel(Xr,c);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}});const ff=jo({sparseReshape_:function(e,t,n){const a=Uo(e,"inputIndices","sparseReshape","int32"),r=Uo(t,"inputShape","sparseReshape","int32"),s=Uo(n,"newShape","sparseReshape","int32");if(2!==a.rank)throw new Error("Input indices should be Tensor2D but received shape\n        ".concat(a.shape));if(1!==r.rank)throw new Error("Input shape should be Tensor1D but received shape ".concat(r.shape));if(1!==s.rank)throw new Error("New shape should be Tensor1D but received shape ".concat(s.shape));const o={inputIndices:a,inputShape:r,newShape:s},i=Fo.runKernel(Yr,o);return{outputIndices:i[0],outputShape:i[1]}}});const mf=jo({sparseSegmentMean_:function(e,t,n){const a=Uo(e,"data","sparseSegmentMean"),r=Uo(t,"indices","sparseSegmentMean","int32"),s=Uo(n,"segmentIds","sparseSegmentMean","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error("Indices should be Tensor1D but received shape\n          ".concat(r.shape));if(1!==s.rank)throw new Error("Segment ids should be Tensor1D but received shape\n          ".concat(s.shape));const o={data:a,indices:r,segmentIds:s};return Fo.runKernel(Zr,o)}});const gf=jo({sparseSegmentSum_:function(e,t,n){const a=Uo(e,"data","sparseSegmentSum"),r=Uo(t,"indices","sparseSegmentSum","int32"),s=Uo(n,"segmentIds","sparseSegmentSum","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error("Indices should be Tensor1D but received shape\n         ".concat(r.shape));if(1!==s.rank)throw new Error("Segment ids should be Tensor1D but received shape\n         ".concat(s.shape));const o={data:a,indices:r,segmentIds:s};return Fo.runKernel(Qr,o)}});const yf=jo({stringNGrams_:function(e,t,n,a,r,s,o,i){const c=Uo(e,"data","stringNGrams","string");if("string"!==c.dtype)throw new Error("Data must be of datatype string");if(1!==c.shape.length)throw new Error("Data must be a vector, saw: ".concat(c.shape));const l=Uo(t,"dataSplits","stringNGrams");if("int32"!==l.dtype)throw new Error("Data splits must be of datatype int32");const u={separator:n,nGramWidths:a,leftPad:r,rightPad:s,padWidth:o,preserveShortSequences:i},h={data:c,dataSplits:l},d=Fo.runKernel(ns,h,u);return{nGrams:d[0],nGramsSplits:d[1]}}});const bf=jo({stringSplit_:function(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const a=Uo(e,"input","stringSplit","string"),r=Uo(t,"delimiter","stringSplit","string");if(1!==a.rank)throw new Error("Input should be Tensor1D but received shape ".concat(a.shape));if(0!==r.rank)throw new Error("Delimiter should be a scalar but received shape ".concat(r.shape));const s={skipEmpty:n},o={input:a,delimiter:r},i=Fo.runKernel(as,o,s);return{indices:i[0],values:i[1],shape:i[2]}}});const vf=jo({stringToHashBucketFast_:function(e,t){const n=Uo(e,"input","stringToHashBucketFast","string"),a={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const r={input:n};return Fo.runKernel(rs,r,a)}}),xf={fft:Ad,ifft:_d,rfft:Dd,irfft:Fd},wf={hammingWindow:Ip,hannWindow:Np,frame:Cp,stft:Tp},kf={flipLeftRight:Rp,grayscaleToRGB:Ap,resizeNearestNeighbor:Yp,resizeBilinear:Xp,rotateWithOffset:_p,cropAndResize:Ep,nonMaxSuppression:Op,nonMaxSuppressionAsync:Gp,nonMaxSuppressionWithScore:jp,nonMaxSuppressionWithScoreAsync:Hp,nonMaxSuppressionPadded:Kp,nonMaxSuppressionPaddedAsync:qp,threshold:Zp,transform:Qp},Sf={bandPart:Jp,gramSchmidt:$p,qr:tf},If={absoluteDifference:rf,computeWeightedLoss:af,cosineDistance:sf,hingeLoss:of,huberLoss:cf,logLoss:lf,meanSquaredError:uf,sigmoidCrossEntropy:hf,softmaxCrossEntropy:df},Nf={sparseFillEmptyRows:pf,sparseReshape:ff,sparseSegmentMean:mf,sparseSegmentSum:gf},Cf={stringNGrams:yf,stringSplit:bf,stringToHashBucketFast:vf};class Tf extends tl{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Fo.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=Fo.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:"".concat(t,"/accum_grad"),variable:Xc((()=>wu(a).variable(false)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:"".concat(t,"/accum_var"),variable:Xc((()=>wu(a).variable(false)))});const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;Xc((()=>{const e=sl(Ml(s,this.rho),Ml(Bu(r),1-this.rho)),t=Ml(bu(zu(sl(o,this.epsilon)),zu(sl(s,this.epsilon))),r),n=sl(Ml(o,this.rho),Ml(Bu(t),1-this.rho));s.assign(e),o.assign(n);const i=sl(Ml(t,-this.learningRate),a);a.assign(i)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Yc(this.accumulatedGrads.map((e=>e.variable))),Yc(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}Tf.className="Adadelta",Hc(Tf);class Ef extends tl{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=Fo.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:"".concat(t,"/accumulator"),variable:Xc((()=>Yl(a.shape,this.initialAccumulatorValue).variable(e)))}}const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=this.accumulatedGrads[n].variable;Xc((()=>{const e=sl(s,Bu(r));s.assign(e);const t=sl(Ml(bu(r,zu(sl(e,Fo.backend.epsilon()))),-this.learningRate),a);a.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Yc(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}Ef.className="Adagrad",Hc(Ef);class Rf extends tl{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Xc((()=>{this.accBeta1=el(t).variable(),this.accBeta2=el(n).variable()})),null==a&&(this.epsilon=Fo.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Xc((()=>{const n=ph(1,this.accBeta1),a=ph(1,this.accBeta2);t.forEach(((t,r)=>{const s=Fo.registeredVariables[t];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:"".concat(t,"/m"),variable:Xc((()=>wu(s).variable(false)))}),null==this.accumulatedSecondMoment[r]&&(this.accumulatedSecondMoment[r]={originalName:"".concat(t,"/v"),variable:Xc((()=>wu(s).variable(false)))});const o=Array.isArray(e)?e[r].tensor:e[t];if(null==o)return;const i=this.accumulatedFirstMoment[r].variable,c=this.accumulatedSecondMoment[r].variable,l=sl(Ml(i,this.beta1),Ml(o,1-this.beta1)),u=sl(Ml(c,this.beta2),Ml(Bu(o),1-this.beta2)),h=bu(l,n),d=bu(u,a);i.assign(l),c.assign(u);const p=sl(Ml(bu(h,sl(zu(d),this.epsilon)),-this.learningRate),s);s.assign(p)})),this.accBeta1.assign(Ml(this.accBeta1,this.beta1)),this.accBeta2.assign(Ml(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Yc(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&Yc(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),Xc((()=>{this.accBeta1.assign(Pu(this.beta1,this.iterations_+1)),this.accBeta2.assign(Pu(this.beta2,this.iterations_+1))}));const t=e.length/2;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}Rf.className="Adam",Hc(Rf);class Af extends tl{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Xc((()=>{this.iteration=el(0).variable(),this.accBeta1=el(t).variable()})),null==a&&(this.epsilon=Fo.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Xc((()=>{const n=ph(1,this.accBeta1),a=bu(-this.learningRate,sl(Ml(this.iteration,this.decay),1));t.forEach(((t,r)=>{const s=Fo.registeredVariables[t];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:"".concat(t,"/m"),variable:wu(s).variable(false)}),null==this.accumulatedWeightedInfNorm[r]&&(this.accumulatedWeightedInfNorm[r]={originalName:"".concat(t,"/v"),variable:wu(s).variable(false)});const o=Array.isArray(e)?e[r].tensor:e[t];if(null==o)return;const i=this.accumulatedFirstMoment[r].variable,c=this.accumulatedWeightedInfNorm[r].variable,l=sl(Ml(i,this.beta1),Ml(o,1-this.beta1)),u=Ml(c,this.beta2),h=nl(o),d=Ch(u,h);i.assign(l),c.assign(d);const p=sl(Ml(bu(a,n),bu(l,sl(d,this.epsilon))),s);s.assign(p)})),this.iteration.assign(sl(this.iteration,1)),this.accBeta1.assign(Ml(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Yc(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&Yc(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}Af.className="Adamax",Hc(Af);class _f extends tl{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const r=Fo.registeredVariables[t];Xc((()=>{const e=sl(Ml(this.c,a),r);r.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=Zc(el(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}_f.className="SGD",Hc(_f);class Ff extends _f{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=el(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=Fo.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:"".concat(t,"/momentum"),variable:Xc((()=>wu(a).variable(e)))}}const r=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];null!=s&&Xc((()=>{let e;const t=sl(Ml(this.m,r),s);e=this.useNesterov?sl(Ml(this.c,sl(s,Ml(t,this.m))),a):sl(Ml(this.c,t),a),r.assign(t),a.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Yc(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}Ff.className="Momentum",Hc(Ff);class Of extends tl{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,null==a&&(this.epsilon=Fo.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=Fo.registeredVariables[t],r=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:"".concat(t,"/rms"),variable:Xc((()=>wu(a).variable(r)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:"".concat(t,"/momentum"),variable:Xc((()=>wu(a).variable(r)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:"".concat(t,"/mg"),variable:Xc((()=>wu(a).variable(r)))});const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const o=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;Xc((()=>{const e=sl(Ml(o,this.decay),Ml(Bu(s),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,r=sl(Ml(t,this.decay),Ml(s,1-this.decay)),c=bu(Ml(s,this.learningRate),zu(ph(e,sl(Bu(r),this.epsilon)))),l=sl(Ml(i,this.momentum),c);o.assign(e),t.assign(r),i.assign(l);const u=ph(a,l);a.assign(u)}else{const e=sl(Ml(o,this.decay),Ml(Bu(s),1-this.decay)),t=sl(Ml(i,this.momentum),bu(Ml(s,this.learningRate),zu(sl(e,this.epsilon))));o.assign(e),i.assign(t);const n=ph(a,t);a.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Yc(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&Yc(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&Yc(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}Of.className="RMSProp",Hc(Of);class Df{static sgd(e){return new _f(e)}static momentum(e,t){return new Ff(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new Of(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new Rf(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new Tf(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new Af(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new Ef(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}}const Mf={sgd:Df.sgd,momentum:Df.momentum,adadelta:Df.adadelta,adagrad:Df.adagrad,rmsprop:Df.rmsprop,adamax:Df.adamax,adam:Df.adam},Lf="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:e=>e();function Pf(){return new Promise((e=>Lf((()=>e()))))}function zf(e,t){const n=e[0].length;e.forEach(((e,t)=>{Et(e.length===n,(()=>"Error in concat".concat(n,"D: rank of tensors[").concat(t,"] must be the same ")+"as the rank of the rest (".concat(n,")")))})),Et(t>=0&&t<n,(()=>"Error in concat".concat(n,"D: axis must be between 0 and ").concat(n-1,".")));const a=e[0];e.forEach(((e,r)=>{for(let s=0;s<n;s++)Et(s===t||e[s]===a[s],(()=>"Error in concat".concat(n,"D: Shape of tensors[").concat(r,"] (").concat(e,") ")+"does not match the shape of the rest (".concat(a,") ")+"along the non-concatenated axis ".concat(r,".")))}))}function Bf(e,t){const n=e[0].slice();for(let a=1;a<e.length;a++)n[t]+=e[a][t];return n}var Wf;function Uf(e,t,n){let a=new Array;if(null==n&&null==t)return a;if(null==t)for(;a.length<e+n.length;)a.push(-1);else a=t.slice();if(null==n)return a;if(e+n.length!==a.length)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.rank = ").concat(e+n.length,", but shape.rank = ").concat(a.length));for(let r=1;r<n.length;++r){const s=n[r],o=a[a.length-n.length+r],i=a[o];if(s>=0)if(i>=0){if(i!==s)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.shape[").concat(r+e,"] = ").concat(s," but shape[").concat(r+e,"] = ").concat(i))}else a[o]=s}return a}function Vf(e){const t={FIRST_DIM_SIZE:Wf.FIRST_DIM_SIZE,VALUE_ROWIDS:Wf.VALUE_ROWIDS,ROW_LENGTHS:Wf.ROW_LENGTHS,ROW_SPLITS:Wf.ROW_SPLITS,ROW_LIMITS:Wf.ROW_LIMITS,ROW_STARTS:Wf.ROW_STARTS},n=[];for(const a of e){if(!(a in t))break;n.push(t[a])}return n}function Gf(e){return 0===e.length?0:e[0]===Wf.FIRST_DIM_SIZE?e.length-1:e.length}function jf(e,t){if(null==e||null==t)return;const n=e.length,a=t.length;if(n>=a)throw new Error("defaultValue.shape=".concat(e," and ragged tensor flatValues.shape=").concat(t,", are incompatible: defaultValue.rank = ").concat(n," must be less than ragged tensor input flatValues.rank = ").concat(a,")"));for(let r=0;r<Math.min(n,a-1);++r){const n=e[r],a=t[r+1];if(n>=0&&a>=0&&1!==n&&n!==a)throw new Error("defaultValue.shape=".concat(e,", and ragged tensor input flatValues.shape=").concat(t," are incompatible: defaultValue.shape[").concat(r-e.length,"] = ").concat(n," but ragged tensor input.flatValues.shape[").concat(r-e.length,"] = ").concat(a))}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(Wf||(Wf={}));const Hf=30;function Kf(e){return e<=Hf?e:Zt(e,Math.floor(Math.sqrt(e)))}function qf(e,t,n){return[n*("number"===typeof e?e:e[0]),t*("number"===typeof e?e:e[1])]}function Xf(e,t,n){let a=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)a=a.concat([e[r+1]/t[r],t[r]]);a=a.concat(e.slice(n+1))}return a}function Yf(e,t){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let a=t+1;a<e;++a)a<=2*t?(n.push(a),n.push(a-(t+1))):n.push(a)}else{const a=[],r=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?r.push(n):a.push(n);n.push(...a),n.push(0),n.push(...r)}return n}function Zf(e,t,n){let a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const r=[];a?r.push(e[0]/n):r.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?a?r.push(t[s-1]*e[s]):r.push(e[s]/t[s-1]):r.push(e[s]);return r}function Qf(e,t){const n=[0];for(let a=0;a<t;++a)n.push(e[a][0]);return n}function Jf(e,t,n){const a=e.slice(0,1);for(let r=0;r<n;++r)a.push(e[r+1]-t[r][0]-t[r][1]);return a}function $f(e,t){const n=e.shape.length,a=t.shape.length;if(n<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher,"+" but the rank was ".concat(n,"."));if(a<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(a,"."));if("int32"!==t.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type,"+" but the dtype was ".concat(t.dtype,"."));if(t.shape[a-1]>n)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+"".concat(t.shape[a-1]," vs. ").concat(n));if(0===Ft(e.shape))throw new Error("Requested more than 0 entries, but input is empty."+" Input shape: ".concat(e.shape,"."));const r=t.shape,s=r[r.length-1];let o=1;for(let h=0;h<r.length-1;++h)o*=r[h];const i=e.shape,c=r.slice();c.pop();let l=1;for(let h=s;h<n;++h)l*=i[h],c.push(i[h]);const u=[...Qt(e.shape).map((e=>e/l)),1].slice(0,s);return[c,o,l,u]}const em=1.7580993408473768,tm=1.0507009873554805,nm=.3275911,am=.254829592,rm=-.284496736,sm=1.421413741,om=-1.453152027,im=1.061405429;function cm(e,t){if(e.length!==t.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+"".concat(e.length,", imag: ").concat(t.length,"."));const n=new Float32Array(2*e.length);for(let a=0;a<n.length;a+=2)n[a]=e[a/2],n[a+1]=t[a/2];return n}function lm(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let a=0;a<e.length;a+=2)t[a/2]=e[a],n[a/2]=e[a+1];return{real:t,imag:n}}function um(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function hm(e){const t=Math.floor(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function dm(e,t){return{real:e[2*t],imag:e[2*t+1]}}function pm(e,t,n,a){e[2*a]=t,e[2*a+1]=n}function fm(e,t){const n=new Float32Array(e/2),a=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){const s=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(s),a[r]=Math.sin(s)}return{real:n,imag:a}}function mm(e,t,n){const a=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(a),imag:Math.sin(a)}}const gm="->",ym=/->/g,bm=",",vm="...";function xm(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(ym,"").length)/gm.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("'.concat(gm,'").'));const[a,r]=e.split(gm);Et(-1===a.indexOf(vm),(()=>'The ellipsis notation ("'.concat(vm,'") is not supported yet.')));const s=a.split(bm),o=s.length;if(t!==o)throw new Error("Expected ".concat(o," input tensors, received ").concat(t));if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let h=0;h<r.length;++h){const e=r[h];if(!s.some((t=>-1!==t.indexOf(e))))throw new Error("Output subscripts contain the label ".concat(e," ")+"not present in the input subscripts.");-1===i.indexOf(e)&&i.push(e)}for(let h=0;h<a.length;++h){const e=a[h];-1===i.indexOf(e)&&e!==bm&&i.push(e)}const c=new Array(s.length);for(let h=0;h<o;++h){if(new Set(s[h].split("")).size!==s[h].length)throw new Error("Found duplicate axes in input component ".concat(s[h],". ")+"Support for duplicate axes in input is not implemented yet.");c[h]=[];for(let e=0;e<s[h].length;++e)c[h].push(i.indexOf(s[h][e]))}const l=i.length,u=[];for(let h=r.length;h<l;++h)u.push(h);return{allDims:i,summedDims:u,idDims:c}}function wm(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;const a=[];for(let r=0;r<e;++r)-1===n[r]&&a.push(r);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:a}}function km(e,t,n){const a=new Array(e);for(let r=0;r<n.length;++r){const e=n[r].shape;for(let n=0;n<t[r].length;++n)void 0===a[t[r][n]]?a[t[r][n]]=e[n]:Et(a[t[r][n]]===e[n],(()=>"Expected dimension ".concat(a[t[r][n]]," at axis ").concat(n," ")+"of input shaped ".concat(JSON.stringify(e),", ")+"but got dimension ".concat(e[n])))}}function Sm(e,t){const n=e,a=[];let r=0;0===e.length&&n.push(-1),r=e.length+1;for(let o=0;o<r;++o)a.push([]);const s=[];for(let o=0;o<n.length;++o){const e=Nm(t,n[o]);for(const t of e)-1===s.indexOf(t)&&(a[o].push(t),s.push(t))}return{path:n,steps:a}}function Im(e){return e.every(((e,t)=>e===t))}function Nm(e,t){const n=[];for(let a=0;a<e.length;++a)0!==e[a].length&&-1===e[a].indexOf(t)&&-1!==t||n.push(a);return n}function Cm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=[];if("number"===typeof t)Et(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),a=new Array(t).fill(e.shape[n]/t);else{const r=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);Et(r<=1,(()=>"There should be only one negative value in split array."));const s=t.indexOf(-1);if(-1!==s){const a=t.reduce(((e,t)=>t>0?e+t:e));t[s]=e.shape[n]-a}Et(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),a=t}return a}function Tm(e){return"Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ".concat(e)}function Em(e,t){return"indices(".concat(e,", 0) is invalid: ").concat(t," < 0")}function Rm(e,t,n){return"indices(".concat(e,", 0) is invalid: ").concat(t," >= ").concat(n)}function Am(e,t){return"only one output dimension may be -1, not both ".concat(e," and ").concat(t)}function _m(e,t){return"size ".concat(e," must be non-negative, not ").concat(t)}function Fm(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Om(e,t){const n=Ft(e),a=Ft(t);return"Input to reshape is a SparseTensor with ".concat(n,"\n  dense values, but the requested shape requires a multiple of ").concat(a,". inputShape=").concat(e," outputShape= ").concat(t)}function Dm(e,t){const n=Ft(e),a=Ft(t);return"Input to reshape is a tensor with ".concat(n," dense values, but the requested shape has ").concat(a,". inputShape=").concat(e," outputShape=").concat(t)}function Mm(){return"segment ids must be >= 0"}function Lm(){return"segment ids are not increasing"}function Pm(e,t){return"Segment id ".concat(e," out of range [0, ").concat(t,"), possibly because segmentIds input is not sorted.")}function zm(e,t,n){return"Bad: indices[".concat(e,"] == ").concat(t," out of range [0, ").concat(n,")")}function Bm(e,t){let n,a=!1;for(e<=Hf?(n=e,a=!0):n=Zt(e,Math.floor(Math.sqrt(e)));!a;)n>t||n===e?a=!0:n=Zt(e,n+1);return n}function Wm(e,t,n){const a=[],r=e.length;for(let s=0;s<r;s++)s!==t?a.push(e[s]):a.push(n);return a}function Um(e,t,n,a){const r=t.shape.length,s=e.shape.length;if(0!==a&&(a<-r||a>r))throw new Error("Expect batchDims in the range of [-".concat(r,", ").concat(r,"], but got ").concat(a));if(a<0&&(a+=r),a>s)throw new Error("batchDims (".concat(a,") must be less than rank(x) (\n    ").concat(s,")."));if(n<a)throw new Error("batchDims (".concat(a,") must be less than or equal to axis (").concat(n,")."));for(let h=0;h<a;++h)if(e.shape[h]!==t.shape[h])throw new Error("x.shape[".concat(h,"]: ").concat(e.shape[h]," should be equal to indices.shape[").concat(h,"]: ").concat(t.shape[h],"."));const o=e.shape[n],i=[];let c=1,l=1,u=1;for(let h=0;h<a;++h)i.push(e.shape[h]),c*=e.shape[h];for(let h=a;h<n;h++)i.push(e.shape[h]),l*=e.shape[h];for(let h=a;h<r;h++)i.push(t.shape[h]);for(let h=n+1;h<s;h++)i.push(e.shape[h]),u*=e.shape[h];return{batchSize:c,sliceSize:u,outerSize:l,dimSize:o,outputShape:i}}function Vm(e){try{return e.map((e=>Zs(e)))}catch(XV){throw new Error("Failed to decode encoded string bytes into utf-8, error: ".concat(XV))}}function Gm(e){return e.map((e=>Ys(e)))}var jm,Hm;hn().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(jm||(jm={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(Hm||(Hm={}));const Km={};function qm(e){return Km[e]}function Xm(e,t,n,a,r){const s=t.inputParams[e];if(s&&void 0!==s.inputIndexStart){const e=s.inputIndexStart,o=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?e+1:s.inputIndexEnd;if("tensor"===s.type)return Ym(t.inputNames[s.inputIndexStart],n,a,r);if("tensors"===s.type){return t.inputNames.slice(e,o).map((e=>Ym(e,n,a,r)))}const i=Ym(t.inputNames.slice(e)[0],n,a,r),c=i.dataSync();return"number"===s.type?c[0]:$t(i.shape,c)}const o=t.attrParams[e];return o&&o.value}function Ym(e,t,n,a){const[r,s]=Jm(e);if(null!=a){const e=a.getHashTableHandleByName(r);if(null!=e)return e}const o=n.currentContextIds.find((e=>!!t[Qm(r,e)]));return void 0!==o?t[Qm(r,o)][s]:void 0}function Zm(e,t){const[n,a,r]=Jm(e);return[Qm(n,t&&t.currentContextId),a,r]}function Qm(e,t){return t?"".concat(e,"-").concat(t):e}function Jm(e){const t=e.split(":");if(1===t.length)return[e,0,void 0];const n=t[0],a=3===t.length?t[1]:void 0;return[n,Number(t[t.length-1]),a]}function $m(e,t,n){let a=Xm("pad",e,t,n);if("explicit"===a){a=Xm("explicitPaddings",e,t,n);const r=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)r[e][0]=a[2*e],r[e][1]=a[2*e+1];return r}return a}function eg(e){return e.kept?e:Yi(e)}const tg=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ng=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ag=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],rg=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],sg=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],og=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ig=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],cg=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],lg=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],ug=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],hg=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],dg=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],pg=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],fg=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],mg=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],gg=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],yg=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],bg=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],vg=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class xg{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[o,i,c,l,u,h,d,p,f,m,g,y,b,v,x,w,k,S,I].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=e.node,a=[],r=[],s=[],o=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?a.push(e[t.name]):"Const"===t.op?r.push(e[t.name]):null!=t.input&&0!==t.input.length||s.push(e[t.name]),e)),{});let i=[];const c=[];let l={},u={};null!=t&&(l=this.mapSignatureEntries(t.inputs),u=this.mapSignatureEntries(t.outputs));const h=Object.keys(o);h.forEach((e=>{const t=o[e];t.inputNames.forEach(((e,n)=>{const[a,,r]=Zm(e),s=o[a];if(null!=s.outputs){const e=s.outputs.indexOf(r);if(-1!==e){const r="".concat(a,":").concat(e);t.inputNames[n]=r}}t.inputs.push(s),s.children.push(t)}))})),0===Object.keys(u).length?h.forEach((e=>{const t=o[e];0===t.children.length&&c.push(t)})):Object.keys(u).forEach((e=>{const[t]=Zm(e),n=o[t];null!=n&&(n.signatureKey=u[e],c.push(n))})),Object.keys(l).length>0?Object.keys(l).forEach((e=>{const[t]=Zm(e),n=o[t];n&&(n.signatureKey=l[e],i.push(n))})):i=a;let d={};null!=e.library&&null!=e.library.function&&(d=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const p={nodes:o,inputs:i,outputs:c,weights:r,placeholders:a,signature:t,functions:d};return s.length>0&&(p.initNodes=s),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){const t=qm(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{const a=n.type;let r;switch(n.type){case"string":r=kg(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=kg(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":r=Fg(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=Fg(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":r=Ig(e.attr,n.tfName,n.defaultValue||0),void 0===r&&n.tfDeprecatedName&&(r=Ig(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":r=_g(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=_g(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":r=Sg(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=Sg(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":r=Dg(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=Dg(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":r=Ag(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=Ag(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":r=Og(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=Og(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":r=Tg(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=Tg(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":r=Eg(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=Eg(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":r=Cg(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=Cg(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error("Unsupported param type: ".concat(n.type," for op: ").concat(e.op))}return t[n.name]={value:r,type:a},t}),{})),n}mapFunction(e){const t=e.nodeDef,n=[];let a={};null!=t&&(a=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));const r=[],s=[];e.signature.inputArg.forEach((e=>{const[t]=Zm(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Ng(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,r.push(n),a[t]=n}));Object.keys(a).forEach((e=>{const t=a[e];t.inputNames.forEach(((e,n)=>{const[r,,s]=Zm(e),o=a[r];if(null!=o.outputs){const e=o.outputs.indexOf(s);if(-1!==e){const a="".concat(r,":").concat(e);t.inputNames[n]=a}}t.inputs.push(o),o.children.push(t)}))}));const o=e.ret;e.signature.outputArg.forEach((e=>{const[t,n]=Zm(o[e.name]),r=a[t];null!=r&&(r.defaultOutput=n,s.push(r))}));const i=this.mapArgsToSignature(e);return{nodes:a,inputs:r,outputs:s,weights:n,placeholders:[],signature:i}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function wg(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=hn().global;if("undefined"!==typeof t.atob)return t.atob(e);if("undefined"!==typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function kg(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=e[t];return null!=r?wg(r.s,a):n}function Sg(e,t,n){const a=e[t];return a?a.b:n}function Ig(e,t,n){const a=e[t]||{},r=null!=a.i?a.i:null!=a.f?a.f:n;return"number"===typeof r?r:parseInt(r,10)}function Ng(e){switch("string"===typeof e&&(e=jm[e]),e){case jm.DT_FLOAT:case jm.DT_HALF:return"float32";case jm.DT_INT32:case jm.DT_INT64:case jm.DT_INT8:case jm.DT_UINT8:return"int32";case jm.DT_BOOL:return"bool";case jm.DT_DOUBLE:return"float32";case jm.DT_STRING:return"string";default:return null}}function Cg(e,t,n){const a=e[t];return a&&a.func?a.func.name:n}function Tg(e,t,n){const a=e[t];return a&&a.type?Ng(a.type):n}function Eg(e,t,n){const a=e[t];return a&&a.list&&a.list.type?a.list.type.map((e=>Ng(e))):n}function Rg(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"===typeof e.size?e.size:parseInt(e.size,10))):[]}function Ag(e,t,n){const a=e[t];return a&&a.shape?Rg(a.shape):n}function _g(e,t,n){const a=e[t];return a?((a.list.f&&a.list.f.length?a.list.f:a.list.i)||[]).map((e=>"number"===typeof e?e:parseInt(e,10))):n}function Fg(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=e[t];return r&&r.list&&r.list.s?r.list.s.map((e=>wg(e,a))):n}function Og(e,t,n){const a=e[t];return a&&a.list&&a.list.shape?a.list.shape.map((e=>Rg(e))):n}function Dg(e,t,n){const a=e[t];return a&&a.list&&a.list.b?a.list.b:n}class Mg{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return Ym(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return Ym(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return Ig(this.node.rawAttrs,e,t);if(null!=n.s)return kg(this.node.rawAttrs,e,t);if(null!=n.b)return Sg(this.node.rawAttrs,e,t);if(null!=n.shape)return Ag(this.node.rawAttrs,e,t);if(null!=n.type)return Tg(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return _g(this.node.rawAttrs,e,t);if(null!=n.list.s)return Fg(this.node.rawAttrs,e,t);if(null!=n.list.shape)return Og(this.node.rawAttrs,e,t);if(null!=n.list.b)return Dg(this.node.rawAttrs,e,t);if(null!=n.list.type)return Eg(this.node.rawAttrs,e,t)}return t}}function Lg(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";if("number"!==typeof e&&"number"!==typeof t){Et(e.length===t.length,(()=>n+" Shapes ".concat(e," and ").concat(t," must match")));for(let a=0;a<e.length;a++){const r=e[a],s=t[a];Et(r<0||s<0||r===s,(()=>n+" Shapes ".concat(e," and ").concat(t," must match")))}}}function Pg(e){return"number"!==typeof e&&!e.some((e=>e<0))}function zg(e,t,n){let a=Bg(e,n);const r=!Pg(a);if(r&&0===t.length)throw new Error("Tried to calculate elements of an empty list"+" with non-fully-defined elementShape: ".concat(a));if(r&&t.forEach((e=>{a=Bg(e.shape,a)})),!Pg(a))throw new Error("Non-fully-defined elementShape: ".concat(a));return a}function Bg(e,t){if("number"===typeof e)return t;if("number"===typeof t)return e;if(e.length!==t.length)throw new Error("Incompatible ranks during merge: ".concat(e," vs. ").concat(t));const n=[];for(let a=0;a<e.length;++a){const r=e[a],s=t[a];if(r>=0&&s>=0&&r!==s)throw new Error("Incompatible shape during merge: ".concat(e," vs. ").concat(t));n[a]=r>=0?r:s}return n}class Wg{constructor(e,t,n,a,r,s,o){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=a,this.identicalElementShapes=r,this.dynamicSize=s,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=el(0),Zc(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error("TensorArray ".concat(this.name," has already been closed."));if(e<0||e>=this.size())throw new Error("Tried to read from index ".concat(e,", but array size is: ").concat(this.size()));const t=this.tensors[e];if(t.cleared)throw new Error("TensorArray ".concat(this.name,": Could not read index ").concat(e," twice because it was cleared after a previous read ")+"(perhaps try setting clear_after_read = false?).");return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error("TensorArray ".concat(this.name," has already been closed."));if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error("Tried to write to index ".concat(e,", but array is not resizeable and size is: ").concat(this.maxSize));const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,",\n          because the value dtype is ").concat(t.dtype,", but TensorArray dtype is ").concat(this.dtype,"."));if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),Lg(this.elementShape,t.shape,"TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,".")),n.read)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,", because it has already been read."));if(n.written)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,", because it has already been written."));n.tensor=t,Zc(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error("TensorArray ".concat(this.name,": could not write multiple tensors,")+"because the index size: ".concat(e.length," is not the same as tensors size: ").concat(t.length,"."));e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but gather requested dtype ").concat(t));if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return qo([],[0].concat(this.elementShape));const n=this.readMany(e);return Lg(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Pd(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but concat requested dtype ").concat(e));if(0===this.size())return qo([],[0].concat(this.elementShape));const t=[];for(let a=0;a<this.size();a++)t.push(a);const n=this.readMany(t);return Lg(this.elementShape,n[0].shape,"TensorArray shape mismatch: tensor array shape (".concat(this.elementShape,") vs first tensor shape (").concat(n[0].shape,")")),Ol(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but tensor has dtype ").concat(t.dtype));if(e.length!==t.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: ".concat(e.length," vs. ").concat(t.shape[0]));const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error("Max index must be < array size (".concat(n,"  vs. ").concat(this.maxSize,")"));this.writeMany(e,Zd(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but tensor has dtype ").concat(t.dtype));let n=0;const a=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ".concat(n,", and tensor's shape is: ").concat(t.shape));if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error("TensorArray's size is not equal to the size of lengths (".concat(this.maxSize," vs. ").concat(e.length,"), ")+"and the TensorArray is not marked as dynamically resizeable");const r=0===n?0:t.size/n,s=[];Xc((()=>{t=Al(t,[1,n,r]);for(let n=0;n<e.length;++n){const o=[0,0===n?0:a[n-1],0],i=[1,e[n],r];s[n]=Al(Pl(t,o,i),this.elementShape)}return s}));const o=[];for(let i=0;i<e.length;i++)o[i]=i;this.writeMany(o,s)}}class Ug{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1;this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error("Invalid data types; op elements ".concat(n,", but list elements ").concat(e.dtype));Lg(t,e.shape,"TensorList shape mismatch: "),Zc(e)})),this.idTensor=el(0),this.maxNumElements=a,Zc(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Ug([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));if(-1!==n&&this.tensors.length!==n)throw new Error("Operation expected a list with ".concat(n," elements but got a list with ").concat(this.tensors.length," elements."));Lg(e,this.elementShape,"TensorList shape mismatch: ");const a=zg(this.elementShape,this.tensors,e);return Xc((()=>{const e=this.tensors.map((e=>Al(e,a)));return Pd(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=zg(this.elementShape,this.tensors,e),a=this.tensors.pop();return a.kept=!1,Lg(a.shape,e,"TensorList shape mismatch: "),Al(a,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(e.dtype,", but list elements ").concat(this.elementDtype));if(Lg(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Zc(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error("TensorListResize expects size to be non-negative. Got: ".concat(e));if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error("TensorListResize input size ".concat(e," is greater maxNumElement ").concat(this.maxNumElements,"."));const t=new Ug([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(n,", but list elements ").concat(this.elementDtype));if(e<0||e>this.tensors.length)throw new Error("Trying to access element ".concat(e," in a list with ").concat(this.tensors.length," elements."));if(null==this.tensors[e])throw new Error("element at index ".concat(e," is null."));Lg(this.tensors[e].shape,t,"TensorList shape mismatch: ");const a=zg(this.elementShape,this.tensors,t);return Al(this.tensors[e],a)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t.dtype,", but list elements ").concat(this.elementDtype));if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error("Trying to set element ".concat(e," in a list with max ").concat(this.maxNumElements," elements."));Lg(this.elementShape,t.shape,"TensorList shape mismatch: "),Zc(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));Lg(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const a=zg(this.elementShape,this.tensors,n);return 0===e.length?qo([],[0].concat(a)):Xc((()=>{const t=e.map((e=>Al(this.tensors[e],a)));return Pd(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error("TensorList dtype is ".concat(this.elementDtype," but concat requested dtype ").concat(e));Lg(this.elementShape,t,"TensorList shape mismatch: ");const n=zg(this.elementShape,this.tensors,t);return 0===this.size()?qo([],[0].concat(n)):Xc((()=>{const e=this.tensors.map((e=>Al(e,n)));return Ol(e,0)}))}}const Vg=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const a=Xm("thenBranch",e,t,n),r=Xm("elseBranch",e,t,n),s=Xm("cond",e,t,n),o=Xm("args",e,t,n);return(await s.data())[0]?n.functionMap[a].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const a=Xm("body",e,t,n),r=Xm("cond",e,t,n),s=Xm("args",e,t,n),o=await n.functionMap[r].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),i=s.map((e=>e.id));let c=await o[0].data();o.forEach((e=>{e.kept||-1!==i.indexOf(e.id)||e.dispose()}));let l=s;for(;c[0];){const e=l;l=await n.functionMap[a].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);const t=l.map((e=>e.id));e.forEach((e=>{e.kept||-1!==i.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const s=await n.functionMap[r].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);c=await s[0].data(),s.forEach((e=>{e.kept||-1!==i.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return l}case"LoopCond":return[eg(Xm("pred",e,t,n))];case"Switch":{const a=Xm("pred",e,t,n);let r=Xm("data",e,t,n);return r.kept||(r=eg(r)),(await a.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const a=e.inputNames.find((e=>void 0!==Ym(e,t,n)));if(a){return[eg(Ym(a,t,n))]}return}case"Enter":{const a=Xm("frameName",e,t,n),r=Xm("tensor",e,t,n);return n.enterFrame(a),[eg(r)]}case"Exit":{const a=Xm("tensor",e,t,n);return n.exitFrame(),[eg(a)]}case"NextIteration":{const a=Xm("tensor",e,t,n);return n.nextIteration(),[eg(a)]}case"TensorArrayV3":{const a=Xm("size",e,t,n),r=Xm("dtype",e,t,n),s=Xm("elementShape",e,t,n),o=Xm("dynamicSize",e,t,n),i=Xm("clearAfterRead",e,t,n),c=Xm("identicalElementShapes",e,t,n),l=Xm("name",e,t,n),u=new Wg(l,r,a,s,c,o,i);return n.addTensorArray(u),[u.idTensor,el(1)]}case"TensorArrayWriteV3":{const a=Xm("tensorArrayId",e,t,n),r=Xm("index",e,t,n),s=Xm("tensor",e,t,n),o=n.getTensorArray(a.id);return o.write(r,s),[o.idTensor]}case"TensorArrayReadV3":{const a=Xm("tensorArrayId",e,t,n),r=Xm("index",e,t,n);return[n.getTensorArray(a.id).read(r)]}case"TensorArrayGatherV3":{const a=Xm("tensorArrayId",e,t,n),r=Xm("indices",e,t,n),s=Xm("dtype",e,t,n);return[n.getTensorArray(a.id).gather(r,s)]}case"TensorArrayScatterV3":{const a=Xm("tensorArrayId",e,t,n),r=Xm("indices",e,t,n),s=Xm("tensor",e,t,n),o=n.getTensorArray(a.id);return o.scatter(r,s),[o.idTensor]}case"TensorArrayConcatV3":{const a=Xm("tensorArrayId",e,t,n),r=n.getTensorArray(a.id),s=Xm("dtype",e,t,n);return[r.concat(s)]}case"TensorArraySplitV3":{const a=Xm("tensorArrayId",e,t,n),r=Xm("tensor",e,t,n),s=Xm("lengths",e,t,n),o=n.getTensorArray(a.id);return o.split(s,r),[o.idTensor]}case"TensorArraySizeV3":{const a=Xm("tensorArrayId",e,t,n);return[el(n.getTensorArray(a.id).size(),"int32")]}case"TensorArrayCloseV3":{const a=Xm("tensorArrayId",e,t,n),r=n.getTensorArray(a.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const a=Xm("tensorListId",e,t,n),r=Xm("index",e,t,n),s=Xm("tensor",e,t,n),o=n.getTensorList(a.id);return o.setItem(r,s),[o.idTensor]}case"TensorListGetItem":{const a=Xm("tensorListId",e,t,n),r=Xm("index",e,t,n),s=Xm("elementShape",e,t,n),o=Xm("elementDType",e,t,n);return[n.getTensorList(a.id).getItem(r,s,o)]}case"TensorListScatterV2":case"TensorListScatter":{const a=Xm("indices",e,t,n),r=function(e,t,n,a){if(t.length!==e.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: ".concat(t.length," vs. ").concat(e.shape[0]));const r=Math.max(...t);if(null!=a&&-1!==a&&r>=a)throw new Error("Max index must be < array size (".concat(r,"  vs. ").concat(a,")"));const s=new Ug([],n,e.dtype,a),o=Zd(e,0);return t.forEach(((e,t)=>{s.setItem(e,o[t])})),s}(Xm("tensor",e,t,n),a,Xm("elementShape",e,t,n),Xm("numElements",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const a=Xm("elementShape",e,t,n),r=Xm("elementDType",e,t,n);let s;s="TensorListReserve"===e.op?"numElements":"maxNumElements";const o=Xm(s,e,t,n),i=function(e,t,n,a){return new Ug([],e,t,a)}(a,r,0,"TensorListReserve"===e.op?-1:o);return n.addTensorList(i),[i.idTensor]}case"TensorListGather":{const a=Xm("tensorListId",e,t,n),r=Xm("indices",e,t,n),s=Xm("elementShape",e,t,n),o=Xm("elementDType",e,t,n);return[n.getTensorList(a.id).gather(r,o,s)]}case"TensorListStack":{const a=Xm("tensorListId",e,t,n),r=Xm("elementShape",e,t,n),s=Xm("elementDType",e,t,n),o=Xm("numElements",e,t,n);return[n.getTensorList(a.id).stack(r,s,o)]}case"TensorListFromTensor":{const a=function(e,t,n){const a=e.dtype;if(e.shape.length<1)throw new Error("Tensor must be at least a vector, but saw shape: ".concat(e.shape));if(e.dtype!==n)throw new Error("Invalid data types; op elements ".concat(e.dtype,", but list elements ").concat(n));Lg(e.shape.slice(1),t,"TensorList shape mismatch: ");const r=Zd(e);return new Ug(r,t,a)}(Xm("tensor",e,t,n),Xm("elementShape",e,t,n),Xm("elementDType",e,t,n));return n.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const a=Xm("tensorListId",e,t,n),r=n.getTensorList(a.id),s=Xm("dtype",e,t,n),o=Xm("elementShape",e,t,n);return[r.concat(s,o)]}case"TensorListPushBack":{const a=Xm("tensorListId",e,t,n),r=Xm("tensor",e,t,n),s=n.getTensorList(a.id);return s.pushBack(r),[s.idTensor]}case"TensorListPopBack":{const a=Xm("tensorListId",e,t,n),r=Xm("elementShape",e,t,n),s=Xm("elementDType",e,t,n);return[n.getTensorList(a.id).popBack(r,s)]}case"TensorListSplit":{const a=Xm("tensor",e,t,n),r=Xm("elementShape",e,t,n),s=function(e,t,n){let a=0;const r=t.map((e=>(a+=e,a)));if(a!==e.shape[0])throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ".concat(a,", and tensor's shape is: ").concat(e.shape));const s=Bg(e.shape.slice(1),n),o=0===a?0:e.size/a,i=Xc((()=>{const n=[];e=Al(e,[1,a,o]);for(let a=0;a<t.length;++a){const i=[0,0===a?0:r[a-1],0],c=[1,t[a],o];n[a]=Al(Pl(e,i,c),s)}return e.dispose(),n})),c=new Ug([],n,e.dtype,t.length);for(let l=0;l<i.length;l++)c.setItem(l,i[l]);return c}(a,Xm("lengths",e,t,n),r);return n.addTensorList(s),[s.idTensor]}case"TensorListLength":{const a=Xm("tensorListId",e,t,n);return[el(n.getTensorList(a.id).size(),"int32")]}case"TensorListResize":{const a=Xm("tensorListId",e,t,n),r=Xm("size",e,t,n),s=n.getTensorList(a.id).resize(r);return n.addTensorList(s),[s.idTensor]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}};function Gg(e,t,n){const[a,r]=Xm("fusedOps",e,t,n),s="biasadd"===a,o=!s,i="prelu"===r,c="fusedbatchnorm"===a,l=Xm("numArgs",e,t,n);if(s){if(i&&2!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&s&&1!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(c)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=Xm("strides",e,t,n),h=$m(e,t,n),d=Xm("dataFormat",e,t,n).toUpperCase(),p=Xm("dilations",e,t,n);let[f,m]=Xm("args",e,t,n);o&&(m=f,f=void 0);return{stride:u,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:r,leakyreluAlpha:Xm("leakyreluAlpha",e,t,n)}}function jg(e,t,n){return{boxes:Xm("boxes",e,t,n),scores:Xm("scores",e,t,n),maxOutputSize:Xm("maxOutputSize",e,t,n),iouThreshold:Xm("iouThreshold",e,t,n),scoreThreshold:Xm("scoreThreshold",e,t,n),softNmsSigma:Xm("softNmsSigma",e,t,n)}}class Hg{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=el(0),this.tensorMap=new Map,Zc(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return el(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),Xc((()=>{const e=Zd(t),a=n.length,r=e.length;Et(a===r,(()=>"The number of elements doesn't match, keys has "+"".concat(a," elements, the values has ").concat(r," ")+"elements."));for(let t=0;t<a;t++){const a=n[t],r=e[t];Zc(r),this.tensorMap.set(a,r)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return Xc((()=>{const e=[];for(let a=0;a<n.length;a++){const r=n[a],s=this.findWithDefault(r,t);e.push(s)}return Pd(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error("Expect key dtype ".concat(this.keyDType,", but got ")+"".concat(e.dtype));if(t.dtype!==this.valueDType)throw new Error("Expect value dtype ".concat(this.valueDType,", but got ")+"".concat(t.dtype))}}function Kg(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Xc;const s=((e,t,n)=>{switch(e.category){case"arithmetic":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[a.add(Xm("a",e,t,n),Xm("b",e,t,n))];case"AddN":return[a.addN(Xm("tensors",e,t,n))];case"FloorMod":case"Mod":return[a.mod(Xm("a",e,t,n),Xm("b",e,t,n))];case"Mul":return[a.mul(Xm("a",e,t,n),Xm("b",e,t,n))];case"RealDiv":case"Div":return[a.div(Xm("a",e,t,n),Xm("b",e,t,n))];case"DivNoNan":return[a.divNoNan(Xm("a",e,t,n),Xm("b",e,t,n))];case"FloorDiv":return[a.floorDiv(Xm("a",e,t,n),Xm("b",e,t,n))];case"Sub":return[a.sub(Xm("a",e,t,n),Xm("b",e,t,n))];case"Minimum":return[a.minimum(Xm("a",e,t,n),Xm("b",e,t,n))];case"Maximum":return[a.maximum(Xm("a",e,t,n),Xm("b",e,t,n))];case"Pow":return[a.pow(Xm("a",e,t,n),Xm("b",e,t,n))];case"SquaredDifference":return[a.squaredDifference(Xm("a",e,t,n),Xm("b",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"basic_math":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"Abs":case"ComplexAbs":return[a.abs(Xm("x",e,t,n))];case"Acos":return[a.acos(Xm("x",e,t,n))];case"Acosh":return[a.acosh(Xm("x",e,t,n))];case"Asin":return[a.asin(Xm("x",e,t,n))];case"Asinh":return[a.asinh(Xm("x",e,t,n))];case"Atan":return[a.atan(Xm("x",e,t,n))];case"Atan2":return[a.atan2(Xm("x",e,t,n),Xm("y",e,t,n))];case"Atanh":return[a.atanh(Xm("x",e,t,n))];case"Ceil":return[a.ceil(Xm("x",e,t,n))];case"Complex":return[a.complex(Xm("real",e,t,n),Xm("imag",e,t,n))];case"Cos":return[a.cos(Xm("x",e,t,n))];case"Cosh":return[a.cosh(Xm("x",e,t,n))];case"Elu":return[a.elu(Xm("x",e,t,n))];case"Erf":return[a.erf(Xm("x",e,t,n))];case"Exp":return[a.exp(Xm("x",e,t,n))];case"Expm1":return[a.expm1(Xm("x",e,t,n))];case"Floor":return[a.floor(Xm("x",e,t,n))];case"Log":return[a.log(Xm("x",e,t,n))];case"Log1p":return[a.log1p(Xm("x",e,t,n))];case"Imag":return[a.imag(Xm("x",e,t,n))];case"Neg":return[a.neg(Xm("x",e,t,n))];case"Reciprocal":return[a.reciprocal(Xm("x",e,t,n))];case"Real":return[a.real(Xm("x",e,t,n))];case"Relu":return[a.relu(Xm("x",e,t,n))];case"Round":return[a.round(Xm("x",e,t,n))];case"Selu":return[a.selu(Xm("x",e,t,n))];case"Sigmoid":return[a.sigmoid(Xm("x",e,t,n))];case"Sin":return[a.sin(Xm("x",e,t,n))];case"Sign":return[a.sign(Xm("x",e,t,n))];case"Sinh":return[a.sinh(Xm("x",e,t,n))];case"Softplus":return[a.softplus(Xm("x",e,t,n))];case"Sqrt":return[a.sqrt(Xm("x",e,t,n))];case"Square":return[a.square(Xm("x",e,t,n))];case"Tanh":return[a.tanh(Xm("x",e,t,n))];case"Tan":return[a.tan(Xm("x",e,t,n))];case"ClipByValue":return[a.clipByValue(Xm("x",e,t,n),Xm("clipValueMin",e,t,n),Xm("clipValueMax",e,t,n))];case"Relu6":return[a.relu6(Xm("x",e,t,n))];case"Rsqrt":return[a.rsqrt(Ym(e.inputNames[0],t,n))];case"Prod":return[a.prod(Xm("x",e,t,n),Xm("axes",e,t,n))];case"LeakyRelu":return[a.leakyRelu(Xm("x",e,t,n),Xm("alpha",e,t,n))];case"Prelu":return[a.prelu(Xm("x",e,t,n),Xm("alpha",e,t,n))];case"IsNan":return[a.isNaN(Ym(e.inputNames[0],t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"control":return Vg(e,t,n);case"convolution":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"Conv1D":{const r=Xm("stride",e,t,n),s=Xm("pad",e,t,n),o=Xm("dataFormat",e,t,n).toUpperCase(),i=Xm("dilation",e,t,n);return[a.conv1d(Xm("x",e,t,n),Xm("filter",e,t,n),r,s,o,i)]}case"Conv2D":{const r=Xm("strides",e,t,n),s=$m(e,t,n),o=Xm("dataFormat",e,t,n).toUpperCase(),i=Xm("dilations",e,t,n);return[a.conv2d(Xm("x",e,t,n),Xm("filter",e,t,n),[r[1],r[2]],s,o,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:r,pad:s,dataFormat:o,dilations:i,biasArg:c,preluArg:l,activationFunc:u,leakyreluAlpha:h}=Gg(e,t,n);return[a.fused.conv2d({x:Xm("x",e,t,n),filter:Xm("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:c,activation:u,preluActivationWeights:l,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:s,dataFormat:o,dilations:i,biasArg:c,preluArg:l,activationFunc:u,leakyreluAlpha:h}=Gg(e,t,n);return[a.fused.depthwiseConv2d({x:Xm("x",e,t,n),filter:Xm("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:c,activation:u,preluActivationWeights:l,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=Xm("outputShape",e,t,n),s=Xm("strides",e,t,n),o=$m(e,t,n);return[a.conv2dTranspose(Xm("x",e,t,n),Xm("filter",e,t,n),r,[s[1],s[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=Xm("strides",e,t,n),s=$m(e,t,n),o=Xm("dilations",e,t,n),i=Xm("dataFormat",e,t,n).toUpperCase();return[a.depthwiseConv2d(Xm("input",e,t,n),Xm("filter",e,t,n),[r[1],r[2]],s,i,[o[1],o[2]])]}case"Conv3D":{const r=Xm("strides",e,t,n),s=Xm("pad",e,t,n),o=Xm("dataFormat",e,t,n).toUpperCase(),i=Xm("dilations",e,t,n);return[a.conv3d(Xm("x",e,t,n),Xm("filter",e,t,n),[r[1],r[2],r[3]],s,o,[i[1],i[2],i[3]])]}case"AvgPool":{const r=Xm("strides",e,t,n),s=Xm("pad",e,t,n),o=Xm("kernelSize",e,t,n);return[a.avgPool(Xm("x",e,t,n),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPool":{const r=Xm("strides",e,t,n),s=Xm("pad",e,t,n),o=Xm("kernelSize",e,t,n);return[a.maxPool(Xm("x",e,t,n),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{const r=Xm("strides",e,t,n),s=Xm("pad",e,t,n),o=Xm("kernelSize",e,t,n),i=Xm("includeBatchInIndex",e,t,n),{result:c,indexes:l}=a.maxPoolWithArgmax(Xm("x",e,t,n),[o[1],o[2]],[r[1],r[2]],s,i);return[c,l]}case"AvgPool3D":{const r=Xm("strides",e,t,n),s=Xm("pad",e,t,n),o=Xm("kernelSize",e,t,n);return[a.avgPool3d(Xm("x",e,t,n),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{const r=Xm("strides",e,t,n),s=Xm("pad",e,t,n),o=Xm("kernelSize",e,t,n);return[a.maxPool3d(Xm("x",e,t,n),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{const r=Xm("strides",e,t,n),s=Xm("pad",e,t,n),o=Xm("dilations",e,t,n),i=r[1],c=r[2],l=o[1],u=o[2];return[a.dilation2d(Xm("x",e,t,n),Xm("filter",e,t,n),[i,c],s,[l,u],"NHWC")]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"creation":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"Fill":{const r=Xm("shape",e,t,n),s=Xm("dtype",e,t,n),o=Xm("value",e,t,n);return[a.fill(r,o,s)]}case"LinSpace":{const r=Xm("start",e,t,n),s=Xm("stop",e,t,n),o=Xm("num",e,t,n);return[a.linspace(r,s,o)]}case"Multinomial":{const r=Xm("logits",e,t,n),s=Xm("numSamples",e,t,n),o=Xm("seed",e,t,n);return[a.multinomial(r,s,o)]}case"OneHot":{const r=Xm("indices",e,t,n),s=Xm("depth",e,t,n),o=Xm("onValue",e,t,n),i=Xm("offValue",e,t,n),c=Xm("dtype",e,t,n);return[a.oneHot(r,s,o,i,c)]}case"Ones":return[a.ones(Xm("shape",e,t,n),Xm("dtype",e,t,n))];case"OnesLike":return[a.onesLike(Xm("x",e,t,n))];case"RandomStandardNormal":return[a.randomStandardNormal(Xm("shape",e,t,n),Xm("dtype",e,t,n),Xm("seed",e,t,n))];case"RandomUniform":return[a.randomUniform(Xm("shape",e,t,n),Xm("minval",e,t,n),Xm("maxval",e,t,n),Xm("dtype",e,t,n))];case"Range":{const r=Xm("start",e,t,n),s=Xm("stop",e,t,n),o=Xm("step",e,t,n);return[a.range(r,s,o,Xm("dtype",e,t,n))]}case"TruncatedNormal":{const r=Xm("shape",e,t,n),s=Xm("mean",e,t,n),o=Xm("stdDev",e,t,n),i=Xm("seed",e,t,n);return[a.truncatedNormal(r,s,o,Xm("dtype",e,t,n),i)]}case"Zeros":return[a.zeros(Xm("shape",e,t,n),Xm("dtype",e,t,n))];case"ZerosLike":return[a.zerosLike(Xm("x",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"dynamic":return async function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:N;switch(e.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:c,softNmsSigma:l}=jg(e,t,n),u=await r.image.nonMaxSuppressionWithScoreAsync(a,s,o,i,c,l);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:c}=jg(e,t,n),l=Xm("padToMaxOutputSize",e,t,n),u=await r.image.nonMaxSuppressionPaddedAsync(a,s,o,i,c,l);return[u.selectedIndices,u.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:c}=jg(e,t,n);return[await r.image.nonMaxSuppressionAsync(a,s,o,i,c)]}case"Where":{const a=r.cast(Xm("condition",e,t,n),"bool"),s=[await r.whereAsync(a)];return a.dispose(),s}case"ListDiff":return r.setdiff1dAsync(Xm("x",e,t,n),Xm("y",e,t,n));default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n);case"evaluation":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"LowerBound":{const r=Xm("sortedSequence",e,t,n),s=Xm("values",e,t,n);return[a.lowerBound(r,s)]}case"TopKV2":{const r=Xm("x",e,t,n),s=Xm("k",e,t,n),o=Xm("sorted",e,t,n),i=a.topk(r,s,o);return[i.values,i.indices]}case"UpperBound":{const r=Xm("sortedSequence",e,t,n),s=Xm("values",e,t,n);return[a.upperBound(r,s)]}case"Unique":{const r=Xm("x",e,t,n),s=a.unique(r);return[s.values,s.indices]}case"UniqueV2":{const r=Xm("x",e,t,n),s=Xm("axis",e,t,n),o=a.unique(r,s);return[o.values,o.indices]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"image":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"ResizeBilinear":{const r=Xm("images",e,t,n),s=Xm("size",e,t,n),o=Xm("alignCorners",e,t,n),i=Xm("halfPixelCenters",e,t,n);return[a.image.resizeBilinear(r,[s[0],s[1]],o,i)]}case"ResizeNearestNeighbor":{const r=Xm("images",e,t,n),s=Xm("size",e,t,n),o=Xm("alignCorners",e,t,n),i=Xm("halfPixelCenters",e,t,n);return[a.image.resizeNearestNeighbor(r,[s[0],s[1]],o,i)]}case"CropAndResize":{const r=Xm("image",e,t,n),s=Xm("boxes",e,t,n),o=Xm("boxInd",e,t,n),i=Xm("cropSize",e,t,n),c=Xm("method",e,t,n),l=Xm("extrapolationValue",e,t,n);return[a.image.cropAndResize(r,s,o,i,c,l)]}case"ImageProjectiveTransformV3":{const r=Xm("images",e,t,n),s=Xm("transforms",e,t,n),o=Xm("outputShape",e,t,n),i=Xm("fillValue",e,t,n),c=Xm("interpolation",e,t,n),l=Xm("fillMode",e,t,n);return[a.image.transform(r,s,c.toLowerCase(),l.toLowerCase(),i,o)]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"graph":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const r=Xm("default",e,t,n);return[Ym(e.name,t,n)||r];case"Placeholder":return[Ym(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[eg(Xm("x",e,t,n))];case"IdentityN":return Xm("x",e,t,n).map((e=>eg(e)));case"Shape":return[a.tensor1d(Xm("x",e,t,n).shape,"int32")];case"ShapeN":return Xm("x",e,t,n).map((e=>a.tensor1d(e.shape)));case"Size":return[a.scalar(Xm("x",e,t,n).size,"int32")];case"Rank":return[a.scalar(Xm("x",e,t,n).rank,"int32")];case"NoOp":return[a.scalar(1)];case"Print":const s=Xm("x",e,t,n),o=Xm("data",e,t,n),i=Xm("message",e,t,n),c=Xm("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let e=0;e<o.length;e++)console.log(Array.prototype.slice.call(o[e].dataSync()).slice(0,c));return[s];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"logical":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"Equal":return[a.equal(Xm("a",e,t,n),Xm("b",e,t,n))];case"NotEqual":return[a.notEqual(Xm("a",e,t,n),Xm("b",e,t,n))];case"Greater":return[a.greater(Xm("a",e,t,n),Xm("b",e,t,n))];case"GreaterEqual":return[a.greaterEqual(Xm("a",e,t,n),Xm("b",e,t,n))];case"Less":return[a.less(Xm("a",e,t,n),Xm("b",e,t,n))];case"LessEqual":return[a.lessEqual(Xm("a",e,t,n),Xm("b",e,t,n))];case"LogicalAnd":return[a.logicalAnd(Xm("a",e,t,n),Xm("b",e,t,n))];case"LogicalNot":return[a.logicalNot(Xm("a",e,t,n))];case"LogicalOr":return[a.logicalOr(Xm("a",e,t,n),Xm("b",e,t,n))];case"Select":case"SelectV2":return[a.where(Xm("condition",e,t,n),Xm("a",e,t,n),Xm("b",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"matrices":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[a.matMul(Xm("a",e,t,n),Xm("b",e,t,n),Xm("transposeA",e,t,n),Xm("transposeB",e,t,n))];case"Einsum":return[a.einsum(Xm("equation",e,t,n),...Xm("tensors",e,t,n))];case"Transpose":return[a.transpose(Xm("x",e,t,n),Xm("perm",e,t,n))];case"_FusedMatMul":const[r,s]=Xm("fusedOps",e,t,n),o="biasadd"===r,i="prelu"===s,c=Xm("numArgs",e,t,n),l=Xm("leakyreluAlpha",e,t,n);if(o){if(i&&2!==c)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==c)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,h]=Xm("args",e,t,n);return[a.fused.matMul({a:Xm("a",e,t,n),b:Xm("b",e,t,n),transposeA:Xm("transposeA",e,t,n),transposeB:Xm("transposeB",e,t,n),bias:u,activation:s,preluActivationWeights:h,leakyreluAlpha:l})];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"normalization":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"EuclideanNorm":return[a.euclideanNorm(Xm("x",e,t,n),Xm("axis",e,t,n),Xm("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[a.batchNorm(Xm("x",e,t,n),Xm("mean",e,t,n),Xm("variance",e,t,n),Xm("offset",e,t,n),Xm("scale",e,t,n),Xm("epsilon",e,t,n))];case"LRN":return[a.localResponseNormalization(Xm("x",e,t,n),Xm("radius",e,t,n),Xm("bias",e,t,n),Xm("alpha",e,t,n),Xm("beta",e,t,n))];case"Softmax":return[a.softmax(Xm("x",e,t,n))];case"LogSoftmax":return[a.logSoftmax(Xm("x",e,t,n))];case"SparseToDense":return[a.sparseToDense(Xm("sparseIndices",e,t,n),Xm("outputShape",e,t,n),Xm("sparseValues",e,t,n),Xm("defaultValue",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"reduction":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"Max":{const r=Xm("axis",e,t,n),s=Xm("keepDims",e,t,n);return[a.max(Xm("x",e,t,n),r,s)]}case"Mean":{const r=Xm("axis",e,t,n),s=Xm("keepDims",e,t,n);return[a.mean(Xm("x",e,t,n),r,s)]}case"Min":{const r=Xm("axis",e,t,n),s=Xm("keepDims",e,t,n);return[a.min(Xm("x",e,t,n),r,s)]}case"Sum":{const r=Xm("axis",e,t,n),s=Xm("keepDims",e,t,n);return[a.sum(Xm("x",e,t,n),r,s)]}case"All":{const r=Xm("axis",e,t,n),s=Xm("keepDims",e,t,n);return[a.all(Xm("x",e,t,n),r,s)]}case"Any":{const r=Xm("axis",e,t,n),s=Xm("keepDims",e,t,n);return[a.any(Xm("x",e,t,n),r,s)]}case"ArgMax":{const r=Xm("axis",e,t,n);return[a.argMax(Xm("x",e,t,n),r)]}case"ArgMin":{const r=Xm("axis",e,t,n);return[a.argMin(Xm("x",e,t,n),r)]}case"Prod":{const r=Xm("axis",e,t,n),s=Xm("keepDims",e,t,n);return[a.prod(Xm("x",e,t,n),r,s)]}case"Cumprod":{const r=Xm("axis",e,t,n),s=Xm("exclusive",e,t,n),o=Xm("reverse",e,t,n);return[a.cumprod(Xm("x",e,t,n),r,s,o)]}case"Cumsum":{const r=Xm("axis",e,t,n),s=Xm("exclusive",e,t,n),o=Xm("reverse",e,t,n);return[a.cumsum(Xm("x",e,t,n),r,s,o)]}case"Bincount":const r=Xm("x",e,t,n),s=Xm("weights",e,t,n),o=Xm("size",e,t,n);return[a.bincount(r,s,o)];case"DenseBincount":{const r=Xm("x",e,t,n),s=Xm("weights",e,t,n),o=Xm("size",e,t,n),i=Xm("binaryOutput",e,t,n);return[a.denseBincount(r,s,o,i)]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"slice_join":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"ConcatV2":case"Concat":{const r=Xm("n",e,t,n),s=Xm("axis",e,t,n);let o=Xm("tensors",e,t,n);return o=o.slice(0,r),[a.concat(o,s)]}case"Gather":{const r=Xm("x",e,t,n),s=Xm("indices",e,t,n);return[a.gather(r,a.cast(s,"int32"),0)]}case"GatherV2":{const r=Xm("axis",e,t,n),s=Xm("batchDims",e,t,n),o=Xm("x",e,t,n),i=Xm("indices",e,t,n);return[a.gather(o,a.cast(i,"int32"),r,s)]}case"Reverse":{const r=Xm("dims",e,t,n),s=[];for(let e=0;e<r.length;e++)r[e]&&s.push(e);const o=Xm("x",e,t,n);return[a.reverse(o,s)]}case"ReverseV2":{const r=Xm("axis",e,t,n),s=Xm("x",e,t,n);return[a.reverse(s,r)]}case"Slice":{const r=Xm("begin",e,t,n),s=Xm("size",e,t,n);return[a.slice(Xm("x",e,t,n),r,s)]}case"StridedSlice":{const r=Xm("begin",e,t,n),s=Xm("end",e,t,n),o=Xm("strides",e,t,n),i=Xm("beginMask",e,t,n),c=Xm("endMask",e,t,n),l=Xm("ellipsisMask",e,t,n),u=Xm("newAxisMask",e,t,n),h=Xm("shrinkAxisMask",e,t,n),d=Xm("x",e,t,n);return[a.stridedSlice(d,r,s,o,i,c,l,u,h)]}case"Pack":return Xc((()=>{const r=Xm("axis",e,t,n),s=Xm("tensors",e,t,n),o=s[0].shape,i=a.squeeze(s[0]).shape,c=s.map((e=>{const t=Ot(e.shape,o);if(!t&&!Ot(a.squeeze(e).shape,i))throw new Error("the input tensors shape does not match");return t?e:a.reshape(e,o)}));return[a.stack(c,r)]}));case"Unpack":{const r=Xm("axis",e,t,n),s=Xm("tensor",e,t,n);return a.unstack(s,r)}case"Tile":{const r=Xm("reps",e,t,n);return[a.tile(Xm("x",e,t,n),r)]}case"Split":case"SplitV":{const r=Xm("axis",e,t,n),s=Xm("numOrSizeSplits",e,t,n),o=Xm("x",e,t,n);return a.split(o,s,r)}case"ScatterNd":{const r=Xm("indices",e,t,n),s=Xm("values",e,t,n),o=Xm("shape",e,t,n);return[a.scatterND(r,s,o)]}case"GatherNd":{const r=Xm("x",e,t,n),s=Xm("indices",e,t,n);return[a.gatherND(r,s)]}case"SparseToDense":{const r=Xm("sparseIndices",e,t,n),s=Xm("outputShape",e,t,n),o=Xm("sparseValues",e,t,n),i=Xm("defaultValue",e,t,n);return[a.sparseToDense(r,o,s,o.dtype===i.dtype?i:a.cast(i,o.dtype))]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"sparse":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:s,emptyRowIndicator:o,reverseIndexMap:i}=a.sparse.sparseFillEmptyRows(Xm("indices",e,t,n),Xm("values",e,t,n),Xm("denseShape",e,t,n),Xm("defaultValue",e,t,n));return[r,s,o,i]}case"SparseReshape":{const{outputIndices:r,outputShape:s}=a.sparse.sparseReshape(Xm("inputIndices",e,t,n),Xm("inputShape",e,t,n),Xm("newShape",e,t,n));return[r,s]}case"SparseSegmentMean":return[a.sparse.sparseSegmentMean(Xm("data",e,t,n),Xm("indices",e,t,n),Xm("segmentIds",e,t,n))];case"SparseSegmentSum":return[a.sparse.sparseSegmentSum(Xm("data",e,t,n),Xm("indices",e,t,n),Xm("segmentIds",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"spectral":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"FFT":return[a.fft(Xm("x",e,t,n))];case"IFFT":return[a.ifft(Xm("x",e,t,n))];case"RFFT":return[a.rfft(Xm("x",e,t,n))];case"IRFFT":return[a.irfft(Xm("x",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"string":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"StringNGrams":{const{nGrams:r,nGramsSplits:s}=a.string.stringNGrams(Xm("data",e,t,n),Xm("dataSplits",e,t,n),Xm("separator",e,t,n),Xm("nGramWidths",e,t,n),Xm("leftPad",e,t,n),Xm("rightPad",e,t,n),Xm("padWidth",e,t,n),Xm("preserveShortSequences",e,t,n));return[r,s]}case"StringSplit":{const{indices:r,values:s,shape:o}=a.string.stringSplit(Xm("input",e,t,n),Xm("delimiter",e,t,n),Xm("skipEmpty",e,t,n));return[r,s,o]}case"StringToHashBucketFast":return[a.string.stringToHashBucketFast(Xm("input",e,t,n),Xm("numBuckets",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"transformation":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"Cast":return[a.cast(Xm("x",e,t,n),Xm("dtype",e,t,n))];case"ExpandDims":{const r=Xm("axis",e,t,n);return[a.expandDims(Xm("x",e,t,n),r)]}case"Squeeze":{const r=Xm("axis",e,t,n);return[a.squeeze(Xm("x",e,t,n),r)]}case"Reshape":return[a.reshape(Xm("x",e,t,n),Xm("shape",e,t,n))];case"MirrorPad":return[a.mirrorPad(Xm("x",e,t,n),Xm("padding",e,t,n),Xm("mode",e,t,n))];case"PadV2":case"Pad":return[a.pad(Xm("x",e,t,n),Xm("padding",e,t,n),Xm("constantValue",e,t,n))];case"SpaceToBatchND":{const r=Xm("blockShape",e,t,n),s=Xm("paddings",e,t,n);return[a.spaceToBatchND(Xm("x",e,t,n),r,s)]}case"BatchToSpaceND":{const r=Xm("blockShape",e,t,n),s=Xm("crops",e,t,n);return[a.batchToSpaceND(Xm("x",e,t,n),r,s)]}case"DepthToSpace":{const r=Xm("blockSize",e,t,n),s=Xm("dataFormat",e,t,n).toUpperCase();return[a.depthToSpace(Xm("x",e,t,n),r,s)]}case"BroadcastTo":return[a.broadcastTo(Xm("x",e,t,n),Xm("shape",e,t,n))];case"BroadcastArgs":return[a.broadcastArgs(Xm("s0",e,t,n),Xm("s1",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"hash_table":return(async(e,t,n,a)=>{switch(e.op){case"HashTable":case"HashTableV2":{const r=Xm("keyDType",e,t,n),s=Xm("valueDType",e,t,n),o=new Hg(r,s);return a.addHashTable(e.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const r=Xm("tableHandle",e,t,n,a),s=Xm("keys",e,t,n),o=Xm("values",e,t,n),i=a.getHashTableById(r.id);return[await i.import(s,o)]}case"LookupTableFind":case"LookupTableFindV2":{const r=Xm("tableHandle",e,t,n,a),s=Xm("keys",e,t,n),o=Xm("defaultValue",e,t,n),i=a.getHashTableById(r.id);return[await i.find(s,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=Xm("tableHandle",e,t,n,a);return[a.getHashTableById(r.id).tensorSize()]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}})(e,t,n,a);case"custom":const s=qm(e.op);if(s&&s.customExecutor)return s.customExecutor(new Mg(e,t,n));throw TypeError("Custom op ".concat(e.op," is not registered."));default:throw TypeError("Unknown op '".concat(e.op,"'. File an issue at ")+"https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()")}})(e,t,n);return on(s)?s.then((e=>[].concat(e))):[].concat(s)}class qg{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":"".concat(e.frameName,"-").concat(e.iterationId))).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function Xg(e,t,n,a){const r=new Set,s=[];let o=null,i=null;const c=new Set,l=Object.keys(e).map((e=>Jm(e)[0]));let u=[];null!=a&&(u=a.map((e=>Jm(e.name)[0])));const h=[...t];for(;h.length>0;){const e=h.pop();(Jg(e)||$g(e)||ey(e))&&null==o&&(o=e,i=o.children.map((e=>e.name)).filter((e=>r.has(e)))),r.add(e.name),null==n[e.name]&&(-1===l.indexOf(e.name)&&-1===u.indexOf(e.name)&&(0!==e.inputs.length?e.inputs.forEach((e=>{c.has(e.name)||(c.add(e.name),h.push(e))})):s.push(e.name)))}return{inputs:e,outputs:t,usedNodes:r,missingInputs:s,dynamicNode:o,syncInputs:i}}const Yg=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],Zg=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],Qg=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Jg(e){return Yg.indexOf(e.op)>=0}function $g(e){return Zg.indexOf(e.op)>=0}function ey(e){return Qg.indexOf(e.op)>=0}class ty{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new ty(e.functions[t],this)}))}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?"".concat(t,":").concat(e.defaultOutput):t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort(),a=t.map((e=>e.name)).sort();return n.join(this.SEPERATOR)+"--"+a.join(this.SEPERATOR)}compile(e,t){const n=Xg(e,t,this.weightMap,this._initNodes),{missingInputs:a,dynamicNode:r,syncInputs:s}=n;if(null!=r)throw new Error("This execution contains the node '".concat(r.name,"', which has ")+"the dynamic op '".concat(r.op,"'. Please use ")+"model.executeAsync() instead. Alternatively, to avoid the "+"dynamic ops, specify the inputs [".concat(s,"]"));if(a.length>0){const n=t.map((e=>e.name)),r=Object.keys(e);throw new Error("Cannot compute the outputs [".concat(n,"] from the provided inputs ")+"[".concat(r,"]. Missing the following inputs: [").concat(a,"]"))}return function(e,t,n){const{usedNodes:a,inputs:r}=n,s=[],o=Object.keys(r).map((e=>Jm(e)[0])).map((t=>e.nodes[t])),i=e.initNodes;o.forEach((e=>{a.has(e.name)&&s.push(e)})),e.weights.forEach((e=>{a.has(e.name)&&s.push(e)})),null!=i&&i.forEach((e=>{a.has(e.name)&&s.push(e)}));const c=new Set,l=[];for(;s.length>0;){const e=s.pop();c.add(e.name),t[e.name]||l.push(e),e.children.forEach((e=>{!c.has(e.name)&&a.has(e.name)&&e.inputs.every((e=>c.has(e.name)))&&s.push(e)}))}return l}(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const a=n.map((e=>this.graph.nodes[Jm(e)[0]])),r=t.map((e=>Jm(e)[0]));let s=r.map((e=>this.graph.nodes[e]));this.resetIntermediateTensors(),0===s.length&&(s=this._outputs);const o=this.getCompilationKey(a,s);let i=this.compiledMap.get(o);null==i&&(i=this.compile(e,s),this.compiledMap.set(o,i));const c={},l={};return Xc((()=>{const n=new qg(this.weightMap,c,l,this.functionExecutorMap),a=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,r]=Jm(t),s=[];s[r]=e[t],a[n]=s}));const s=this.getFrozenTensorIds(a),o={};for(let e=0;e<i.length;e++){const t=i[e];if(!a[t.name]){const e=Kg(t,a,n,this._resourceManager);if(on(e))throw new Error("The execution of the op '".concat(t.op,"' returned a promise. ")+"Please use model.executeAsync() instead.");a[t.name]=e,this.checkTensorForDisposal(t.name,t,a,n,s,r,o)}}return null==this.parent&&n.dispose(s),t.map((e=>Ym(e,a,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,a,r,s,o){"control"!==t.category&&-1===s.indexOf(e)&&(n[e].forEach((e=>{null!=e&&(o[e.id]=(o[e.id]||0)+t.children.length)})),t.inputs.forEach((e=>{if("control"!==e.category){const s=function(e,t,n){return t[Qm(e,n.currentContextId)]}(e.name,n,a);null!=s&&s.forEach((e=>{if(e&&!e.kept&&!r.has(e.id)){const n=o[e.id];if(1===n){if(this.keepTensorForDebug){const[n,r]=Zm(t.name,a);this.intermediateTensors[n]||(this.intermediateTensors[n]=[]),this.intermediateTensors[n][r]=e}else e.dispose();delete o[e.id]}else null!=n&&o[e.id]--}}))}})))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.intermediateTensors&&(Object.keys(this.intermediateTensors).forEach((e=>this.intermediateTensors[e].forEach((e=>e.dispose())))),this.disposeTensorsMap())}disposeTensorsMap(){this.tensorsMap&&Object.keys(this.tensorsMap).forEach((e=>{this.tensorsMap[e].forEach((e=>{!e||e.kept||e.isDisposed||this.keepIds.has(e.id)||e.dispose()}))}))}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const e in this.intermediateTensors)this.intermediateTensors[e].forEach((e=>e.dispose())),delete this.intermediateTensors[e]}async _executeAsync(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepTensorForDebug=hn().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(qV){console.warn(qV.message)}this.resetIntermediateTensors();const s=new qg(this.weightMap,a,r,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,s,t,n);const o=t.map((e=>Ym(e,this.tensorsMap,s))),i=o.map((e=>e.id)),c=Object.keys(e).map((t=>e[t].id));return this.keepIds=new Set([...i,...c,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),null==this.parent&&s.dispose(this.keepIds),o}async executeFunctionAsync(e,t,n){const a=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(a,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,a){const r=Object.keys(e),s=r.map((e=>this.graph.nodes[Jm(e)[0]])),o=n.map((e=>Jm(e)[0]));let i=o.map((e=>this.graph.nodes[e]));0===i.length&&(i=this._outputs);const{usedNodes:c,missingInputs:l,dynamicNode:u,syncInputs:h}=Xg(e,i,this.weightMap,this._initNodes),d=[...s,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),p=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,a]=Jm(t),r=[];r[a]=e[t],p[n]=r}));const f={},m=this.getFrozenTensorIds(p),g={};for(;d.length>0;){const e=this.processStack(s,d,t,p,g,m,o,f,c);await Promise.all(e)}null!=u||a||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const y=i.filter((e=>!Jg(e)&&!Ym(e.name,p,t))).map((e=>e.name));if(y.length>0){let e="";throw null!=u&&(e="Alternatively, to avoid the dynamic ops, use model.execute() "+"and specify the inputs [".concat(h,"]")),new Error("Cannot compute the outputs [".concat(y,"] from the provided ")+"inputs [".concat(r,"]. Consider providing the following inputs: ")+"[".concat(l,"]. ").concat(e))}return p}processStack(e,t,n,a,r,s,o,i,c){const l=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let u="";if("Enter"===e.node.op&&Xm("isConstant",e.node,a,n)&&([u]=Zm(e.node.name,n)),null==a[e.node.name]){const h=Kg(e.node,a,n,this._resourceManager);u||([u]=Zm(e.node.name,n));const d=n.currentContext;on(h)?l.push(h.then((l=>(a[u]=l,n.currentContext=d,this.checkTensorForDisposal(u,e.node,a,n,s,o,i),this.processChildNodes(e.node,t,n,a,r,c),l)))):(a[u]=h,this.checkTensorForDisposal(u,e.node,a,n,s,o,i),this.processChildNodes(e.node,t,n,a,r,c))}else this.processChildNodes(e.node,t,n,a,r,c)}return l}processChildNodes(e,t,n,a,r,s){e.children.forEach((e=>{const[o]=Zm(e.name,n);!r[o]&&s.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!Ym(e,a,n)))&&(r[o]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!Ym(e,a,n)))&&(r[o]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const n=e[t],[a]=Jm(t),r=this.graph.nodes[a];if(r.attrParams.shape&&r.attrParams.shape.value){const e=r.attrParams.shape.value;Et(e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t)),(()=>"The shape of dict['".concat(r.name,"'] provided in ")+"model.execute(dict) must be [".concat(e,"], but was ")+"[".concat(n.shape,"]")))}r.attrParams.dtype&&r.attrParams.dtype.value&&Et(n.dtype===r.attrParams.dtype.value,(()=>"The dtype of dict['".concat(r.name,"'] provided in ")+"model.execute(dict) must be "+"".concat(r.attrParams.dtype.value,", but was ").concat(n.dtype)))}))}mapInputs(e){const t={};for(const n in e)if(null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[n]){t[this._signature.inputs[n].name]=e[n]}else t[n]=e[n];return t}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=Jm(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error("The dict provided in model.execute(dict) has "+"keys: [".concat(t,"] that are not part of graph"))}mapOutputs(e){return e.map((e=>{if(null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]){return this._signature.outputs[e].name}return e}),{})}checkOutputs(e){e.forEach((e=>{const[t]=Jm(e);if(!this.graph.nodes[t])throw new Error("The output '".concat(e,"' is not found in the graph"))}))}}class ny{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const ay="?tfjs-format=file",ry="model.json";class sy{constructor(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e;this.modelUrl=t,this.loadOptions=n,this.version="n/a",this.io=a,null==n&&(this.loadOptions={}),this.resourceManager=new ny}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error("Found more than one (".concat(t.length,") load handlers for ")+"URL '".concat([e],"'"));this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return on(e)?e.then((e=>this.loadSync(e))):this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let n=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const e=this.artifacts.userDefinedMetadata;null!=e.signature&&(n=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}this.signature=n,this.version="".concat(t.versions.producer,".").concat(t.versions.minConsumer);const a=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new ty(xg.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(a),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=xg.Instance.transformGraph(e.modelInitializer);this.initializer=new ty(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if("string"===typeof e){const t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error("Cannot find any save handlers for URL '".concat(e,"'"));if(t.length>1)throw new Error("Found more than one (".concat(t.length,") save handlers for ")+"URL '".concat(e,"'"));e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){const n=this.execute(e,this.outputNodes);if(this.structuredOutputKeys){const e={};return(n instanceof po?[n]:n).forEach(((t,n)=>e[this.structuredOutputKeys[n]]=t)),e}return n}normalizeInputs(e){if(!(e instanceof po)&&!Array.isArray(e))return e;if((e=Array.isArray(e)?e:[e]).length!==this.inputNodes.length)throw new Error("Input tensor count mismatch,"+"the graph model has ".concat(this.inputNodes.length," placeholders, ")+"while there are ".concat(e.length," input tensors."));return this.inputNodes.reduce(((t,n,a)=>(t[n]=e[a],t)),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function oy(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e;if(null==t)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==n&&(n={}),n.fromTFHub&&"string"===typeof t&&(t=function(e){e.endsWith("/")||(e+="/");return"".concat(e).concat(ry).concat(ay)}(t));const r=new sy(t,n,a);return await r.load(),r}var iy=function(e,t){return(iy=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(e,t)};function cy(e,t){function n(){this.constructor=e}iy(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}var ly=function(){return(ly=Object.assign||function(e){for(var t,n=1,a=arguments.length;n<a;n++)for(var r in t=arguments[n])Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e}).apply(this,arguments)};function uy(e,t,n,a){return new(n||(n=Promise))((function(r,s){function o(e){try{c(a.next(e))}catch(e){s(e)}}function i(e){try{c(a.throw(e))}catch(e){s(e)}}function c(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,i)}c((a=a.apply(e,t||[])).next())}))}function hy(e,t){var n,a,r,s,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return s={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function i(s){return function(i){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,a&&(r=2&s[0]?a.return:s[0]?a.throw||((r=a.return)&&r.call(a),0):a.next)&&!(r=r.call(a,s[1])).done)return r;switch(a=0,r&&(s=[2&s[0],r.value]),s[0]){case 0:case 1:r=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,a=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!((r=(r=o.trys).length>0&&r[r.length-1])||6!==s[0]&&2!==s[0])){o=0;continue}if(3===s[0]&&(!r||s[1]>r[0]&&s[1]<r[3])){o.label=s[1];break}if(6===s[0]&&o.label<r[1]){o.label=r[1],r=s;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(s);break}r[2]&&o.ops.pop(),o.trys.pop();continue}s=t.call(e,o)}catch(e){s=[6,e],a=0}finally{n=r=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,i])}}}var dy=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],py=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],fy={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},my={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},gy=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],yy=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]],by={runtime:"mediapipe",enableSmoothing:!0,modelType:"full"},vy=function(){function e(e){var t,n=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new xt.Pose({locateFile:function(t,n){return e.solutionPath?e.solutionPath.replace(/\/+$/,"")+"/"+t:n+"/"+t}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing||!0,selfieMode:this.selfieMode}),this.poseSolution.onResults((function(e){n.height=e.image.height,n.width=e.image.width,null==e.poseLandmarks?n.poses=[]:n.poses=[n.translateOutput(e.poseLandmarks,e.poseWorldLandmarks)]}))}return e.prototype.translateOutput=function(e,t){var n=this,a={keypoints:e.map((function(e,t){return{x:e.x*n.width,y:e.y*n.height,z:e.z,score:e.visibility,name:py[t]}}))};return null!=t&&(a.keypoints3D=t.map((function(e,t){return{x:e.x,y:e.y,z:e.z,score:e.visibility,name:py[t]}}))),a},e.prototype.estimatePoses=function(e,t,n){return uy(this,void 0,void 0,(function(){return hy(this,(function(a){switch(a.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),[4,this.poseSolution.send({image:e},n)];case 1:return a.sent(),[2,this.poses]}}))}))},e.prototype.dispose=function(){this.poseSolution.close()},e.prototype.reset=function(){this.poseSolution.reset()},e.prototype.initialize=function(){return this.poseSolution.initialize()},e}();function xy(e){return uy(this,void 0,void 0,(function(){var t,n;return hy(this,(function(a){switch(a.label){case 0:return t=function(e){if(null==e)return ly({},by);var t=ly({},e);return t.runtime="mediapipe",null==t.enableSmoothing&&(t.enableSmoothing=by.enableSmoothing),null==t.modelType&&(t.modelType=by.modelType),t}(e),[4,(n=new vy(t)).initialize()];case 1:return a.sent(),[2,n]}}))}))}function wy(e){return e instanceof po?{height:e.shape[0],width:e.shape[1]}:{height:e.height,width:e.width}}function ky(e){return e-2*Math.PI*Math.floor((e+Math.PI)/(2*Math.PI))}function Sy(e){return e instanceof po?e:Sc(e)}function Iy(e,t){Et(0!==e.width,(function(){return t+" width cannot be 0."})),Et(0!==e.height,(function(){return t+" height cannot be 0."}))}function Ny(e,t,n){var a=t.inputResolution,r=t.keepAspectRatio,s=wy(e),o=function(e,t){return t?{xCenter:t.xCenter*e.width,yCenter:t.yCenter*e.height,width:t.width*e.width,height:t.height*e.height,rotation:t.rotation}:{xCenter:.5*e.width,yCenter:.5*e.height,width:e.width,height:e.height,rotation:0}}(s,n),i=function(e,t,n){if(void 0===n&&(n=!1),!n)return{top:0,left:0,right:0,bottom:0};var a=t.height,r=t.width;Iy(t,"targetSize"),Iy(e,"roi");var s,o,i=a/r,c=e.height/e.width,l=0,u=0;return i>c?(s=e.width,o=e.width*i,u=(1-c/i)/2):(s=e.height/i,o=e.height,l=(1-i/c)/2),e.width=s,e.height=o,{top:u,left:l,right:l,bottom:u}}(o,a,r);return{imageTensor:Xc((function(){var t=Sy(e),n=Vd(function(e,t,n,a){Iy(a,"inputResolution");var r=1/t.width,s=1/t.height,o=e.xCenter,i=e.yCenter,c=Math.cos(e.rotation),l=Math.sin(e.rotation),u=e.width,h=e.height;return[1/a.width*u*c*1*r*t.width,1/a.height*-h*l*r*t.width,(-.5*u*c*1+.5*h*l+o)*r*t.width,1/a.width*u*l*1*s*t.height,1/a.height*h*c*s*t.height,(-.5*h*c-.5*u*l*1+i)*s*t.height,0,0]}(o,s,0,a),[1,8]);return kf.transform(Hu(Xi(t,"float32")),n,"bilinear","nearest",0,[a.height,a.width])})),padding:i}}function Cy(e){return null!=e&&null!=e.currentTime}var Ty=function(){function e(e){this.alpha=e,this.initialized=!1}return e.prototype.apply=function(e,t){var n;return this.initialized?n=null==t?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(n=e,this.initialized=!0),this.rawValue=e,this.storedValue=n,n},e.prototype.applyWithAlpha=function(e,t,n){return this.alpha=t,this.apply(e,n)},e.prototype.hasLastRawValue=function(){return this.initialized},e.prototype.lastRawValue=function(){return this.rawValue},e.prototype.reset=function(){this.initialized=!1},e}(),Ey=function(){function e(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new Ty(this.getAlpha(this.minCutOff)),this.dx=new Ty(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return e.prototype.apply=function(e,t,n){if(null==e)return e;var a=Math.trunc(t);if(this.lastTimestamp>=a)return e;0!==this.lastTimestamp&&0!==a&&(this.frequency=1/(1e-6*(a-this.lastTimestamp))),this.lastTimestamp=a;var r=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*n*this.frequency:0,s=this.dx.applyWithAlpha(r,this.getAlpha(this.derivateCutOff)),o=this.minCutOff+this.beta*Math.abs(s),i=null!=this.thresholdCutOff?this.thresholdCutOff+this.thresholdBeta*Math.abs(s):null;return this.x.applyWithAlpha(e,this.getAlpha(o),i)},e.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},e}(),Ry=function(){function e(e){this.config=e}return e.prototype.apply=function(e,t,n){var a=this;if(null==e)return this.reset(),null;this.initializeFiltersIfEmpty(e);var r=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return e.slice();r=1/n}return e.map((function(e,n){var s=ly({},e,{x:a.xFilters[n].apply(e.x,t,r),y:a.yFilters[n].apply(e.y,t,r)});return null!=e.z&&(s.z=a.zFilters[n].apply(e.z,t,r)),s}))},e.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},e.prototype.initializeFiltersIfEmpty=function(e){var t=this;null!=this.xFilters&&this.xFilters.length===e.length||(this.xFilters=e.map((function(e){return new Ey(t.config)})),this.yFilters=e.map((function(e){return new Ey(t.config)})),this.zFilters=e.map((function(e){return new Ey(t.config)})))},e}();function Ay(e,t){return e.map((function(e){var n=ly({},e,{x:e.x/t.width,y:e.y/t.height});return null!=e.z&&(e.z=e.z/t.width),n}))}var _y=function(){function e(e){this.config=e,this.window=[],this.lowPassFilter=new Ty(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return e.prototype.apply=function(e,t,n){if(null==e)return e;var a,r=Math.trunc(t);if(this.lastTimestamp>=r)return e;if(-1===this.lastTimestamp)a=1;else{for(var s=e*n-this.lastValue*this.lastValueScale,o=r-this.lastTimestamp,i=s,c=o,l=(1+this.window.length)*(1e6/30),u=0,h=this.window;u<h.length;u++){var d=h[u];if(c+d.duration>l)break;i+=d.distance,c+=d.duration}var p=i/(1e-6*c);a=1-1/(1+this.config.velocityScale*Math.abs(p)),this.window.unshift({distance:s,duration:o}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=n,this.lastTimestamp=r,this.lowPassFilter.applyWithAlpha(e,a)},e}(),Fy=function(){function e(e){this.config=e}return e.prototype.apply=function(e,t,n){var a=this;if(null==e)return this.reset(),null;var r=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return e.slice();r=1/n}return this.initializeFiltersIfEmpty(e),e.map((function(e,n){var s=ly({},e,{x:a.xFilters[n].apply(e.x,t,r),y:a.yFilters[n].apply(e.y,t,r)});return null!=e.z&&(s.z=a.zFilters[n].apply(e.z,t,r)),s}))},e.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},e.prototype.initializeFiltersIfEmpty=function(e){var t=this;null!=this.xFilters&&this.xFilters.length===e.length||(this.xFilters=e.map((function(e){return new _y(t.config)})),this.yFilters=e.map((function(e){return new _y(t.config)})),this.zFilters=e.map((function(e){return new _y(t.config)})))},e}();function Oy(e,t){return e.map((function(e){var n=ly({},e,{x:e.x*t.width,y:e.y*t.height});return null!=e.z&&(n.z=e.z*t.width),n}))}var Dy=function(){function e(e){if(null!=e.velocityFilter)this.keypointsFilter=new Fy(e.velocityFilter);else{if(null==e.oneEuroFilter)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+e+".");this.keypointsFilter=new Ry(e.oneEuroFilter)}}return e.prototype.apply=function(e,t,n,a,r){if(void 0===a&&(a=!1),null==e)return this.keypointsFilter.reset(),null;var s=null!=r?function(e,t){return(e.width*t.width+e.height*t.height)/2}(r,n):1,o=a?Oy(e,n):e,i=this.keypointsFilter.apply(o,t,s);return a?Ay(i,n):i},e}();function My(e,t){var n=function(e,t,n,a){var r=(a-n)/255;return{scale:r,offset:n-0*r}}(0,0,t[0],t[1]);return Xc((function(){return sl(Ml(e,n.scale),n.offset)}))}function Ly(e,t,n){var a=n.rotationVectorStartKeypointIndex,r=n.rotationVectorEndKeypointIndex,s=e.locationData,o=s.relativeKeypoints[a].x*t.width,i=s.relativeKeypoints[a].y*t.height,c=s.relativeKeypoints[r].x*t.width,l=s.relativeKeypoints[r].y*t.height,u=2*Math.sqrt((c-o)*(c-o)+(l-i)*(l-i)),h=function(e,t,n){var a,r=e.locationData,s=n.rotationVectorStartKeypointIndex,o=n.rotationVectorEndKeypointIndex;a=n.rotationVectorTargetAngle?n.rotationVectorTargetAngle:Math.PI*n.rotationVectorTargetAngleDegree/180;var i=r.relativeKeypoints[s].x*t.width,c=r.relativeKeypoints[s].y*t.height,l=r.relativeKeypoints[o].x*t.width,u=r.relativeKeypoints[o].y*t.height;return ky(a-Math.atan2(-(u-c),l-i))}(e,t,n);return{xCenter:o/t.width,yCenter:i/t.height,width:u/t.width,height:u/t.height,rotation:h}}function Py(e,t,n,a){return 1===a?.5*(e+t):e+(t-e)*n/(a-1)}function zy(e){for(var t={locationData:{relativeKeypoints:[]}},n=Number.MAX_SAFE_INTEGER,a=Number.MIN_SAFE_INTEGER,r=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER,o=0;o<e.length;++o){var i=e[o];n=Math.min(n,i.x),a=Math.max(a,i.x),r=Math.min(r,i.y),s=Math.max(s,i.y),t.locationData.relativeKeypoints.push({x:i.x,y:i.y})}return t.locationData.relativeBoundingBox={xMin:n,yMin:r,xMax:a,yMax:s,width:a-n,height:s-r},t}function By(e,t,n,a){return uy(this,void 0,void 0,(function(){var r,s,o,i,c;return hy(this,(function(l){switch(l.label){case 0:return r=Vd(e.map((function(e){return[e.locationData.relativeBoundingBox.yMin,e.locationData.relativeBoundingBox.xMin,e.locationData.relativeBoundingBox.yMax,e.locationData.relativeBoundingBox.xMax]}))),s=Ud(e.map((function(e){return e.score[0]}))),[4,kf.nonMaxSuppressionAsync(r,s,t,n,a)];case 1:return[4,(o=l.sent()).array()];case 2:return i=l.sent(),c=e.filter((function(e,t){return i.indexOf(t)>-1})),Yc([r,s,o]),[2,c]}}))}))}function Wy(e,t,n){return uy(this,void 0,void 0,(function(){var a,r,s,o,i,c,l,u,h,d,p,f,m,g,y,b,v,x,w,k,S,I,N,C;return hy(this,(function(T){switch(T.label){case 0:if(a=Ld(t,[0]),r=a.shape,s=r[0],o=r[1],i=r[2],e.length!==i)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+e.length+", heatmap length: "+i);return c=[],[4,a.buffer()];case 1:for(l=T.sent(),u=0;u<e.length;u++)if(h=e[u],d=ly({},h),c.push(d),p=Math.trunc(d.x*o),f=Math.trunc(d.y*s),!(p<0||p>=o||f<0||p>=s)){for(m=Math.trunc((n.kernelSize-1)/2),g=Math.max(0,p-m),y=Math.min(o,p+m+1),b=Math.max(0,f-m),v=Math.min(s,f+m+1),x=0,w=0,k=0,S=0,I=b;I<v;++I)for(N=g;N<y;++N)C=l.get(I,N,u),x+=C,S=Math.max(S,C),w+=N*C,k+=I*C;S>=n.minConfidenceToRefine&&x>0&&(d.x=w/o/x,d.y=k/s/x)}return a.dispose(),[2,c]}}))}))}function Uy(e,t,n){return uy(this,void 0,void 0,(function(){var a,r,s,o,i;return hy(this,(function(c){switch(c.label){case 0:return a=e[0],r=e[1],s=function(e,t,n){return Xc((function(){var a,r,s,o;n.reverseOutputOrder?(r=Ld(Pl(e,[0,n.boxCoordOffset+0],[-1,1])),a=Ld(Pl(e,[0,n.boxCoordOffset+1],[-1,1])),o=Ld(Pl(e,[0,n.boxCoordOffset+2],[-1,1])),s=Ld(Pl(e,[0,n.boxCoordOffset+3],[-1,1]))):(a=Ld(Pl(e,[0,n.boxCoordOffset+0],[-1,1])),r=Ld(Pl(e,[0,n.boxCoordOffset+1],[-1,1])),s=Ld(Pl(e,[0,n.boxCoordOffset+2],[-1,1])),o=Ld(Pl(e,[0,n.boxCoordOffset+3],[-1,1]))),r=sl(Ml(bu(r,n.xScale),t.w),t.x),a=sl(Ml(bu(a,n.yScale),t.h),t.y),n.applyExponentialOnBoxSize?(s=Ml(ju(bu(s,n.hScale)),t.h),o=Ml(ju(bu(o,n.wScale)),t.w)):(s=Ml(bu(s,n.hScale),t.h),o=Ml(bu(o,n.wScale),t.h));var i=ph(a,bu(s,2)),c=ph(r,bu(o,2)),l=sl(a,bu(s,2)),u=sl(r,bu(o,2)),h=Ol([Al(i,[n.numBoxes,1]),Al(c,[n.numBoxes,1]),Al(l,[n.numBoxes,1]),Al(u,[n.numBoxes,1])],1);if(n.numKeypoints)for(var d=0;d<n.numKeypoints;++d){var p=n.keypointCoordOffset+d*n.numValuesPerKeypoint,f=void 0,m=void 0;n.reverseOutputOrder?(f=Ld(Pl(e,[0,p],[-1,1])),m=Ld(Pl(e,[0,p+1],[-1,1]))):(m=Ld(Pl(e,[0,p],[-1,1])),f=Ld(Pl(e,[0,p+1],[-1,1])));var g=sl(Ml(bu(f,n.xScale),t.w),t.x),y=sl(Ml(bu(m,n.yScale),t.h),t.y);h=Ol([h,Al(g,[n.numBoxes,1]),Al(y,[n.numBoxes,1])],1)}return h}))}(r,t,n),o=Xc((function(){var e=a;return n.sigmoidScore?(null!=n.scoreClippingThresh&&(e=Zl(a,-n.scoreClippingThresh,n.scoreClippingThresh)),e=Ll(e)):e})),[4,Vy(s,o,n)];case 1:return i=c.sent(),Yc([s,o]),[2,i]}}))}))}function Vy(e,t,n){return uy(this,void 0,void 0,(function(){var a,r,s,o,i,c,l,u,h,d,p,f;return hy(this,(function(m){switch(m.label){case 0:return a=[],[4,e.data()];case 1:return r=m.sent(),[4,t.data()];case 2:for(s=m.sent(),o=0;o<n.numBoxes;++o)if(!(null!=n.minScoreThresh&&s[o]<n.minScoreThresh||(i=o*n.numCoords,c=Gy(r[i+0],r[i+1],r[i+2],r[i+3],s[o],n.flipVertically,o),(l=c.locationData.relativeBoundingBox).width<0||l.height<0))){if(n.numKeypoints>0)for((u=c.locationData).relativeKeypoints=[],h=n.numKeypoints*n.numValuesPerKeypoint,d=0;d<h;d+=n.numValuesPerKeypoint)p=i+n.keypointCoordOffset+d,f={x:r[p+0],y:n.flipVertically?1-r[p+1]:r[p+1]},u.relativeKeypoints.push(f);a.push(c)}return[2,a]}}))}))}function Gy(e,t,n,a,r,s,o){return{score:[r],ind:o,locationData:{relativeBoundingBox:{xMin:t,yMin:s?1-n:e,xMax:a,yMax:s?1-e:n,width:a-t,height:n-e}}}}function jy(e,t,n,a){return void 0===n&&(n=!1),void 0===a&&(a=!1),uy(this,void 0,void 0,(function(){var r,s,o,i,c,l,u,h;return hy(this,(function(d){switch(d.label){case 0:return r=e.size,s=r/t.numLandmarks,[4,e.data()];case 1:for(o=d.sent(),i=[],c=0;c<t.numLandmarks;++c)l=c*s,(h={x:0,y:0}).x=n?t.inputImageWidth-o[l]:o[l],s>1&&(h.y=a?t.inputImageHeight-o[l+1]:o[l+1]),s>2&&(h.z=o[l+2]),s>3&&(h.score=(p=o[l+3],1/(1+Math.exp(-p)))),i.push(h);for(u=0;u<i.length;++u)(h=i[u]).x=h.x/t.inputImageWidth,h.y=h.y/t.inputImageHeight,h.z=h.z/t.inputImageWidth/(t.normalizeZ||1);return[2,i]}var p}))}))}function Hy(e,t,n){var a=e.width,r=e.height,s=e.rotation;if(null==n.rotation&&null==n.rotationDegree||(s=function(e,t){return null!=t.rotation?e+=t.rotation:null!=t.rotationDegree&&(e+=Math.PI*t.rotationDegree/180),ky(e)}(s,n)),0===s)e.xCenter=e.xCenter+a*n.shiftX,e.yCenter=e.yCenter+r*n.shiftY;else{var o=(t.width*a*n.shiftX*Math.cos(s)-t.height*r*n.shiftY*Math.sin(s))/t.width,i=(t.width*a*n.shiftX*Math.sin(s)+t.height*r*n.shiftY*Math.cos(s))/t.height;e.xCenter=e.xCenter+o,e.yCenter=e.yCenter+i}if(n.squareLong){var c=Math.max(a*t.width,r*t.height);a=c/t.width,r=c/t.height}else if(n.squareShort){var l=Math.min(a*t.width,r*t.height);a=l/t.width,r=l/t.height}return e.width=a*n.scaleX,e.height=r*n.scaleY,e}var Ky=function(){function e(e){this.alpha=e.alpha}return e.prototype.apply=function(e){var t=this;if(null==e)return this.visibilityFilters=null,null;null!=this.visibilityFilters&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map((function(e){return new Ty(t.alpha)})));for(var n=[],a=0;a<e.length;++a){var r=e[a],s=ly({},r);s.score=this.visibilityFilters[a].apply(r.score),n.push(s)}return n},e}(),qy={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},Xy={runtime:"tfjs",modelType:"full",enableSmoothing:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/1"},Yy={maxPoses:1,flipHorizontal:!1},Zy={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},Qy={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},Jy={inputResolution:{width:224,height:224},keepAspectRatio:!0},$y={inputResolution:{width:256,height:256},keepAspectRatio:!0},eb={numLandmarks:39,inputImageWidth:256,inputImageHeight:256},tb={numLandmarks:39,inputImageWidth:1,inputImageHeight:1},nb={kernelSize:7,minConfidenceToRefine:.5},ab={alpha:.1},rb={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},sb={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},ob={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},ib=function(){function e(e,t,n,a){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=n,this.modelType=a,this.regionOfInterest=null,this.anchors=function(e){for(var t=[],n=0;n<e.numLayers;){for(var a=[],r=[],s=[],o=[],i=n;i<e.strides.length&&e.strides[i]===e.strides[n];){var c=Py(e.minScale,e.maxScale,i,e.strides.length);if(0===i&&e.reduceBoxesInLowestLayer)s.push(1),s.push(2),s.push(.5),o.push(.1),o.push(c),o.push(c);else{for(var l=0;l<e.aspectRatios.length;++l)s.push(e.aspectRatios[l]),o.push(c);if(e.interpolatedScaleAspectRatio>0){var u=i===e.strides.length-1?1:Py(e.minScale,e.maxScale,i+1,e.strides.length);o.push(Math.sqrt(c*u)),s.push(e.interpolatedScaleAspectRatio)}}i++}for(var h=0;h<s.length;++h){var d=Math.sqrt(s[h]);a.push(o[h]/d),r.push(o[h]*d)}var p=0,f=0;if(e.featureMapHeight.length>0)p=e.featureMapHeight[n],f=e.featureMapWidth[n];else{var m=e.strides[n];p=Math.ceil(e.inputSizeHeight/m),f=Math.ceil(e.inputSizeWidth/m)}for(var g=0;g<p;++g)for(var y=0;y<f;++y)for(var b=0;b<a.length;++b){var v={xCenter:(y+e.anchorOffsetX)/f,yCenter:(g+e.anchorOffsetY)/p,width:0,height:0};e.fixedAnchorSize?(v.width=1,v.height=1):(v.width=r[b],v.height=a[b]),t.push(v)}n=i}return t}(qy);var r=Ud(this.anchors.map((function(e){return e.width}))),s=Ud(this.anchors.map((function(e){return e.height}))),o=Ud(this.anchors.map((function(e){return e.xCenter}))),i=Ud(this.anchors.map((function(e){return e.yCenter})));this.anchorTensor={x:o,y:i,w:r,h:s}}return e.prototype.estimatePoses=function(e,t,n){return uy(this,void 0,void 0,(function(){var a,r,s,o,i,c,l,u,h,d,p,f,m,g,y,b,v,x;return hy(this,(function(w){switch(w.label){case 0:return a=function(e){var t;if(null==(t=null==e?Yy:ly({},e)).maxPoses&&(t.maxPoses=1),t.maxPoses<=0)throw new Error("Invalid maxPoses "+t.maxPoses+". Should be > 0.");if(t.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return t}(t),null==e?(this.reset(),[2,[]]):(this.maxPoses=a.maxPoses,this.timestamp=null!=n?1e3*n:Cy(e)?1e6*e.currentTime:null,r=wy(e),s=Xc((function(){return Xi(Sy(e),"float32")})),null!=(o=this.regionOfInterest)?[3,2]:[4,this.detectPose(s)]);case 1:if(0===(i=w.sent()).length)return this.reset(),s.dispose(),[2,[]];c=i[0],o=this.poseDetectionToRoi(c,r),w.label=2;case 2:return[4,this.poseLandmarksByRoi(o,s)];case 3:return l=w.sent(),s.dispose(),null==l?(this.reset(),[2,[]]):(u=l.actualLandmarks,h=l.auxiliaryLandmarks,d=l.poseScore,p=l.actualWorldLandmarks,f=this.poseLandmarkFiltering(u,h,p,r),m=f.actualLandmarksFiltered,g=f.auxiliaryLandmarksFiltered,y=f.actualWorldLandmarksFiltered,b=this.poseLandmarksToRoi(g,r),this.regionOfInterest=b,null!=(v=null!=m?Oy(m,r):null)&&v.forEach((function(e,t){e.name=py[t]})),null!=(x=y)&&x.forEach((function(e,t){e.name=py[t]})),[2,[{score:d,keypoints:v,keypoints3D:x}]])}}))}))},e.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),Yc([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h])},e.prototype.reset=function(){this.regionOfInterest=null,this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},e.prototype.detectPose=function(e){return uy(this,void 0,void 0,(function(){var t,n,a,r,s,o,i,c,l;return hy(this,(function(u){switch(u.label){case 0:return t=Ny(e,Jy),n=t.imageTensor,a=t.padding,r=My(n,[-1,1]),s=function(e,t){return Xc((function(){var n=function(e){return Xc((function(){var t=Pl(e,[0,0,0],[1,-1,1]);return[Ll(t),Pl(e,[0,0,1],[1,-1,-1])]}))}(t.predict(e)),a=n[0],r=n[1];return{boxes:Ld(r),scores:Ld(a)}}))}(r,this.detectorModel),o=s.boxes,[4,Uy([i=s.scores,o],this.anchorTensor,Zy)];case 1:return[4,By(u.sent(),this.maxPoses,.3,-1)];case 2:return c=u.sent(),l=function(e,t){void 0===e&&(e=[]);for(var n=t.left,a=t.top,r=t.left+t.right,s=t.top+t.bottom,o=0;o<e.length;o++){var i=e[o],c=i.locationData.relativeBoundingBox,l=(c.xMin-n)/(1-r),u=(c.yMin-a)/(1-s),h=c.width/(1-r),d=c.height/(1-s);c.xMin=l,c.yMin=u,c.width=h,c.height=d;for(var p=0;p<i.locationData.relativeKeypoints.length;++p){var f=i.locationData.relativeKeypoints[p],m=(f.x-n)/(1-r),g=(f.y-a)/(1-s);f.x=m,f.y=g}}return e}(c,a),Yc([n,r,i,o]),[2,l]}}))}))},e.prototype.poseDetectionToRoi=function(e,t){return Hy(Ly(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,Qy)},e.prototype.poseLandmarksByRoi=function(e,t){return uy(this,void 0,void 0,(function(){var n,a,r,s,o,i,c,l,u,h,d,p,f,m,g,y,b,v,x,w;return hy(this,(function(k){switch(k.label){case 0:if(n=Ny(t,$y,e),a=n.imageTensor,r=n.padding,s=My(a,[0,1]),"lite"!==this.modelType&&"full"!==this.modelType&&"heavy"!==this.modelType)throw new Error("Model type must be one of lite, full or heavy,but got "+this.modelType);return o=this.landmarkModel.execute(s,["ld_3d","output_poseflag","activation_heatmap","world_3d"]),i=o[0],c=o[1],l=o[2],u=o[3],[4,c.data()];case 1:return(h=k.sent()[0])<.5?(Yc(o),Yc([a,s]),[2,null]):[4,jy(i,eb)];case 2:return[4,Wy(d=k.sent(),l,nb)];case 3:return p=k.sent(),f=function(e,t){var n=t.left,a=t.top,r=t.left+t.right,s=t.top+t.bottom;return e.map((function(e){return ly({},e,{x:(e.x-n)/(1-r),y:(e.y-a)/(1-s),z:e.z/(1-r)})}))}(p,r),m=function(e,t,n){void 0===n&&(n={ignoreRotation:!1});for(var a=[],r=0,s=e;r<s.length;r++){var o=s[r],i=o.x-.5,c=o.y-.5,l=n.ignoreRotation?0:t.rotation,u=Math.cos(l)*i-Math.sin(l)*c,h=Math.sin(l)*i+Math.cos(l)*c;u=u*t.width+t.xCenter,h=h*t.height+t.yCenter;var d=o.z*t.width,p=ly({},o);p.x=u,p.y=h,p.z=d,a.push(p)}return a}(f,e),g=m.slice(0,33),y=m.slice(33,35),[4,jy(u,tb)];case 4:return b=k.sent(),v=function(e,t,n){void 0===n&&(n=!0);for(var a=[],r=0;r<e.length;r++){var s=ly({},t[r]);n&&(s.score=e[r].score),a.push(s)}return a}(d,b,!0),x=function(e,t){for(var n=[],a=0,r=e;a<r.length;a++){var s=r[a],o=s.x,i=s.y,c=t.rotation,l=Math.cos(c)*o-Math.sin(c)*i,u=Math.sin(c)*o+Math.cos(c)*i,h=ly({},s);h.x=l,h.y=u,n.push(h)}return n}(v,e),w=x.slice(0,33),Yc(o),Yc([a,s]),[2,{actualLandmarks:g,auxiliaryLandmarks:y,poseScore:h,actualWorldLandmarks:w}]}}))}))},e.prototype.poseLandmarksToRoi=function(e,t){return Hy(Ly(zy(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,Qy)},e.prototype.poseLandmarkFiltering=function(e,t,n,a){var r,s,o;if(null!=this.timestamp&&this.enableSmoothing){var i=Ly(zy(t),a,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});null==this.visibilitySmoothingFilterActual&&(this.visibilitySmoothingFilterActual=new Ky(ab)),r=this.visibilitySmoothingFilterActual.apply(e),null==this.visibilitySmoothingFilterAuxiliary&&(this.visibilitySmoothingFilterAuxiliary=new Ky(ab)),s=this.visibilitySmoothingFilterAuxiliary.apply(t),o=this.visibilitySmoothingFilterActual.apply(n),null==this.landmarksSmoothingFilterActual&&(this.landmarksSmoothingFilterActual=new Dy(rb)),r=this.landmarksSmoothingFilterActual.apply(r,this.timestamp,a,!0,i),null==this.landmarksSmoothingFilterAuxiliary&&(this.landmarksSmoothingFilterAuxiliary=new Dy(sb)),s=this.landmarksSmoothingFilterAuxiliary.apply(s,this.timestamp,a,!0,i),null==this.worldLandmarksSmoothingFilterActual&&(this.worldLandmarksSmoothingFilterActual=new Dy(ob)),o=this.worldLandmarksSmoothingFilterActual.apply(n,this.timestamp)}else r=e,s=t,o=n;return{actualLandmarksFiltered:r,auxiliaryLandmarksFiltered:s,actualWorldLandmarksFiltered:o}},e}();function cb(e){return uy(this,void 0,void 0,(function(){var t,n,a,r,s,o;return hy(this,(function(i){switch(i.label){case 0:return t=function(e){var t=ly({},null==e?Xy:e);if(null==t.enableSmoothing&&(t.enableSmoothing=Xy.enableSmoothing),null==t.modelType&&(t.modelType=Xy.modelType),null==t.detectorModelUrl&&(t.detectorModelUrl=Xy.detectorModelUrl),null==t.landmarkModelUrl)switch(t.modelType){case"lite":t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/1";break;case"heavy":t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/1";break;default:t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/1"}return t}(e),n=t.detectorModelUrl.indexOf("https://tfhub.dev")>-1,a=t.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([oy(t.detectorModelUrl,{fromTFHub:n}),oy(t.landmarkModelUrl,{fromTFHub:a})])];case 1:return r=i.sent(),s=r[0],o=r[1],[2,new ib(s,o,t.enableSmoothing,t.modelType)]}}))}))}var lb,ub,hb,db=function(){function e(e){!function(e){if(e.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but encountered "+e.maxTracks);if(e.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but encountered "+e.maxAge);if(void 0!==e.keypointTrackerParams){if(e.keypointTrackerParams.keypointConfidenceThreshold<0||e.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+e.keypointTrackerParams.keypointConfidenceThreshold);if(e.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but encountered "+e.keypointTrackerParams.minNumberOfKeypoints);for(var t=0,n=e.keypointTrackerParams.keypointFalloff;t<n.length;t++){var a=n[t];if(a<=0)throw new Error("Must specify each keypoint falloff parameterto be positive but encountered "+a)}}}(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return e.prototype.apply=function(e,t){this.filterOldTracks(t);var n=this.computeSimilarity(e);return this.assignTracks(e,n,t),this.updateTracks(t),e},e.prototype.getTracks=function(){return this.tracks.slice()},e.prototype.getTrackIDs=function(){return new Set(this.tracks.map((function(e){return e.id})))},e.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter((function(n){return e-n.lastTimestamp<=t.maxAge}))},e.prototype.assignTracks=function(e,t,n){for(var a=Array.from(Array(t[0].length).keys()),r=[],s=0,o=Array.from(Array(e.length).keys());s<o.length;s++){var i=o[s];if(0!==a.length){for(var c=-1,l=-1,u=0,h=a;u<h.length;u++){var d=h[u],p=t[i][d];p>=this.minSimilarity&&p>l&&(c=d,l=p)}if(c>=0){var f=this.tracks[c];f=Object.assign(f,this.createTrack(e[i],n,f.id)),e[i].id=f.id;var m=a.indexOf(c);a.splice(m,1)}else r.push(i)}else r.push(i)}for(var g=0,y=r;g<y.length;g++){i=y[g];var b=this.createTrack(e[i],n);this.tracks.push(b),e[i].id=b.id}},e.prototype.updateTracks=function(e){this.tracks.sort((function(e,t){return t.lastTimestamp-e.lastTimestamp})),this.tracks=this.tracks.slice(0,this.maxTracks)},e.prototype.createTrack=function(e,t,n){var a={id:n||this.nextTrackID(),lastTimestamp:t,keypoints:e.keypoints.slice().map((function(e){return ly({},e)}))};return void 0!==e.box&&(a.box=ly({},e.box)),a},e.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},e.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter((function(t){return!e.includes(t.id)}))},e.prototype.reset=function(){this.tracks=[]},e}(),pb=function(e){function t(t){return e.call(this,t)||this}return cy(t,e),t.prototype.computeSimilarity=function(e){var t=this;return 0===e.length||0===this.tracks.length?[[]]:e.map((function(e){return t.tracks.map((function(n){return t.iou(e,n)}))}))},t.prototype.iou=function(e,t){var n=Math.max(e.box.xMin,t.box.xMin),a=Math.max(e.box.yMin,t.box.yMin),r=Math.min(e.box.xMax,t.box.xMax),s=Math.min(e.box.yMax,t.box.yMax);if(n>=r||a>=s)return 0;var o=(r-n)*(s-a);return o/(e.box.width*e.box.height+t.box.width*t.box.height-o)},t}(db),fb=function(e){function t(t){var n=e.call(this,t)||this;return n.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,n.keypointFalloff=t.keypointTrackerParams.keypointFalloff,n.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,n}return cy(t,e),t.prototype.computeSimilarity=function(e){if(0===e.length||0===this.tracks.length)return[[]];for(var t=[],n=0,a=e;n<a.length;n++){for(var r=a[n],s=[],o=0,i=this.tracks;o<i.length;o++){var c=i[o];s.push(this.oks(r,c))}t.push(s)}return t},t.prototype.oks=function(e,t){for(var n=this.area(t.keypoints)+1e-6,a=0,r=0,s=0;s<e.keypoints.length;++s){var o=e.keypoints[s],i=t.keypoints[s];if(!(o.score<this.keypointThreshold||i.score<this.keypointThreshold)){r+=1;var c=Math.pow(o.x-i.x,2)+Math.pow(o.y-i.y,2),l=2*this.keypointFalloff[s];a+=Math.exp(-1*c/(2*n*Math.pow(l,2)))}}return r<this.minNumKeyoints?0:a/r},t.prototype.area=function(e){var t=this,n=e.filter((function(e){return e.score>t.keypointThreshold})),a=Math.min.apply(Math,[1].concat(n.map((function(e){return e.x})))),r=Math.max.apply(Math,[0].concat(n.map((function(e){return e.x})))),s=Math.min.apply(Math,[1].concat(n.map((function(e){return e.y}))));return(r-a)*(Math.max.apply(Math,[0].concat(n.map((function(e){return e.y}))))-s)},t}(db);function mb(e){switch(e){case ub.BlazePose:return py.reduce((function(e,t,n){return e[t]=n,e}),{});case ub.PoseNet:case ub.MoveNet:return dy.reduce((function(e,t,n){return e[t]=n,e}),{});default:throw new Error("Model "+e+" is not supported.")}}(hb=lb||(lb={})).Keypoint="keypoint",hb.BoundingBox="boundingBox",function(e){e.MoveNet="MoveNet",e.BlazePose="BlazePose",e.PoseNet="PoseNet"}(ub||(ub={}));Object.freeze({__proto__:null,getKeypointIndexBySide:function(e){switch(e){case ub.BlazePose:return fy;case ub.PoseNet:case ub.MoveNet:return my;default:throw new Error("Model "+e+" is not supported.")}},getAdjacentPairs:function(e){switch(e){case ub.BlazePose:return yy;case ub.PoseNet:case ub.MoveNet:return gy;default:throw new Error("Model "+e+" is not supported.")}},getKeypointIndexByName:mb});var gb=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],yb={modelType:"SinglePose.Lightning",enableSmoothing:!0},bb={},vb={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},xb={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},wb={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function kb(e,t){var n,a,r,s;return e?t.width>t.height?(n=1,a=t.height/t.width,r=0,s=(t.width/2-t.height/2)/t.width):(n=t.width/t.height,a=1,r=(t.height/2-t.width/2)/t.height,s=0):t.width>t.height?(n=t.width/t.height,a=1,r=(t.height/2-t.width/2)/t.height,s=0):(n=1,a=t.height/t.width,r=0,s=(t.width/2-t.height/2)/t.width),{yMin:r,xMin:s,yMax:r+n,xMax:s+a,height:n,width:a}}function Sb(e,t){var n={maxTracks:e.maxTracks,maxAge:e.maxAge,minSimilarity:e.minSimilarity};return null!=t.maxTracks&&(n.maxTracks=t.maxTracks),null!=t.maxAge&&(n.maxAge=t.maxAge),null!=t.minSimilarity&&(n.minSimilarity=t.minSimilarity),n}var Ib=function(){function e(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=mb(ub.MoveNet),"SinglePose.Lightning"===t.modelType?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):"SinglePose.Thunder"===t.modelType&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel="MultiPose.Lightning"===t.modelType,this.multiPoseModel||(this.keypointFilter=new Ry(vb),this.cropRegionFilterYMin=new Ty(.9),this.cropRegionFilterXMin=new Ty(.9),this.cropRegionFilterYMax=new Ty(.9),this.cropRegionFilterXMax=new Ty(.9)),this.enableSmoothing=t.enableSmoothing,t.minPoseScore?this.minPoseScore=t.minPoseScore:this.minPoseScore=.25,t.multiPoseMaxDimension?this.multiPoseMaxDimension=t.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=t.enableTracking,this.multiPoseModel&&this.enableTracking&&(t.trackerType===lb.Keypoint?this.tracker=new fb(t.trackerConfig):t.trackerType===lb.BoundingBox&&(this.tracker=new pb(t.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return e.prototype.runSinglePersonPoseModel=function(e){return uy(this,void 0,void 0,(function(){var t,n,a,r,s;return hy(this,(function(o){switch(o.label){case 0:if(4!==(t=this.moveNetModel.execute(e)).shape.length||1!==t.shape[0]||1!==t.shape[1]||17!==t.shape[2]||3!==t.shape[3])throw t.dispose(),new Error("Unexpected output shape from model: ["+t.shape+"]");return"webgpu"===Qc()?[3,1]:(n=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:n=o.sent(),o.label=3;case 3:for(t.dispose(),a={keypoints:[],score:0},r=0,s=0;s<17;++s)a.keypoints[s]={y:n[3*s],x:n[3*s+1],score:n[3*s+2]},a.keypoints[s].score>.2&&(++r,a.score+=a.keypoints[s].score);return r>0&&(a.score/=r),[2,a]}}))}))},e.prototype.runMultiPersonPoseModel=function(e){return uy(this,void 0,void 0,(function(){var t,n,a,r,s,o,i,c;return hy(this,(function(l){switch(l.label){case 0:if(3!==(t=this.moveNetModel.execute(e)).shape.length||1!==t.shape[0]||56!==t.shape[2])throw t.dispose(),new Error("Unexpected output shape from model: ["+t.shape+"]");return"webgpu"===Qc()?[3,1]:(n=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:n=l.sent(),l.label=3;case 3:for(t.dispose(),a=[],r=n.length/56,s=0;s<r;++s)for(a[s]={keypoints:[]},o=56*s+51,a[s].box={yMin:n[o],xMin:n[o+1],yMax:n[o+2],xMax:n[o+3],width:n[o+3]-n[o+1],height:n[o+2]-n[o]},i=56*s+55,a[s].score=n[i],a[s].keypoints=[],c=0;c<17;++c)a[s].keypoints[c]={y:n[56*s+3*c],x:n[56*s+3*c+1],score:n[56*s+3*c+2]};return[2,a]}}))}))},e.prototype.estimatePoses=function(e,t,n){return void 0===t&&(t=bb),uy(this,void 0,void 0,(function(){var a,r,s,o,i,c;return hy(this,(function(l){switch(l.label){case 0:return t=function(e){return null==e?bb:ly({},e)}(t),null==e?(this.reset(),[2,[]]):(null==n?Cy(e)&&(n=1e6*e.currentTime):n*=1e3,a=Sy(e),r=wy(a),s=Hu(a,0),e instanceof po||a.dispose(),o=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(s,r,n)]);case 1:return o=l.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(s,r,n)];case 3:o=l.sent(),l.label=4;case 4:for(i=0;i<o.length;++i)for(c=0;c<o[i].keypoints.length;++c)o[i].keypoints[c].name=dy[c],o[i].keypoints[c].y*=r.height,o[i].keypoints[c].x*=r.width;return[2,o]}}))}))},e.prototype.estimateSinglePose=function(e,t,n){return uy(this,void 0,void 0,(function(){var a,r,s,o,i=this;return hy(this,(function(c){switch(c.label){case 0:return this.cropRegion||(this.cropRegion=kb(null==this.cropRegion,t)),a=Xc((function(){var t=Vd([[i.cropRegion.yMin,i.cropRegion.xMin,i.cropRegion.yMax,i.cropRegion.xMax]]),n=Eh([1],"int32"),a=[i.modelInputResolution.height,i.modelInputResolution.width];return Xi(kf.cropAndResize(e,t,n,a,"bilinear",0),"int32")})),e.dispose(),[4,this.runSinglePersonPoseModel(a)];case 1:if(r=c.sent(),a.dispose(),r.score<this.minPoseScore)return this.reset(),[2,[]];for(s=0;s<r.keypoints.length;++s)r.keypoints[s].y=this.cropRegion.yMin+r.keypoints[s].y*this.cropRegion.height,r.keypoints[s].x=this.cropRegion.xMin+r.keypoints[s].x*this.cropRegion.width;return null!=n&&this.enableSmoothing&&(r.keypoints=this.keypointFilter.apply(r.keypoints,n,1)),o=function(e,t,n,a){for(var r={},s=0,o=dy;s<o.length;s++){var i=o[s];r[i]=[t[n[i]].y*a.height,t[n[i]].x*a.width]}if(function(e,t){return(e[t.left_hip].score>.2||e[t.right_hip].score>.2)&&(e[t.left_shoulder].score>.2||e[t.right_shoulder].score>.2)}(t,n)){var c=(r.left_hip[0]+r.right_hip[0])/2,l=(r.left_hip[1]+r.right_hip[1])/2,u=function(e,t,n,a,r){for(var s=["left_shoulder","right_shoulder","left_hip","right_hip"],o=0,i=0,c=0;c<s.length;c++)(p=Math.abs(a-n[s[c]][0]))>o&&(o=p),(f=Math.abs(r-n[s[c]][1]))>i&&(i=f);for(var l=0,u=0,h=0,d=Object.keys(n);h<d.length;h++){var p,f,m=d[h];e[t[m]].score<.2||((p=Math.abs(a-n[m][0]))>l&&(l=p),(f=Math.abs(r-n[m][1]))>u&&(u=f))}return[o,i,l,u]}(t,n,r,c,l),h=u[0],d=u[1],p=u[2],f=u[3],m=Math.max(1.9*d,1.9*h,1.2*p,1.2*f),g=[c-(m=Math.min(m,Math.max(l,a.width-l,c,a.height-c))),l-m];if(m>Math.max(a.width,a.height)/2)return kb(null==e,a);var y=2*m;return{yMin:g[0]/a.height,xMin:g[1]/a.width,yMax:(g[0]+y)/a.height,xMax:(g[1]+y)/a.width,height:(g[0]+y)/a.height-g[0]/a.height,width:(g[1]+y)/a.width-g[1]/a.width}}return kb(null==e,a)}(this.cropRegion,r.keypoints,this.keypointIndexByName,t),this.cropRegion=this.filterCropRegion(o),[2,[r]]}}))}))},e.prototype.estimateMultiplePoses=function(e,t,n){return uy(this,void 0,void 0,(function(){var a,r,s,o,i,c,l,u,h,d,p,f=this;return hy(this,(function(m){switch(m.label){case 0:return t.width>t.height?(r=this.multiPoseMaxDimension,s=Math.round(this.multiPoseMaxDimension*t.height/t.width),a=kf.resizeBilinear(e,[s,r]),i=r,c=32*Math.ceil(s/32),o=Uh(a,[[0,0],[0,c-s],[0,0],[0,0]])):(r=Math.round(this.multiPoseMaxDimension*t.width/t.height),s=this.multiPoseMaxDimension,a=kf.resizeBilinear(e,[s,r]),i=32*Math.ceil(r/32),c=s,o=Uh(a,[[0,0],[0,0],[0,i-r],[0,0]])),a.dispose(),e.dispose(),l=Xi(o,"int32"),o.dispose(),[4,this.runMultiPersonPoseModel(l)];case 1:for(u=m.sent(),l.dispose(),u=u.filter((function(e){return e.score>=f.minPoseScore})),d=0;d<u.length;++d)for(h=0;h<u[d].keypoints.length;++h)u[d].keypoints[h].y*=c/s,u[d].keypoints[h].x*=i/r;if(this.enableTracking&&(this.tracker.apply(u,n),this.enableSmoothing)){for(d=0;d<u.length;++d)this.keypointFilterMap.has(u[d].id)||this.keypointFilterMap.set(u[d].id,new Ry(vb)),u[d].keypoints=this.keypointFilterMap.get(u[d].id).apply(u[d].keypoints,n,1);p=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach((function(e,t){p.has(t)||f.keypointFilterMap.delete(t)}))}return[2,u]}}))}))},e.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),n=this.cropRegionFilterXMin.apply(e.xMin),a=this.cropRegionFilterYMax.apply(e.yMax),r=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:n,yMax:a,xMax:r,height:a-t,width:r-n}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},e.prototype.dispose=function(){this.moveNetModel.dispose()},e.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},e.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},e}();function Nb(e){return void 0===e&&(e=yb),uy(this,void 0,void 0,(function(){var t,n,a,r;return hy(this,(function(s){switch(s.label){case 0:return t=function(e){var t,n=null==e?yb:ly({},e);if(null==n.modelType)n.modelType="SinglePose.Lightning";else if(gb.indexOf(n.modelType)<0)throw new Error("Invalid architecture "+n.modelType+". Should be one of "+gb);if(null==n.enableSmoothing&&(n.enableSmoothing=!0),null!=n.minPoseScore&&(n.minPoseScore<0||n.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(null!=n.multiPoseMaxDimension&&(n.multiPoseMaxDimension%32!=0||n.multiPoseMaxDimension<128||n.multiPoseMaxDimension>512))throw new Error("multiPoseResolution must be a multiple of 32 and between 128 and 512");if("MultiPose.Lightning"===n.modelType&&null==n.enableTracking&&(n.enableTracking=!0),"MultiPose.Lightning"===n.modelType&&!0===n.enableTracking)if(null==n.trackerType&&(n.trackerType=lb.BoundingBox),n.trackerType===lb.Keypoint)null!=n.trackerConfig?n.trackerConfig=function(e){var t=Sb(xb,e);return t.keypointTrackerParams=ly({},xb.keypointTrackerParams),null!=e.keypointTrackerParams&&(null!=e.keypointTrackerParams.keypointConfidenceThreshold&&(t.keypointTrackerParams.keypointConfidenceThreshold=e.keypointTrackerParams.keypointConfidenceThreshold),null!=e.keypointTrackerParams.keypointFalloff&&(t.keypointTrackerParams.keypointFalloff=e.keypointTrackerParams.keypointFalloff),null!=e.keypointTrackerParams.minNumberOfKeypoints&&(t.keypointTrackerParams.minNumberOfKeypoints=e.keypointTrackerParams.minNumberOfKeypoints)),t}(n.trackerConfig):n.trackerConfig=xb;else{if(n.trackerType!==lb.BoundingBox)throw new Error("Tracker type not supported by MoveNet");null!=n.trackerConfig?n.trackerConfig=(t=n.trackerConfig,Sb(wb,t)):n.trackerConfig=wb}return n}(e),a=!0,t.modelUrl?(a=t.modelUrl.indexOf("https://tfhub.dev")>-1,[4,oy(t.modelUrl,{fromTFHub:a})]):[3,2];case 1:return n=s.sent(),[3,4];case 2:return r=void 0,"SinglePose.Lightning"===t.modelType?r="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":"SinglePose.Thunder"===t.modelType?r="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":"MultiPose.Lightning"===t.modelType&&(r="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,oy(r,{fromTFHub:a})];case 3:n=s.sent(),s.label=4;case 4:return"webgl"===Qc()&&hn().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new Ib(n,t)]}}))}))}var Cb={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},Tb=["MobileNetV1","ResNet50"],Eb={MobileNetV1:[8,16],ResNet50:[16]},Rb=[8,16,32],Ab={MobileNetV1:[.5,.75,1],ResNet50:[1]},_b=[1,2,4],Fb={maxPoses:1,flipHorizontal:!1},Ob={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},Db=[-123.15,-115.9,-103.06];function Mb(e){return Math.floor(e/2)}var Lb=function(){function e(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return e.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},e.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},e.prototype.empty=function(){return-1===this.numberOfElements},e.prototype.size=function(){return this.numberOfElements+1},e.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},e.prototype.max=function(){return this.priorityQueue[0]},e.prototype.swim=function(e){for(;e>0&&this.less(Mb(e),e);)this.exchange(e,Mb(e)),e=Mb(e)},e.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},e.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},e.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},e.prototype.exchange=function(e,t){var n=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=n},e}();function Pb(e,t,n,a,r,s){for(var o=s.shape,i=o[0],c=o[1],l=!0,u=Math.max(n-r,0),h=Math.min(n+r+1,i),d=u;d<h;++d){for(var p=Math.max(a-r,0),f=Math.min(a+r+1,c),m=p;m<f;++m)if(s.get(d,m,e)>t){l=!1;break}if(!l)break}return l}function zb(e){return uy(this,void 0,void 0,(function(){return hy(this,(function(t){return[2,Promise.all(e.map((function(e){return e.buffer()})))]}))}))}function Bb(e,t,n,a){return{y:a.get(e,t,n),x:a.get(e,t,n+17)}}function Wb(e,t,n){var a=Bb(e.heatmapY,e.heatmapX,e.id,n),r=a.y,s=a.x;return{x:e.heatmapX*t+s,y:e.heatmapY*t+r}}function Ub(e,t,n,a){var r=n.x,s=n.y;return e.some((function(e){var n,o,i,c,l=e.keypoints;return n=s,o=r,(i=l[a].y-n)*i+(c=l[a].x-o)*c<=t}))}var Vb=dy.reduce((function(e,t,n){return e[t]=n,e}),{}),Gb=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map((function(e){var t=e[0],n=e[1];return[Vb[t],Vb[n]]})),jb=Gb.map((function(e){return e[1]})),Hb=Gb.map((function(e){return e[0]}));function Kb(e,t,n){return e<t?t:e>n?n:e}function qb(e,t,n,a){return{y:Kb(Math.round(e.y/t),0,n-1),x:Kb(Math.round(e.x/t),0,a-1)}}function Xb(e,t){return{x:e.x+t.x,y:e.y+t.y}}function Yb(e,t,n,a,r,s,o,i){void 0===i&&(i=2);for(var c=a.shape,l=c[0],u=c[1],h={y:t.y,x:t.x},d=Xb(h,function(e,t,n){var a=n.shape[2]/2;return{y:n.get(t.y,t.x,e),x:n.get(t.y,t.x,a+e)}}(e,qb(h,s,l,u),o)),p=0;p<i;p++){var f=qb(d,s,l,u),m=Bb(f.y,f.x,n,r);d=Xb({x:f.x*s,y:f.y*s},{x:m.x,y:m.y})}var g=qb(d,s,l,u),y=a.get(g.y,g.x,n);return{y:d.y,x:d.x,name:dy[n],score:y}}function Zb(e,t,n,a,r,s){var o=t.shape[2],i=jb.length,c=new Array(o),l=e.part,u=e.score,h=Wb(l,a,n);c[l.id]={score:u,name:dy[l.id],y:h.y,x:h.x};for(var d=i-1;d>=0;--d){var p=jb[d],f=Hb[d];c[p]&&!c[f]&&(c[f]=Yb(d,c[p],f,t,n,a,s))}for(d=0;d<i;++d)p=Hb[d],f=jb[d],c[p]&&!c[f]&&(c[f]=Yb(d,c[p],f,t,n,a,r));return c}function Qb(e,t,n){return n.reduce((function(n,a,r){var s=a.y,o=a.x,i=a.score;return Ub(e,t,{y:s,x:o},r)||(n+=i),n}),0)/n.length}function Jb(e,t,n,a,r,s,o,i){return void 0===o&&(o=.5),void 0===i&&(i=20),uy(this,void 0,void 0,(function(){var c,l,u,h,d,p,f,m,g,y,b,v;return hy(this,(function(x){switch(x.label){case 0:return[4,zb([e,t,n,a])];case 1:for(c=x.sent(),l=c[0],u=c[1],h=c[2],d=c[3],p=[],f=function(e,t,n){for(var a=n.shape,r=a[0],s=a[1],o=a[2],i=new Lb(r*s*o,(function(e){return e.score})),c=0;c<r;++c)for(var l=0;l<s;++l)for(var u=0;u<o;++u){var h=n.get(c,l,u);h<e||Pb(u,h,c,l,1,n)&&i.enqueue({score:h,part:{heatmapY:c,heatmapX:l,id:u}})}return i}(o,0,l),m=i*i;p.length<s&&!f.empty();)g=f.dequeue(),y=Wb(g.part,r,u),Ub(p,m,y,g.part.id)||(b=Zb(g,l,u,r,h,d),v=Qb(p,m,b),p.push({keypoints:b,score:v}));return[2,p]}}))}))}function $b(e,t,n){return Xc((function(){var a=function(e,t){for(var n=[],a=0;a<dy.length;a++){var r=ev(e.get(a,0).valueOf(),e.get(a,1).valueOf(),a,t),s=r.x,o=r.y;n.push(o),n.push(s)}return Vd(n,[dy.length,2])}(e,n);return sl(Xi(Ml(e.toTensor(),el(t,"int32")),"float32"),a)}))}function ev(e,t,n,a){return{y:a.get(e,t,n),x:a.get(e,t,n+dy.length)}}function tv(e,t,n){return uy(this,void 0,void 0,(function(){var a,r,s,o,i,c,l,u,h,d;return hy(this,(function(p){switch(p.label){case 0:return a=0,r=function(e){var t=e.shape,n=t[0],a=t[1],r=t[2];return Xc((function(){var t,s,o=Al(e,[n*a,r]),i=ll(o,0),c=Hu(bu(i,el(a,"int32")),1),l=Hu((t=i,s=a,Xc((function(){var e=bu(t,el(s,"int32"));return ph(t,Ml(e,el(s,"int32")))}))),1);return Ol([c,l],1)}))}(e),[4,Promise.all([e.buffer(),t.buffer(),r.buffer()])];case 1:return s=p.sent(),o=s[0],i=s[1],c=s[2],[4,(l=$b(c,n,i)).buffer()];case 2:return u=p.sent(),h=Array.from(function(e,t){for(var n=t.shape[0],a=new Float32Array(n),r=0;r<n;r++){var s=t.get(r,0),o=t.get(r,1);a[r]=e.get(s,o,r)}return a}(o,c)),d=h.map((function(e,t){return a+=e,{y:u.get(t,0),x:u.get(t,1),score:e,name:dy[t]}})),r.dispose(),l.dispose(),[2,{keypoints:d,score:a/d.length}]}}))}))}function nv(e,t){return(e-1)%t==0}var av="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",rv="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function sv(e,t){return function(e,t){return(e-1)%t==0}(e,t)?e:Math.floor(e/t)*t+1}var ov=function(){function e(e,t){this.posenetModel=e;var n=this.posenetModel.inputs[0].shape;Et(-1===n[1]&&-1===n[2],(function(){return"Input shape ["+n[1]+", "+n[2]+"] must both be equal to or -1"}));var a,r,s=(a=t.inputResolution,r=t.outputStride,{height:sv(a.height,r),width:sv(a.width,r)});!function(e){Et(Rb.indexOf(e)>=0,(function(){return"outputStride of "+e+" is invalid. It must be either 8 or 16."}))}(t.outputStride),function(e,t){Et(nv(e.height,t),(function(){return"height of "+e.height+" is invalid for output stride "+t+"."})),Et(nv(e.width,t),(function(){return"width of "+e.width+" is invalid for output stride "+t+"."}))}(s,t.outputStride),this.inputResolution=s,this.outputStride=t.outputStride,this.architecture=t.architecture}return e.prototype.estimatePoses=function(e,t){return void 0===t&&(t=Fb),uy(this,void 0,void 0,(function(){var n,a,r,s,o,i,c,l,u,h,d,p,f,m,g;return hy(this,(function(y){switch(y.label){case 0:return n=function(e){var t=e;if(null==t.maxPoses&&(t.maxPoses=1),t.maxPoses<=0)throw new Error("Invalid maxPoses "+t.maxPoses+". Should be > 0.");if(t.maxPoses>1){if((t=ly({},Ob,t)).scoreThreshold<0||t.scoreThreshold>1)throw new Error("Invalid scoreThreshold "+t.scoreThreshold+". Should be in range [0.0, 1.0]");if(t.nmsRadius<=0)throw new Error("Invalid nmsRadius "+t.nmsRadius+".")}return t}(t),null==e?[2,[]]:(this.maxPoses=n.maxPoses,a=Ny(e,{inputResolution:this.inputResolution,keepAspectRatio:!0}),r=a.imageTensor,s=a.padding,o="ResNet50"===this.architecture?sl(r,Db):My(r,[-1,1]),i=this.posenetModel.predict(o),"ResNet50"===this.architecture?(c=Ld(i[2],[0]),l=Ld(i[3],[0]),u=Ld(i[0],[0]),h=Ld(i[1],[0])):(c=Ld(i[0],[0]),l=Ld(i[1],[0]),u=Ld(i[2],[0]),h=Ld(i[3],[0])),d=Ll(l),1!==this.maxPoses?[3,2]:[4,tv(d,c,this.outputStride)]);case 1:return f=y.sent(),p=[f],[3,4];case 2:return[4,Jb(d,c,u,h,this.outputStride,this.maxPoses,n.scoreThreshold,n.nmsRadius)];case 3:p=y.sent(),y.label=4;case 4:return m=wy(e),g=function(e,t,n,a){var r=t.height,s=t.width,o=r/(n.height*(1-a.top-a.bottom)),i=s/(n.width*(1-a.left-a.right)),c=-a.top*n.height,l=-a.left*n.width;if(1===i&&1===o&&0===c&&0===l)return e;for(var u=0,h=e;u<h.length;u++)for(var d=0,p=h[u].keypoints;d<p.length;d++){var f=p[d];f.x=(f.x+l)*i,f.y=(f.y+c)*o}return e}(p,m,this.inputResolution,s),n.flipHorizontal&&(g=function(e,t){for(var n=0,a=e;n<a.length;n++)for(var r=0,s=a[n].keypoints;r<s.length;r++){var o=s[r];o.x=t.width-1-o.x}return e}(g,m)),r.dispose(),o.dispose(),Yc(i),c.dispose(),l.dispose(),u.dispose(),h.dispose(),d.dispose(),[2,g]}}))}))},e.prototype.dispose=function(){this.posenetModel.dispose()},e.prototype.reset=function(){},e}();function iv(e){return void 0===e&&(e=Cb),uy(this,void 0,void 0,(function(){var t,n,a,r,s;return hy(this,(function(o){switch(o.label){case 0:return"ResNet50"!==(t=function(e){var t=e||Cb;if(null==t.architecture&&(t.architecture="MobileNetV1"),Tb.indexOf(t.architecture)<0)throw new Error("Invalid architecture "+t.architecture+". Should be one of "+Tb);if(null==t.inputResolution&&(t.inputResolution={height:257,width:257}),null==t.outputStride&&(t.outputStride=16),Eb[t.architecture].indexOf(t.outputStride)<0)throw new Error("Invalid outputStride "+t.outputStride+". Should be one of "+Eb[t.architecture]+" for architecture "+t.architecture+".");if(null==t.multiplier&&(t.multiplier=1),Ab[t.architecture].indexOf(t.multiplier)<0)throw new Error("Invalid multiplier "+t.multiplier+". Should be one of "+Ab[t.architecture]+" for architecture "+t.architecture+".");if(null==t.quantBytes&&(t.quantBytes=4),_b.indexOf(t.quantBytes)<0)throw new Error("Invalid quantBytes "+t.quantBytes+". Should be one of "+_b+" for architecture "+t.architecture+".");if("MobileNetV1"===t.architecture&&32===t.outputStride&&1!==t.multiplier)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return t}(e)).architecture?[3,2]:(i=t.outputStride,c=t.quantBytes,l="model-stride"+i+".json",n=4===c?rv+"float/"+l:rv+"quant"+c+"/"+l,[4,oy(t.modelUrl||n)]);case 1:return a=o.sent(),[2,new ov(a,t)];case 2:return r=function(e,t,n){var a={1:"100",.75:"075",.5:"050"},r="model-stride"+e+".json";return 4===n?av+"float/"+a[t]+"/"+r:av+"quant"+n+"/"+a[t]+"/"+r}(t.outputStride,t.multiplier,t.quantBytes),[4,oy(t.modelUrl||r)];case 3:return s=o.sent(),[2,new ov(s,t)]}var i,c,l}))}))}var cv={SINGLEPOSE_LIGHTNING:"SinglePose.Lightning",SINGLEPOSE_THUNDER:"SinglePose.Thunder",MULTIPOSE_LIGHTNING:"MultiPose.Lightning"};const lv={kernelName:gn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ml(e,zd(Xi(n,"float32"),-1))}}},uv={kernelName:yn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Bu(Xi(n,"float32")),a=zu(ph(el(1),t));return uh(bu(e,a))}}}},hv={kernelName:bn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=zu(ph(Bu(Xi(n,"float32")),1));return bu(e,t)}}}},dv={kernelName:vn,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=vc(n.shape,a.shape);return{a:()=>{let t=e;const a=bc(n.shape,r);return a.length>0&&(t=Wu(t,a)),Al(t,n.shape)},b:()=>{let t=e;const n=bc(a.shape,r);return n.length>0&&(t=Wu(t,n)),Al(t,a.shape)}}}},pv={kernelName:xn,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,a)=>{n[a]=()=>e.clone()})),n}},fv={kernelName:Sn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>wu(n)}}},mv={kernelName:In,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>wu(n)}}},gv={kernelName:Nn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bu(e,zu(ph(el(1),Bu(Xi(n,"float32")))))}}},yv={kernelName:Cn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=zu(sl(el(1),Bu(Xi(n,"float32"))));return bu(e,t)}}}},bv={kernelName:Rn,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=vc(n.shape,a.shape);return{a:()=>{const t=sl(Bu(n),Bu(a));let s=Ml(e,bu(a,t));const o=bc(n.shape,r);return o.length>0&&(s=Wu(s,o)),Al(s,n.shape)},b:()=>{const t=sl(Bu(n),Bu(a));let s=uh(Ml(e,bu(n,t)));const o=bc(a.shape,r);return o.length>0&&(s=Wu(s,o)),Al(s,a.shape)}}}},vv={kernelName:Tn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bu(e,sl(Bu(Xi(n,"float32")),1))}}},xv={kernelName:En,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bu(e,ph(el(1),Bu(Xi(n,"float32"))))}}};const wv=jo({avgPool3dGrad_:function(e,t,n,a,r,s){const o=Uo(e,"dy","avgPool3dGrad"),i=Uo(t,"input","avgPool3dGrad");let c=o,l=i,u=!1;4===i.rank&&(u=!0,c=Al(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),l=Al(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Et(5===c.rank,(()=>"Error in avgPool3dGrad: dy must be rank 5 but got rank "+"".concat(c.rank,"."))),Et(5===l.rank,(()=>"Error in avgPool3dGrad: input must be rank 5 but got rank "+"".concat(l.rank,"."))),Rl("avgPool3dGrad",r,s);const h={dy:c,input:l},d={filterSize:n,strides:a,pad:r,dimRoundingMode:s},p=Fo.runKernel(On,h,d);return u?Al(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),kv={kernelName:Fn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{filterSize:r,strides:s,pad:o,dimRoundingMode:i}=n;return{x:()=>wv(e,a,r,s,o,i)}}};const Sv=jo({avgPoolGrad_:function(e,t,n,a,r){const s=Uo(e,"dy","avgPoolGrad"),o=Uo(t,"input","avgPoolGrad");Et(o.rank===s.rank,(()=>"Rank of input (".concat(o.rank,") does not match rank of dy (").concat(s.rank,")")));let i=o,c=s,l=!1;3===o.rank&&(l=!0,i=Al(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=Al(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Et(4===c.rank,(()=>"Error in avgPoolGrad: dy must be rank 4 but got rank "+"".concat(c.rank,"."))),Et(4===i.rank,(()=>"Error in avgPoolGrad: input must be rank 4 but got rank "+"".concat(i.rank,".")));const u={dy:c,input:i},h={filterSize:n,strides:a,pad:r},d=Fo.runKernel(_n,u,h);return l?Al(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Iv={kernelName:An,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{filterSize:r,strides:s,pad:o}=n;return{x:()=>Sv(e,a,r,s,o)}}},Nv={kernelName:Dn,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[a,r]=t,{transposeA:s,transposeB:o}=n;return s||o?!s&&o?{a:()=>Dl(e,r,!1,!1),b:()=>Dl(e,a,!0,!1)}:s&&!o?{a:()=>Dl(r,e,!1,!0),b:()=>Dl(a,e,!1,!1)}:{a:()=>Dl(r,e,!0,!0),b:()=>Dl(e,a,!0,!0)}:{a:()=>Dl(e,r,!1,!0),b:()=>Dl(a,e,!0,!1)}}},Cv={kernelName:Mn,gradFunc:(e,t,n)=>{const{blockShape:a,crops:r}=n;return{x:()=>Kh(e,a,r)}}},Tv={kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{const a=n,r=a.inputShape,s=a.shape,o=Array.from(s);for(let c=r.length-1;c>=0;c--)if(r[c]===s[c])o[c]=1;else if(1!==r[c])throw new Error("broadcastTo(): [".concat(r,"] cannot be broadcast to [").concat(s,"]."));const i=[];for(let c=0;c<o.length;c++)o[c]>1&&i.push(c);return{x:()=>Wu(e,i,!0)}}},Ev={kernelName:zn,gradFunc:e=>({x:()=>e.clone()})},Rv={kernelName:Bn,gradFunc:e=>({x:()=>wu(e)})},Av={kernelName:Wn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{clipValueMin:r,clipValueMax:s}=n;return{x:()=>xu(gh(Ju(a,r),sh(a,s)),e,wu(e))}}},_v={kernelName:Vn,inputsToSave:["x"],gradFunc:lv.gradFunc},Fv={kernelName:Gn,saveAllInputs:!0,gradFunc:(e,t,n)=>{const a=t.map((e=>e.shape)),{axis:r}=n,s=Bt(r,t[0].shape)[0],o=a.map((e=>e[s]));return Od(e,o,s).map((e=>()=>e))}},Ov={kernelName:jn,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,{dilations:s,strides:o,pad:i,dataFormat:c}=n;return Et(Cl(s),(()=>"Error in gradient of conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(s,"'"))),{x:()=>au(a.shape,e,r,o,i,c),filter:()=>fp(a,e,r.shape,o,i,c)}}},Dv={kernelName:Kn,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,{strides:s,pad:o,dataFormat:i,dimRoundingMode:c}=n;return{dy:()=>tu(e,r,s,o,i,1,c),filter:()=>fp(e,a,r.shape,s,o,i,c)}}};const Mv=jo({conv3DBackpropFilter_:function(e,t,n,a,r){let s=e;4===e.rank&&(s=Al(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let o=t;4===o.rank&&(o=Al(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Et(5===s.rank,(()=>"Error in conv3dDerFilter: input must be rank 5, but got shape "+"".concat(s.shape,"."))),Et(5===o.rank,(()=>"Error in conv3dDerFilter: dy must be rank 5, but got shape "+"".concat(o.shape,"."))),Et(5===n.length,(()=>"Error in conv3dDerFilter: filterShape must be length 5, but got "+"".concat(n,"."))),Et(s.shape[4]===n[3],(()=>"Error in conv3dDerFilter: depth of input ".concat(s.shape[4],") must ")+"match input depth in filter (".concat(n[3],"."))),Et(o.shape[4]===n[4],(()=>"Error in conv3dDerFilter: depth of dy (".concat(o.shape[4],") must ")+"match output depth for filter (".concat(n[4],").")));const i={x:s,dy:o},c={strides:a,pad:r,filterShape:n};return Fo.runKernel(Xn,i,c)}}),Lv={kernelName:qn,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:a,strides:r,pad:s}=n;Et(Cl(a),(()=>"Error in gradient of conv3D: dilation rates greater than 1 are "+"not yet supported in gradients. Got dilations '".concat(a,"'")));const[o,i]=t;return{x:()=>ou(o.shape,e,i,r,s),filter:()=>Mv(o,e,i.shape,r,s)}}},Pv={kernelName:Zn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ml(uh(Sd(Xi(n,"float32"))),e)}}},zv={kernelName:Qn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ml(Id(Xi(n,"float32")),e)}}},Bv={kernelName:$n,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r,exclusive:s,reverse:o}=n;return{x:()=>{const t=Fu([r],a.rank);let n=hu(e,r,s,!o);return null!=t&&(n=np(n,t)),n}}}},Wv={kernelName:aa,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:a,strides:r,pad:s,dimRoundingMode:o}=n,i=null==a?[1,1]:a;Et(Cl(i),(()=>"Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(i,"'")));const[c,l]=t;return Et(4===c.rank,(()=>"Error in gradient of depthwiseConv2dNative: input must be "+"rank 4, but got rank ".concat(c.rank,"."))),Et(4===l.rank,(()=>"Error in gradient of depthwiseConv2dNative: filter must be "+"rank 4, but got rank ".concat(l.rank,"."))),Et(c.shape[3]===l.shape[2],(()=>"Error in gradient of depthwiseConv2d: number of input "+"channels (".concat(c.shape[3],") must match the inChannels dimension ")+"in filter ".concat(l.shape[2],"."))),Et(Tl(r,i),(()=>"Error in gradient of depthwiseConv2d: Either strides or "+"dilations must be  1. Got strides ".concat(r," and dilations ")+"'".concat(i,"'."))),Rl("depthwiseConv2d",s,o),{x:()=>wp(c.shape,e,l,r,s,i,o),filter:()=>xp(c,e,l.shape,r,s,i,o)}}},Uv={kernelName:ia,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,s={x:a,filter:r,dy:e},o={x:a,filter:r,dy:e};return{x:()=>Fo.runKernel(ca,s,n),filter:()=>Fo.runKernel(la,o,n)}}},Vv={kernelName:da,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,a={dy:e,y:n};return{x:()=>Fo.runKernel(pa,a)}}},Gv={kernelName:fa,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,a=Ml(ju(uh(Bu(n))),2/Math.sqrt(Math.PI));return{x:()=>Ml(e,a)}}},jv={kernelName:ga,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ml(e,n)}}},Hv={kernelName:ya,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>Al(e,n.shape)}}},Kv={kernelName:ba,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ml(e,ju(n))}}},qv={kernelName:ka,gradFunc:e=>({x:()=>wu(e)})},Xv={kernelName:Sa,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=vc(n.shape,a.shape);return{a:()=>{const t=bu(e,Xi(a,"float32")),s=bc(n.shape,r);return s.length>0?Al(Wu(t,s),n.shape):t},b:()=>{let t=Ml(e,Xi(n,"float32"));const s=bc(a.shape,r);s.length>0&&(t=Al(Wu(t,s),a.shape));const o=Bu(a);return uh(bu(t,Xi(o,"float32")))}}}},Yv={kernelName:Ia,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:a}=n,[r,s,o,i]=t,c=null==i?el(1):i,l=bc(s.shape,r.shape),u=[];if(1===s.rank){for(let e=0;e<r.shape.length-1;++e)u.push(r.shape[e]);u.push(1)}const h=ph(r,s),d=Ml(e,c),p=bd(sl(o,el(a))),f=Ml(Ml(Ml(p,p),p),el(-.5));return{x:()=>1===s.rank?Al(Ml(Ml(e,qu(Al(p,[1,1,1,s.shape[0]]),u)),c),r.shape):Al(Ml(Ml(e,p),c),r.shape),mean:()=>{let e=Ml(Ml(p,el(-1)),d);return 1===s.rank&&(e=Wu(e,l)),Al(e,s.shape)},variance:()=>{let e=Ml(Ml(f,h),d);return 1===s.rank&&(e=Wu(e,l)),Al(e,s.shape)},scale:()=>{const t=Ml(h,p);let n=Ml(e,t);return 1===s.rank&&(n=Wu(n,l)),Al(n,s.shape)},offset:()=>{let t=e;return 1===s.rank&&(t=Wu(t,l)),Al(t,s.shape)}}}},Zv={kernelName:Na,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[a,r]=t,{axis:s}=n,o=Bt(s,a.shape)[0];return{x:()=>{const t=a.shape,n=r.size,i=t.slice(0,o),c=i.length,l=t.slice(s,t.length).slice(1),u=l.length,h=Qv(0,c),d=Qv(c+1,c+1+u),p=Jv([i,[n],l]),f=Al(e,p),m=Al(r,[n]),g=Jv([[c],h,d]),y=np(f,g);let b=Yd(y,m,a.shape[o]);const v=Ou(g);return b=np(b,v),b},indices:()=>r}}};function Qv(e,t){const n=[];for(let a=e;a<t;++a)n.push(a);return n}function Jv(e){const t=[];for(let n=0;n<e.length;++n)for(let a=0;a<e[n].length;++a)t.push(e[n][a]);return t}const $v={kernelName:Ea,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>wu(n),b:()=>wu(a)}}},ex={kernelName:Ra,gradFunc:e=>({x:()=>Xi(e,"float32")})},tx={kernelName:Fa,gradFunc:e=>({x:()=>wu(e)})},nx={kernelName:Oa,gradFunc:e=>({x:()=>wu(e)})},ax={kernelName:Da,gradFunc:e=>({x:()=>wu(e)})},rx={kernelName:Ma,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{alpha:r}=n,s=Qu(a,0);return{x:()=>xu(s,e,Ml(e,r))}}},sx={kernelName:Wa,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bu(e,sl(n,1))}}},ox={kernelName:Ba,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bu(e,Xi(n,"float32"))}}},ix={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n;return{logits:()=>{const t=ju(a);return ph(e,Ml(Wu(e,r,!0),t))}}}};const cx=jo({localResponseNormalizationBackprop_:function(e,t,n){const a={x:e,y:t,dy:n},r={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return Fo.runKernel(Ha,a,r)}}),lx={kernelName:ja,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{depthRadius:s,bias:o,alpha:i,beta:c}=n;return{x:()=>cx(a,r,e,s,o,i,c)}}};function ux(e,t,n,a){return t.rank<n.rank&&(t=Al(t,Au(t.shape,a))),e.rank<n.rank&&(e=Al(e,Au(e.shape,a))),{x:()=>Ml(e,Xi(vu(n,t),e.dtype))}}const hx={kernelName:Ka,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const a=n,{reductionIndices:r}=a,s=t[0],o=ux(e,t[1],s,Bt(r,s.shape));return{x:()=>o.x()}}},dx={kernelName:qa,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>Ml(e,Xi(Ju(n,a),"float32")),b:()=>Ml(e,Xi(rh(n,a),"float32"))}}};const px=jo({maxPool3dGrad_:function(e,t,n,a,r,s,o){const i=Uo(e,"dy","maxPool3dGrad"),c=Uo(t,"input","maxPool3dGrad"),l=Uo(n,"output","maxPool3dGrad");let u=i,h=c,d=l,p=!1;4===c.rank&&(p=!0,u=Al(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),h=Al(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),d=Al(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),Et(5===u.rank,(()=>"Error in maxPool3dGrad: dy must be rank 5 but got rank "+"".concat(u.rank,"."))),Et(5===h.rank,(()=>"Error in maxPool3dGrad: input must be rank 5 but got rank "+"".concat(h.rank,"."))),Et(5===d.rank,(()=>"Error in maxPool3dGrad: output must be rank 5 but got rank "+"".concat(d.rank,"."))),Rl("maxPool3dGrad",s,o);const f={dy:u,input:h,output:d},m={filterSize:a,strides:r,pad:s,dimRoundingMode:o},g=Fo.runKernel(Qa,f,m);return p?Al(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),fx={kernelName:Za,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:c}=n;return{x:()=>px(e,a,r,s,o,i,c)}}};const mx=jo({maxPoolGrad_:function(e,t,n,a,r,s,o){const i=Uo(e,"dy","maxPoolGrad"),c=Uo(t,"input","maxPoolGrad"),l=Uo(n,"output","maxPoolGrad");Et(c.rank===i.rank,(()=>"Rank of input (".concat(c.rank,") does not match rank of dy ")+"(".concat(i.rank,")"))),Et(4===i.rank,(()=>"Error in maxPoolGrad: dy must be rank 4 but got rank "+"".concat(i.rank,"."))),Et(4===c.rank,(()=>"Error in maxPoolGrad: input must be rank 4 but got rank "+"".concat(c.rank,"."))),Rl("maxPoolGrad",s,o);const u={dy:i,input:c,output:l},h={filterSize:a,strides:r,pad:s,dimRoundingMode:o};return Fo.runKernel(Ya,u,h)}}),gx={kernelName:Xa,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{filterSize:s,strides:o,pad:i}=n;return{x:()=>mx(e,a,r,s,o,i)}}},yx={kernelName:nr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const a=t[0],{paddings:r}=n,s=r.map((e=>e[0]));return{x:()=>Pl(e,s,a.shape)}}},bx={kernelName:pr,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:a}=n;return Zd(e,a).map((e=>()=>e))}},vx={kernelName:fr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const a=t[0],{paddings:r}=n,s=r.map((e=>e[0]));return{x:()=>Pl(e,s,a.shape)}}},xx={kernelName:mr,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,a,r]=t,s=n,o=a,i=vc(s.shape,o.shape);return{a:()=>{const t=Xi(o,"float32");let n=Ml(e,Ml(t,Pu(s,ph(t,el(1)))));const a=bc(s.shape,i);return a.length>0&&(n=Wu(n,a)),Al(n,s.shape)},b:()=>{const t=Qu(s,0),n=xu(t,ch(s),wu(s));let a=Ml(e,Ml(r,n));const c=bc(o.shape,i);return c.length>0&&(a=Wu(a,c)),Al(a,o.shape)}}}};function wx(e,t,n){const a=e.shape.length,r=a-n.length,s=Fu(n,a);let o=e;null!=s&&(o=np(e,s));const i=o.shape.slice(),c=i.splice(a-n.length,n.length).reduce(((e,t)=>e*t),1);i.push(c);let l=function(e,t,n){const a=e.shape.slice();a[n]=1;const r=Al(t,a),s=uu(e,n,!0,!1),o=uu(e,n,!0,!0),i=Ml(s,o);return Ml(r,i)}(o.reshape(i),t,r);if(l=l.reshape(o.shape),null!=s){const e=Ou(s);l=np(l,e)}return l}const kx={kernelName:Lr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Qu(n,el(0)),a=el(em),r=el(tm),s=Ml(e,r),o=Ml(Ml(e,a),ju(Xi(n,"float32")));return xu(t,s,o)}}}},Sx={kernelName:Hr,gradFunc:(e,t,n)=>{const{blockShape:a,paddings:r}=n;return{x:()=>Wl(e,a,r)}}},Ix={kernelName:Kr,gradFunc:(e,t,n)=>{const{axis:a}=n;return{x:()=>Ol(e,a)}}},Nx={kernelName:cs,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{reps:r}=n;return{x:()=>{let t=wu(a);if(1===a.rank)for(let n=0;n<r[0];++n)t=sl(t,Pl(e,[n*a.shape[0]],[a.shape[0]]));else if(2===a.rank)for(let n=0;n<r[0];++n)for(let s=0;s<r[1];++s)t=sl(t,Pl(e,[n*a.shape[0],s*a.shape[1]],[a.shape[0],a.shape[1]]));else if(3===a.rank)for(let n=0;n<r[0];++n)for(let s=0;s<r[1];++s)for(let o=0;o<r[2];++o)t=sl(t,Pl(e,[n*a.shape[0],s*a.shape[1],o*a.shape[2]],[a.shape[0],a.shape[1],a.shape[2]]));else{if(4!==a.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+"".concat(a.rank," tensors yet."));for(let n=0;n<r[0];++n)for(let s=0;s<r[1];++s)for(let o=0;o<r[2];++o)for(let i=0;i<r[3];++i)t=sl(t,Pl(e,[n*a.shape[0],s*a.shape[1],o*a.shape[2],i*a.shape[3]],[a.shape[0],a.shape[1],a.shape[2],a.shape[3]]))}return t}}}};const Cx=[lv,uv,hv,dv,pv,fv,mv,gv,yv,bv,vv,xv,kv,Iv,Nv,Cv,Tv,Ev,Rv,Av,_v,Fv,Dv,Ov,Lv,Pv,zv,Bv,Wv,Uv,{kernelName:ua,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=vc(n.shape,a.shape);return{a:()=>{const t=bu(e,Xi(a,"float32")),s=bc(n.shape,r);return s.length>0?Al(Wu(t,s),n.shape):t},b:()=>{let t=Ml(e,Xi(n,"float32"));const s=bc(a.shape,r);s.length>0&&(t=Al(Wu(t,s),a.shape));const o=Bu(a);return uh(bu(t,Xi(o,"float32")))}}}},Vv,Gv,jv,Hv,Kv,Xv,qv,Yv,Zv,$v,ex,tx,nx,ax,rx,sx,ox,ix,lx,hx,hx,dx,fx,gx,{kernelName:$a,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n,s=Bt(r,a.shape),o=Ft(Ru(a.shape,s)[1]);return{x:()=>{const t=a.shape.slice();s.forEach((e=>{t[e]=1}));const n=Al(e,t);return bu(Ml(n,Rh(a.shape,"float32")),o)}}}},{kernelName:er,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const a=n,{axis:r}=a,[s,o]=t,i=ux(e,o,s,Bt(r,s.shape));return{x:()=>i.x()}}},{kernelName:tr,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>Ml(e,Xi(sh(n,a),"float32")),b:()=>Ml(e,Xi(Qu(n,a),"float32"))}}},yx,{kernelName:ar,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=vc(n.shape,a.shape);return{a:()=>{const t=bc(n.shape,r);return t.length>0?Al(Wu(e,t),n.shape):e},b:()=>{const t=Ml(e,uh(Yu(bu(n,a)))),s=bc(a.shape,r);return s.length>0?Al(Wu(t,s),a.shape):t}}}},{kernelName:sr,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=vc(n.shape,a.shape);return{a:()=>{const t=Ml(e,Xi(a,"float32")),s=bc(n.shape,r);return s.length>0?Al(Wu(t,s),n.shape):t},b:()=>{const t=Ml(e,Xi(n,"float32")),s=bc(a.shape,r);return s.length>0?Al(Wu(t,s),a.shape):t}}}},{kernelName:or,gradFunc:e=>({x:()=>uh(e)})},{kernelName:dr,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>Eh(n.shape,"float32")}}},{kernelName:hr,gradFunc:e=>({x:()=>wu(e)})},bx,vx,vx,xx,{kernelName:gr,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,a]=t,r=Qu(n,0);return{x:()=>xu(r,e,Ml(e,a)),alpha:()=>{let t=xu(r,wu(e),Ml(e,n));const s=bc(a.shape,e.shape);return s.length>0&&(t=Wu(t,s)),Al(t,a.shape)}}}},{kernelName:yr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n;let s=[];return s=void 0===r||null===r?a.shape.map(((e,t)=>t)):"number"===typeof r?[r]:r,{x:()=>wx(a,e,s)}}},{kernelName:kr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bu(e,uh(Bu(n)))}}},{kernelName:Rr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,a=Ml(sh(n,6),zd(n));return{x:()=>Ml(e,Xi(a,"float32"))}}},{kernelName:Sr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ml(e,Xi(zd(n),"float32"))}}},{kernelName:Ir,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Al(e,n.shape)}}},{kernelName:Tr,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[a]=t,r={dy:e,images:a};return{images:()=>Fo.runKernel(Er,r,n)}}},{kernelName:Nr,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[a]=t,r={dy:e,images:a};return{images:()=>Fo.runKernel(Cr,r,n)}}},{kernelName:Ar,gradFunc:(e,t,n)=>{const{dims:a}=n,r=Bt(a,e.shape);return{x:()=>dd(e,r)}}},{kernelName:_r,gradFunc:e=>({x:()=>wu(e)})},{kernelName:Fr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>uh(bu(e,Ml(Pu(n,1.5),2)))}}},{kernelName:Mr,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>Xi(wu(n),"float32"),t:()=>Ml(e,Xi(n,e.dtype)),e:()=>Ml(e,Xi(yh(n),e.dtype))}}},kx,{kernelName:Ur,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ml(e,Ml(n,ph(el(1),n)))}}},{kernelName:Wr,gradFunc:e=>({x:()=>wu(e)})},{kernelName:zr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ml(cu(Xi(n,"float32")),e)}}},{kernelName:Br,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ml(lu(Xi(n,"float32")),e)}}},{kernelName:Pr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{begin:r,size:s}=n,o=a.shape,[i,c]=Wc(a,r,s),l=[];for(let u=0;u<e.rank;u++)l.push([i[u],o[u]-i[u]-c[u]]);return{x:()=>Uh(e,l)}}},{kernelName:qr,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a]=t,{dim:r}=n,s=Ml(e,a);return{logits:()=>ph(s,Ml(Wu(s,[r],true),a))}}},{kernelName:Vr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ml(e,Ll(n))}}},Sx,Sx,Ix,Ix,{kernelName:Gr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bu(e,Ml(zu(Xi(n,"float32")),2))}}},{kernelName:$r,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=el(2);return{a:()=>Ml(e,Ml(r,ph(n,a))),b:()=>Ml(e,Ml(r,ph(a,n)))}}},{kernelName:es,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ml(e,Ml(Xi(n,"float32"),2))}}},{kernelName:gs,gradFunc:e=>({x:()=>wu(e)})},{kernelName:ss,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=vc(n.shape,a.shape);return{a:()=>{let t=e;const a=bc(n.shape,r);return a.length>0&&(t=Wu(t,a)),Al(t,n.shape)},b:()=>{let t=e;const n=bc(a.shape,r);return n.length>0&&(t=Wu(t,n)),Al(uh(t),a.shape)}}}},{kernelName:jr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,r=a.shape.slice(),{axis:s}=n;Bt(s,a.shape).forEach((e=>{r[e]=1}));const o=Al(e,r),i=Ml(o,Rh(a.shape,"float32"));return{x:()=>i}}},{kernelName:os,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bu(e,Bu(cu(n)))}}},{kernelName:is,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ml(ph(el(1),Bu(n)),e)}}},Nx,{kernelName:hs,gradFunc:(e,t,n)=>{const a=n,{perm:r}=a,s=Ou(r);return{x:()=>np(e,s)}}},{kernelName:ps,gradFunc:(e,t,n)=>{const a=n,{axis:r}=a;return{value:()=>Pd(e,r)}}},{kernelName:fs,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=Ch(t,wu(t)),a=Zu(e,n);let r=Ju(t,el(0,"int32"));const s=a.rank-r.rank;for(let i=0;i<s;++i)r=Hu(r,i+1);r=gh(r,Rh(a.shape,"bool"));const o=wu(a);return xu(r,a,o)}(e,n)}}},{kernelName:ms,gradFunc:e=>({x:()=>wu(e)})}];for(const n of Cx)As(n);fo().prototype.abs=function(){return this.throwIfDisposed(),nl(this)},fo().prototype.acos=function(){return this.throwIfDisposed(),al(this)},fo().prototype.acosh=function(){return this.throwIfDisposed(),rl(this)},fo().prototype.add=function(e){return this.throwIfDisposed(),sl(this,e)},fo().prototype.all=function(e,t){return this.throwIfDisposed(),il(this,e,t)},fo().prototype.any=function(e,t){return this.throwIfDisposed(),cl(this,e,t)},fo().prototype.argMax=function(e){return this.throwIfDisposed(),ll(this,e)},fo().prototype.argMin=function(e){return this.throwIfDisposed(),ul(this,e)},fo().prototype.asScalar=function(){return this.throwIfDisposed(),Et(1===this.size,(()=>"The array must have only 1 element.")),Al(this,[])},fo().prototype.asType=function(e){return this.throwIfDisposed(),Xi(this,e)},fo().prototype.as1D=function(){return this.throwIfDisposed(),Al(this,[this.size])},fo().prototype.as2D=function(e,t){return this.throwIfDisposed(),Al(this,[e,t])},fo().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Al(this,[e,t,n])},fo().prototype.as4D=function(e,t,n,a){return this.throwIfDisposed(),Al(this,[e,t,n,a])},fo().prototype.as5D=function(e,t,n,a,r){return this.throwIfDisposed(),Al(this,[e,t,n,a,r])},fo().prototype.asin=function(){return this.throwIfDisposed(),hl(this)},fo().prototype.asinh=function(){return this.throwIfDisposed(),dl(this)},fo().prototype.atan=function(){return this.throwIfDisposed(),pl(this)},fo().prototype.atan2=function(e){return this.throwIfDisposed(),fl(this,e)},fo().prototype.atanh=function(){return this.throwIfDisposed(),ml(this)},fo().prototype.avgPool=function(e,t,n,a){return this.throwIfDisposed(),_l(this,e,t,n,a)},fo().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),Wl(this,e,t)},fo().prototype.batchNorm=function(e,t,n,a,r){return this.throwIfDisposed(),Ul(this,e,t,n,a,r)},fo().prototype.broadcastTo=function(e){return this.throwIfDisposed(),ql(this,e)},fo().prototype.cast=function(e){return this.throwIfDisposed(),Xi(this,e)},fo().prototype.ceil=function(){return this.throwIfDisposed(),Xl(this)},fo().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Zl(this,e,t)},fo().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof po&&(e=[e]),Ol([this,...e],t)},fo().prototype.conv1d=function(e,t,n,a,r,s){return this.throwIfDisposed(),nu(this,e,t,n,a,r,s)},fo().prototype.conv2dTranspose=function(e,t,n,a,r){return this.throwIfDisposed(),ru(this,e,t,n,a,r)},fo().prototype.conv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),tu(this,e,t,n,a,r,s)},fo().prototype.cos=function(){return this.throwIfDisposed(),cu(this)},fo().prototype.cosh=function(){return this.throwIfDisposed(),lu(this)},fo().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),uu(this,e,t,n)},fo().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),hu(this,e,t,n)},fo().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),pu(this,e,t)},fo().prototype.depthwiseConv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),fu(this,e,t,n,a,r,s)},fo().prototype.dilation2d=function(e,t,n,a,r){return this.throwIfDisposed(),gu(this,e,t,n,a,r)},fo().prototype.divNoNan=function(e){return this.throwIfDisposed(),ku(this,e)},fo().prototype.div=function(e){return this.throwIfDisposed(),bu(this,e)},fo().prototype.dot=function(e){return this.throwIfDisposed(),Su(this,e)},fo().prototype.elu=function(){return this.throwIfDisposed(),Nu(this)},fo().prototype.equal=function(e){return this.throwIfDisposed(),vu(this,e)},fo().prototype.erf=function(){return this.throwIfDisposed(),Cu(this)},fo().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),Gu(this,e,t)},fo().prototype.exp=function(){return this.throwIfDisposed(),ju(this)},fo().prototype.expandDims=function(e){return this.throwIfDisposed(),Hu(this,e)},fo().prototype.expm1=function(){return this.throwIfDisposed(),Ku(this)},fo().prototype.fft=function(){return this.throwIfDisposed(),Ad(this)},fo().prototype.flatten=function(){return this.throwIfDisposed(),Al(this,[this.size])},fo().prototype.floor=function(){return this.throwIfDisposed(),Yu(this)},fo().prototype.floorDiv=function(e){return this.throwIfDisposed(),yu(this,e)},fo().prototype.gather=function(e,t){return this.throwIfDisposed(),Zu(this,e,t)},fo().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Ju(this,e)},fo().prototype.greater=function(e){return this.throwIfDisposed(),Qu(this,e)},fo().prototype.ifft=function(){return this.throwIfDisposed(),_d(this)},fo().prototype.irfft=function(){return this.throwIfDisposed(),Fd(this)},fo().prototype.isFinite=function(){return this.throwIfDisposed(),eh(this)},fo().prototype.isInf=function(){return this.throwIfDisposed(),th(this)},fo().prototype.isNaN=function(){return this.throwIfDisposed(),nh(this)},fo().prototype.leakyRelu=function(e){return this.throwIfDisposed(),ah(this,e)},fo().prototype.lessEqual=function(e){return this.throwIfDisposed(),sh(this,e)},fo().prototype.less=function(e){return this.throwIfDisposed(),rh(this,e)},fo().prototype.localResponseNormalization=function(e,t,n,a){return this.throwIfDisposed(),ih(this,e,t,n,a)},fo().prototype.logSigmoid=function(){return this.throwIfDisposed(),dh(this)},fo().prototype.logSoftmax=function(e){return this.throwIfDisposed(),fh(this,e)},fo().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),mh(this,e,t)},fo().prototype.log=function(){return this.throwIfDisposed(),ch(this)},fo().prototype.log1p=function(){return this.throwIfDisposed(),lh(this)},fo().prototype.logicalAnd=function(e){return this.throwIfDisposed(),gh(this,e)},fo().prototype.logicalNot=function(){return this.throwIfDisposed(),yh(this)},fo().prototype.logicalOr=function(e){return this.throwIfDisposed(),bh(this,e)},fo().prototype.logicalXor=function(e){return this.throwIfDisposed(),vh(this,e)},fo().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),Dl(this,e,t,n)},fo().prototype.maxPool=function(e,t,n,a){return this.throwIfDisposed(),Sh(this,e,t,n,a)},fo().prototype.max=function(e,t){return this.throwIfDisposed(),Mu(this,e,t)},fo().prototype.maximum=function(e){return this.throwIfDisposed(),Ch(this,e)},fo().prototype.mean=function(e,t){return this.throwIfDisposed(),Th(this,e,t)},fo().prototype.min=function(e,t){return this.throwIfDisposed(),Lu(this,e,t)},fo().prototype.minimum=function(e){return this.throwIfDisposed(),_h(this,e)},fo().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),Fh(this,e,t)},fo().prototype.mod=function(e){return this.throwIfDisposed(),Oh(this,e)},fo().prototype.mul=function(e){return this.throwIfDisposed(),Ml(this,e)},fo().prototype.neg=function(){return this.throwIfDisposed(),uh(this)},fo().prototype.norm=function(e,t,n){return this.throwIfDisposed(),Vu(this,e,t,n)},fo().prototype.notEqual=function(e){return this.throwIfDisposed(),Ph(this,e)},fo().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),zh(this,e,t,n)},fo().prototype.onesLike=function(){return this.throwIfDisposed(),Bh(this)},fo().prototype.pad=function(e,t){return this.throwIfDisposed(),Uh(this,e,t)},fo().prototype.pool=function(e,t,n,a,r,s){return this.throwIfDisposed(),qh(this,e,t,n,a,r,s)},fo().prototype.pow=function(e){return this.throwIfDisposed(),Pu(this,e)},fo().prototype.prelu=function(e){return this.throwIfDisposed(),Xh(this,e)},fo().prototype.prod=function(e,t){return this.throwIfDisposed(),Yh(this,e,t)},fo().prototype.reciprocal=function(){return this.throwIfDisposed(),ld(this)},fo().prototype.relu=function(){return this.throwIfDisposed(),ud(this)},fo().prototype.relu6=function(){return this.throwIfDisposed(),hd(this)},fo().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Al(this,e.shape)},fo().prototype.reshape=function(e){return this.throwIfDisposed(),Al(this,e)},fo().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),Xp(this,e,t,n)},fo().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),Yp(this,e,t,n)},fo().prototype.reverse=function(e){return this.throwIfDisposed(),dd(this,e)},fo().prototype.rfft=function(){return this.throwIfDisposed(),Dd(this)},fo().prototype.round=function(){return this.throwIfDisposed(),yd(this)},fo().prototype.rsqrt=function(){return this.throwIfDisposed(),bd(this)},fo().prototype.selu=function(){return this.throwIfDisposed(),vd(this)},fo().prototype.separableConv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),xd(this,e,t,n,a,r,s)},fo().prototype.sigmoid=function(){return this.throwIfDisposed(),Ll(this)},fo().prototype.sign=function(){return this.throwIfDisposed(),kd(this)},fo().prototype.sin=function(){return this.throwIfDisposed(),Sd(this)},fo().prototype.sinh=function(){return this.throwIfDisposed(),Id(this)},fo().prototype.slice=function(e,t){return this.throwIfDisposed(),Pl(this,e,t)},fo().prototype.softmax=function(e){return this.throwIfDisposed(),Rd(this,e)},fo().prototype.softplus=function(){return this.throwIfDisposed(),hh(this)},fo().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),Kh(this,e,t)},fo().prototype.split=function(e,t){return this.throwIfDisposed(),Od(this,e,t)},fo().prototype.sqrt=function(){return this.throwIfDisposed(),zu(this)},fo().prototype.square=function(){return this.throwIfDisposed(),Bu(this)},fo().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Md(this,e)},fo().prototype.squeeze=function(e){return this.throwIfDisposed(),Ld(this,e)},fo().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof po?[this,e]:[this,...e];return Pd(n,t)},fo().prototype.step=function(e){return this.throwIfDisposed(),zd(this,e)},fo().prototype.stridedSlice=function(e,t,n,a,r,s,o,i){return this.throwIfDisposed(),Bd(this,e,t,n,a,r,s,o,i)},fo().prototype.sub=function(e){return this.throwIfDisposed(),ph(this,e)},fo().prototype.sum=function(e,t){return this.throwIfDisposed(),Wu(this,e,t)},fo().prototype.tan=function(){return this.throwIfDisposed(),Wd(this)},fo().prototype.tanh=function(){return this.throwIfDisposed(),zl(this)},fo().prototype.tile=function(e){return this.throwIfDisposed(),qu(this,e)},fo().prototype.toBool=function(){return this.throwIfDisposed(),Xi(this,"bool")},fo().prototype.toFloat=function(){return this.throwIfDisposed(),Xi(this,"float32")},fo().prototype.toInt=function(){return this.throwIfDisposed(),Xi(this,"int32")},fo().prototype.topk=function(e,t){return this.throwIfDisposed(),Kd(this,e,t)},fo().prototype.transpose=function(e){return this.throwIfDisposed(),np(this,e)},fo().prototype.unique=function(e){return this.throwIfDisposed(),Xd(this,e)},fo().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),Yd(this,e,t)},fo().prototype.unstack=function(e){return this.throwIfDisposed(),Zd(this,e)},fo().prototype.where=function(e,t){return this.throwIfDisposed(),xu(e,this,t)},fo().prototype.zerosLike=function(){return this.throwIfDisposed(),wu(this)};class Tx extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Tx.prototype)}}class Ex extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ex.prototype)}}class Rx extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Rx.prototype)}}class Ax extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ax.prototype)}}class _x extends Error{constructor(e){super(e),Object.setPrototypeOf(this,_x.prototype)}}Error;class Fx{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error("The maxEntries of LRU caches must be at least 0, but got ".concat(e,"."));if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function Ox(e,t){if(Array.isArray(e)){let n=[];for(let a=0;a<t;a++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function Dx(e,t){if(!e)throw new _x(t)}function Mx(e,t){let n=0;for(const a of e)a===t&&n++;return n}function Lx(e){return 1===e.length?e[0]:e}function Px(e){return Array.isArray(e)?e:[e]}function zx(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function Bx(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}let Wx={};function Ux(e){if(null===e||void 0===e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function Vx(e){if(null!=e&&"object"===typeof e)if(Array.isArray(e))e.forEach((e=>Vx(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"===typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!==typeof t.value?Vx(t):e[n]=t.value)}}}function Gx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof e){const r=e;let s;if(r in n)s=n[r];else if(r in Wx)s=Wx[r];else if(s=t[r],null==s)throw new Rx("Unknown ".concat(a,": ").concat(e,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(a," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(a," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");return s}{const s=e;if(null==s.className||null==s.config)throw new Rx("".concat(a,": Improper config format: ")+"".concat(JSON.stringify(s),".\n")+"'className' and 'config' must set.");const o=s.className;let i,c;if(o in n?[i,c]=n[o]:o in Wx?[i,c]=Wx.className:o in t&&([i,c]=t[o]),null==i)throw new Rx("Unknown ".concat(a,": ").concat(o,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(a," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(a," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");if(null!=c){const e={};for(const n of Object.keys(Wx))e[n]=Wx[n];for(const r of Object.keys(n))e[r]=n[r];s.config.customObjects=e;const t=Object.assign({},Wx);for(const r of Object.keys(n))Wx[r]=n[r];Vx(s.config);const a=c(i,s.config,n,r);return Wx=Object.assign({},t),a}{const e=Object.assign({},Wx);for(const a of Object.keys(n))Wx[a]=n[a];const t=new i(s.config);return Wx=Object.assign({},e),t}}}function jx(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function Hx(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function Kx(e){if(null==e)throw new Rx("Invalid value in obj: ".concat(JSON.stringify(e)));for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function qx(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new Rx("".concat(n," is not a valid ").concat(t,".  Valid values are ").concat(e," or null/undefined."))}function Xx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return Dx(n>=0),Dx(a>=n),Array.isArray(e)&&e.length>=n&&e.length<=a&&e.every((e=>typeof e===t))}function Yx(e,t){Array.isArray(e)?(Et(e.length>0,(()=>"".concat(t," is unexpectedly an empty array."))),e.forEach(((e,n)=>Yx(e,"element ".concat(n+1," of ").concat(t))))):Et(Number.isInteger(e)&&e>0,(()=>"Expected ".concat(t," to be a positive integer, but got ")+"".concat(Zx(e),".")))}function Zx(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>Zx(e))).join(",")+"]":"string"===typeof e?'"'.concat(e,'"'):"".concat(e)}function Qx(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let Jx=0;function $x(){return Jx++}const ew={};function tw(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in ew||(ew[e]=0),ew[e]+=1,e+ew[e].toString()}const nw=["channelsFirst","channelsLast"],aw=["nearest","bilinear"],rw=["valid","same","causal"],sw=["max","avg"],ow=["sum","mul","concat","ave"],iw=new Map;function cw(e){qx(nw,"DataFormat",e)}function lw(e){qx(rw,"PaddingMode",e)}function uw(e){qx(sw,"PoolMode",e)}const hw=[],dw="/";function pw(e,t){hw.push(e);try{const e=t();return hw.pop(),e}catch(qV){throw hw.pop(),qV}}function fw(e){if(!yw(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===hw.length?"":hw.join(dw)+dw)+e}function mw(e){if(!yw(e))throw new Error("Not a valid tensor name: '"+e+"'");iw.has(e)||iw.set(e,0);const t=iw.get(e);if(iw.set(e,iw.get(e)+1),t>0){const n="".concat(e,"_").concat(t);return iw.set(n,1),n}return e}const gw=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function yw(e){return!!e.match(gw)}function bw(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let a=1;for(let r=t;r<n;++r)a*=e[r];return a}function vw(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const a=e[n];a<t&&(t=a)}return t}function xw(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const a=e[n];a>t&&(t=a)}return t}function ww(e,t){if(t<e)throw new Rx("end (".concat(t,") < begin (").concat(e,") is forbidden."));const n=[];for(let a=e;a<t;++a)n.push(a);return n}let kw;function Sw(){return null==kw&&(kw=Fo.backend.epsilon()),kw}function Iw(e,t){return Xi(e,t)}function Nw(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),Al(e,n)}function Cw(e,t,n){return Xc((()=>{switch(e.rank){case 1:return Nd(e,t,n);case 2:return Cd(e,[t,0],[n,e.shape[1]]);case 3:return Td(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Ed(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Pl(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Pl(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new Rx("sliceAlongFirstAxis() received an unsupported tensor rank: "+"".concat(e.rank))}}))}function Tw(e,t,n){return Xc((()=>{switch(e.rank){case 1:return Nd(e,t,n);case 2:return Cd(e,[0,t],[e.shape[0],n]);case 3:return Td(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Ed(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new Rx("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(e.rank))}}))}function Ew(e,t,n,a){return Xc((()=>{switch(e.rank){case 1:return Nd(e,t,n);case 2:switch(a){case 1:return Cw(e,t,n);case 2:return Tw(e,t,n);default:throw new Rx("The axis is not within the rank of the tensor "+"".concat(a))}case 3:switch(a){case 1:return Cw(e,t,n);case 2:return Td(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return Tw(e,t,n);default:throw new Rx("The axis is not within the rank of the tensor "+"".concat(a))}case 4:switch(a){case 1:return Cw(e,t,n);case 2:return Ed(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Ed(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return Tw(e,t,n);default:throw new Rx("The axis is not within the rank of the tensor "+"".concat(a))}default:throw new Rx("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(e.rank))}}))}function Rw(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),Ol(e,n)}function Aw(e,t){switch(e.rank){case 1:return Ql([e,t]);case 2:return Jl([e,t],0);case 3:return $l([e,t],0);case 4:return eu([e,t],0);default:throw new Rx("concatAlongFirstAxis() received an unsupported "+"tensor rank: ".concat(e.rank))}}function _w(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new Rx("The length of input n (".concat(t.length,") does not match ")+"the number of dimensions in input x (".concat(e.rank,")"));return qu(e,t)}function Fw(e){return rd(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function Ow(e,t,n,a){if(e.rank<2||t.rank<2)throw new Ax("dot requires both inputs to be rank >= 2"+" but got x shape = ".concat(e.shape," and y shape = ").concat(t.shape));if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new Ax("If rank y >= 3, then the second last dim"+" of y must equal the last dim of x but got x shape = ".concat(e.shape," and ")+" y shape = ".concat(t.shape))}if(2===e.rank&&2===t.rank){return Sp({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?Lw(e.rank,a,"channelsLast"):null,activation:n})}{const r=e.shape.slice(),s=r.pop();e=Al(e,[-1,s]);const o=t.shape.slice(),i=o.pop(),c=o.pop(),l=[...o,i],u=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=Al(np(t,u),[c,-1]);const h=[...r,...l];return Al(Sp({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?Lw(e.rank,a,"channelsLast"):null,activation:n}),h)}}function Dw(e,t,n){return Xc((()=>(t=Array.isArray(t)?Ud(t,"int32"):Xi(t,"int32"),Zu(e,t,n))))}function Mw(e){return Ml(e,e)}function Lw(e,t,n){const a=t.shape;if(1!==t.rank&&t.rank!==e)throw new Rx("Unexpected bias dimensions: ".concat(t.rank)+"; expected it to be 1 or ".concat(e));if(5===e){if("channelsFirst"===n)return 1===a.length?Al(t,[1,a[0],1,1,1]):Al(t,[1,a[3],a[0],a[1],a[2]]);if("channelsLast"===n)return 1===a.length?Al(t,[1,1,1,1,a[0]]):Al(t,[1].concat(a))}else if(4===e){if("channelsFirst"===n)return 1===a.length?Al(t,[1,a[0],1,1]):Al(t,[1,a[2],a[0],a[1]]);if("channelsLast"===n)return 1===a.length?Al(t,[1,1,1,a[0]]):Al(t,[1].concat(a))}else if(3===e){if("channelsFirst"===n)return 1===a.length?Al(t,[1,a[0],1]):Al(t,[1,a[1],a[0]]);if("channelsLast"===n)return 1===a.length?Al(t,[1,1,a[0]]):Al(t,[1].concat(a))}else if(e<3)return t;throw new Rx("Unsupported input rank by biasAdd: ".concat(t.rank))}function Pw(e,t,n){return Xc((()=>(null==n&&(n="channelsLast"),cw(n),sl(e,Lw(e.rank,t,n)))))}function zw(e,t,n,a){return Xc((()=>up(e,t,n,a)))}function Bw(e,t){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?e():t()}const Ww=["fanIn","fanOut","fanAvg"],Uw=["normal","uniform","truncatedNormal"];class Vw extends Gc{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Gw extends Vw{apply(e,t){return Eh(e,t)}}Gw.className="Zeros",Hc(Gw);class jw extends Vw{apply(e,t){return Rh(e,t)}}jw.className="Ones",Hc(jw);class Hw extends Vw{constructor(e){if(super(),"object"!==typeof e)throw new Rx("Expected argument of type ConstantConfig but got ".concat(e));if(void 0===e.value)throw new Rx("config must have value set but got ".concat(e));this.value=e.value}apply(e,t){return Xc((()=>Ml(el(this.value),Rh(e,t))))}getConfig(){return{value:this.value}}}Hw.className="Constant",Hc(Hw);class Kw extends Vw{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return od(e,this.minval,this.maxval,t)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Kw.className="RandomUniform",Hc(Kw);class qw extends Vw{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Ax("randomNormal does not support dType ".concat(t,"."));return Fw(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}qw.className="RandomNormal",Hc(qw);class Xw extends Vw{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Ax("truncatedNormal does not support dType ".concat(t,"."));return qd(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Xw.className="TruncatedNormal",Hc(Xw);class Yw extends Vw{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return Xc((()=>{if(2!==e.length||e[0]!==e[1])throw new Rx("Identity matrix initializer can only be used for 2D square matrices.");return Ml(this.gain,Xu(e[0]))}))}getConfig(){return{gain:this.gain}}}Yw.className="Identity",Hc(Yw);class Zw extends Vw{constructor(e){if(super(),e.scale<0)throw new Rx("scale must be a positive float. Got: ".concat(e.scale));var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,qx(Ww,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){qx(Uw,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e){let t,n,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(cw(a),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===a){const a=bw(e,2);t=e[1]*a,n=e[0]*a}else if("channelsLast"===a){const a=bw(e,0,e.length-2);t=e[e.length-2]*a,n=e[e.length-1]*a}}else{const a=bw(e);t=Math.sqrt(a),n=Math.sqrt(a)}return[t,n]}(e),a=n[0],r=n[1];let s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,a):"fanOut"===this.mode?s/=Math.max(1,r):s/=Math.max(1,(a+r)/2),"normal"===this.distribution){const n=Math.sqrt(s);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Ax("".concat(this.getClassName()," does not support dType ").concat(t,"."));return qd(e,0,n,t,this.seed)}{const n=Math.sqrt(3*s);return od(e,-n,n,t)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Zw.className="VarianceScaling",Hc(Zw);class Qw extends Zw{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Zw.className}}Qw.className="GlorotUniform",Hc(Qw);class Jw extends Zw{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Zw.className}}Jw.className="GlorotNormal",Hc(Jw);class $w extends Zw{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Zw.className}}$w.className="HeNormal",Hc($w);class ek extends Zw{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Zw.className}}ek.className="HeUniform",Hc(ek);class tk extends Zw{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Zw.className}}tk.className="LeCunNormal",Hc(tk);class nk extends Zw{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Zw.className}}nk.className="LeCunNormal",Hc(nk);class ak extends Vw{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,null!=this.seed)throw new Ax("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return Xc((()=>{if(e.length<2)throw new Ax("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn("Orthogonal initializer is being called on a matrix with more "+"than 2000 (".concat(e[0]*e[1],") elements: ")+"Slowness may result.");const t=Fw(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32");let n=Sf.gramSchmidt(t);return e[0]>e[1]&&(n=np(n)),Ml(this.gain,n)}))}getConfig(){return{gain:this.gain,seed:this.seed}}}ak.className="Orthogonal",Hc(ak);const rk={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function sk(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Gx(e,jc.getMap().classNameMap,t,"initializer")}function ok(e){return Ux(e)}function ik(e){if("string"===typeof e){const t=e in rk?rk[e]:e;if("GlorotNormal"===t)return new Jw;if("GlorotUniform"===t)return new Qw;if("HeNormal"===t)return new $w;if("HeUniform"===t)return new ek;if("LeCunNormal"===t)return new tk;if("LeCunUniform"===t)return new nk;{const e={};return e.className=t,e.config={},sk(e)}}return e instanceof Vw?e:sk(e)}function ck(e){return Array.isArray(e)&&Array.isArray(e[0])}function lk(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function uk(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new Rx("Expected Tensor length to be 1; got ".concat(e.length));t=e[0]}else t=e;return t}function hk(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new Rx("Expected exactly 1 Shape; got ".concat(e.length))}return e}function dk(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}const pk="Variable";class fk{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:pk,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=$x(),n=null==n?pk:n,this.originalName=fw(n),this.name=mw(this.originalName),this.trainable_=a,this.constraint=r,this.val=Jd(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error("LayersVariable ".concat(this.name," is already disposed."))}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function mk(e){return e.map((e=>e.read()))}function gk(e){e.forEach((e=>{e[0].write(e[1])}))}class yk{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class bk{constructor(e,t,n,a,r,s,o){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=a,this.callArgs=r,this.outputTensorIndex=o,this.id=$x(),null!=s&&(this.originalName=fw(s),this.name=mw(this.originalName)),this.rank=t.length}}let vk=0;class xk{constructor(e,t){this.callArgs=t,this.id=vk++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let wk=0;class kk extends Gc{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=wk++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=zx(e)+"_"+tw(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new Ex("The layer has never been called "+"and thus has no defined ".concat(t,"."));if(this.inboundNodes.length<=e)throw new Rx("Asked to get ".concat(t," at node ").concat(e,", ")+"but the layer has only ".concat(this.inboundNodes.length," inbound nodes."));return this.inboundNodes[e]}getInputAt(e){return Lx(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Lx(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Tx("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new Tx("Layer ".concat(this.name)+" is not connected, no input to return.");return Lx(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Tx("Layer ".concat(this.name)+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new Tx("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return Lx(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=Px(e),null==this.inputSpec||0===this.inputSpec.length)return;const t=Px(this.inputSpec);if(e.length!==t.length)throw new Rx("Layer ".concat(this.name," expects ").concat(t.length," inputs, ")+"but it received ".concat(e.length," input tensors. ")+"Input received: ".concat(e));for(let n=0;n<e.length;n++){const a=e[n],r=t[n];if(null==r)continue;const s=a.rank;if(null!=r.ndim&&s!==r.ndim)throw new Rx("Input ".concat(n," is incompatible with layer ").concat(this.name,": ")+"expected ndim=".concat(r.ndim,", found ndim=").concat(s));if(null!=r.maxNDim&&s>r.maxNDim)throw new Rx("Input ".concat(n," is incompatible with layer ").concat(this.name)+": expected max_ndim=".concat(r.maxNDim,", found ndim=").concat(s));if(null!=r.minNDim&&s<r.minNDim)throw new Rx("Input ".concat(n," is incompatible with layer ").concat(this.name)+": expected min_ndim=".concat(r.minNDim,", found ndim=").concat(s,"."));if(null!=r.dtype&&a.dtype!==r.dtype)throw new Rx("Input ".concat(n," is incompatible with layer ").concat(this.name," ")+": expected dtype=".concat(r.dtype,", found dtype=").concat(a.dtype,"."));if(r.axes){const e=a.shape;for(const t in r.axes){const a=Number(t),s=r.axes[t],o=a>=0?e[a]:e[e.length+a];if(null!=s&&-1===[s,null].indexOf(o))throw new Rx("Input ".concat(n," is incompatible with layer ")+"".concat(this.name,": expected axis ").concat(a," of input shape to ")+"have value ".concat(s," but got shape ").concat(e,"."))}}if(null!=r.shape)for(let e=0;e<r.shape.length;++e){const t=r.shape[e],s=a.shape[e];if(null!=t&&null!=s&&t!==s)throw new Rx("Input ".concat(n," is incompatible with layer ")+"".concat(this.name,": expected shape=").concat(r.shape,", ")+"found shape=".concat(a.shape,"."))}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=Px(e);let a=!0;for(const s of n)if(!(s instanceof bk)){a=!1;break}let r=!0;for(const s of n)if(s instanceof bk){r=!1;break}if(a===r)throw new Rx("Arguments to apply() must be all SymbolicTensors or all Tensors");return pw(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of Px(e))t.push(n.shape);this.build(Lx(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let a=this.call(e,t);const r=Px(a),s=[];for(let e of r)-1!==n.indexOf(e)&&(e=e.clone()),s.push(e);if(a=Lx(s),null!=this.activityRegularizer)throw new Ax("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}{const n=function(e){e=Px(e);const t=[];for(const n of e)t.push(n.shape);return Lx(t)}(e),a=this.computeOutputShape(n);let r;const s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),r=null!=a&&a.length>0&&Array.isArray(a[0])?a.map(((n,a)=>new bk(s,n,this,Px(e),t,this.name,a))):new bk(s,a,this,Px(e),t,this.name),this.addInboundNode(e,r,null,null,n,a,t),this._refCount++,null!=this.activityRegularizer)throw new Ax("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+"".concat(JSON.stringify(e),") does not match that of the ")+"batchInputShape (".concat(JSON.stringify(this.batchInputShape),") ")+"of the layer ".concat(this.name));else{let t=!1;this.batchInputShape.forEach(((n,a)=>{null!=n&&null!=e[a]&&e[a]!==n&&(t=!0)})),t&&console.warn("The shape of the input tensor "+"(".concat(JSON.stringify(e),") does not ")+"match the expectation of layer ".concat(this.name,": ")+"".concat(JSON.stringify(this.batchInputShape)))}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Tx("The layer ".concat(this.name," has never been called and thus has no ")+"defined output shape.");const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Tx("The layer ".concat(this.name," has multiple inbound nodes with different ")+'output shapes. Hence the notion of "output shape" is ill-defined for the layer.')}countParams(){if(!this.built)throw new Ex("You tried to call countParams() on ".concat(this.name,", ")+"but the layer is not built yet. Build it first by calling build(batchInputShape).");return dk(this.weights)}build(e){this.built=!0}getWeights(){return mk(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){Xc((()=>{const t=this.weights;if(t.length!==e.length)throw new Rx('You called setWeights(weights) on layer "'.concat(this.name,'" ')+"with a weight list of length ".concat(e.length,", ")+"but the layer was expecting ".concat(t.length," weights. ")+"Provided weights: ".concat(e,"..."));if(0===t.length)return;const n=[],a=mk(t);for(let r=0;r<a.length;++r){const s=a[r],o=t[r],i=e[r];if(!Ot(s.shape,i.shape))throw new Rx("Layer weight shape ".concat(s.shape," ")+"not compatible with provided weight shape ".concat(i.shape));n.push([o,i])}gk(n)}))}addWeight(e,t,n,a,r,s,o,i){if(-1!==this._addedWeightNames.indexOf(e))throw new Rx("Duplicate weight name ".concat(e," for layer ").concat(this.name));this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(a=null!=i?i():ik("zeros"));const c=a.apply(t,n),l=new fk(c,n,e,s,o);return c.dispose(),null!=r&&this.addLoss((()=>r.apply(l.read()))),null==s&&(s=!0),s?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=Px(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.");t.forEach((e=>{if(null!=e)throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.")}))}return null}return t}addInboundNode(e,t,n,a,r,s){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const i=Px(e);t=Px(t),n=Px(n),a=Px(a),r=lk(r),s=lk(s);const c=[],l=[],u=[];for(const h of i)c.push(h.sourceLayer),l.push(h.nodeIndex),u.push(h.tensorIndex);new xk({outboundLayer:this,inboundLayers:c,nodeIndices:l,tensorIndices:u,inputTensors:i,outputTensors:t,inputMasks:n,outputMasks:a,inputShapes:r,outputShapes:s},o);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error("Layer '".concat(this.name,"' is already disposed."))}dispose(){if(!this.built)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been ")+"built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been used ")+"yet.");this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function Sk(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const a=Sk(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of a)-1===t.indexOf(e)&&t.push(e)}return t}}}class Ik extends kk{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:tw("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new Rx("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new Rx("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new Rx("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const a=new bk(this.dtype,this.batchInputShape,this,[],{},this.name);a.nodeIndex=0,a.tensorIndex=0,new xk({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new Rx("Cannot pass any input to an "+"InputLayer's apply() method. InputLayer name: ".concat(this.name))}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}Ik.className="InputLayer",Hc(Ik);class Nk{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Nk)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new Rx("Duplicate key: name=".concat(e.name,", id=").concat(e.id));return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return Xi(t,e.dtype)}catch(XV){throw new Rx("The dtype of the feed (".concat(t.dtype,") can not be cast to the dtype ")+"of the key '".concat(e.name,"' (").concat(e.dtype,")."))}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof bk){if(null==this.id2Value[e.id])throw new Rx("Nonexistent key: ".concat(e.name));return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new Rx("Feed dict has no SymbolicTensor name: ".concat(e));return this.id2Value[t]}}getMask(e){if(e instanceof bk){if(null==this.id2Value[e.id])throw new Rx("Nonexistent key: ".concat(e.name));return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new Rx("Feed dict has no SymbolicTensor name: ".concat(e));return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&Yc(this.id2Mask)}}const Ck=new Fx,Tk=new Fx;function Ek(e,t,n,a){const r=null!=n&&n.training,s=Array.isArray(e),o=s?e:[e],i=o.map((e=>e.name)),c=[],l=t.names();for(const f of i)-1!==l.indexOf(f)?c.push(t.getValue(f)):c.push(null);null!=a&&(a.maxNumTensors=-1/0,a.minNumTensors=1/0);const u=i.join(",")+"|"+t.names().sort().join(",");let h,d=Ck.get(u);if(null==d){const e=function(e,t){Et(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],a={};if(1===e.length){const r=Ak(e[0],t);n=r.sorted,a=r.recipientMap}else{const r=new Set;for(const s of e){const{sorted:e,recipientMap:o}=Ak(s,t);for(const t of e)r.has(t.name)||(n.push(t),r.add(t.name));for(const t in o)null==a[t]&&(a[t]=new Set),o[t].forEach((e=>a[t].add(e)))}}return{sorted:n,recipientCounts:Rk(a)}}(o,t);d=e.sorted,h=e.recipientCounts,Ck.put(u,d),Tk.put(u,h)}h={},r||Object.assign(h,Tk.get(u));const p=new Nk(t);for(let f=0;f<d.length;++f){if(null!=a){const e=qc().numTensors;e>a.maxNumTensors&&(a.maxNumTensors=e),e<a.minNumTensors&&(a.minNumTensors=e)}const e=d[f],s=e.sourceLayer;if(s instanceof Ik)continue;const o=[],l=[],u=[];let m=!1;for(const n of e.inputs){const e=p.getValue(n),a=p.getMask(n);o.push(e),l.push(a),null!=a&&(m=!0),r||(h[n.name]--,0!==h[n.name]||t.hasKey(n)||-1!==i.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||u.push(e))}m&&((n=n||{}).mask=l[0]);const g=Px(s.apply(o,n));let y=null;s.supportsMasking&&(y=s.computeMask(o,l));const b=_k(e),v=Array.isArray(b)?b:[b];for(let t=0;t<v.length;++t){p.hasKey(v[t])||p.add(v[t],g[t],Array.isArray(y)?y[0]:y);const e=i.indexOf(v[t].name);-1!==e&&(c[e]=g[t])}r||Yc(u)}return p.disposeMasks(),s?c:c[0]}function Rk(e){const t={};for(const n in e)t[n]=e[n].size;return t}function Ak(e,t){const n=new Set,a=[],r={};for(const i of t.names())n.add(i);const s=[],o=[];for(s.push(e);s.length>0;){const e=s[s.length-1];if(n.has(e.name)){s.pop();continue}const t=o[o.length-1]===s.length-1;if(0===e.inputs.length||t)s.pop(),a.push(e),n.add(e.name),t&&o.pop();else{o.push(s.length-1);for(const t of e.inputs)null==r[t.name]&&(r[t.name]=new Set),r[t.name].add(e.name),n.has(t.name)||s.push(t)}}return{sorted:a,recipientMap:r}}function _k(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const a of e.sourceLayer.inboundNodes[t].outputTensors)if(a.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function Fk(e,t){return Xc((()=>zu(Wu(Ml(e,e),t,!0))))}hn().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=Ck&&Ck.setMaxEntries(e),null!=Tk&&Tk.setMaxEntries(e)}));class Ok extends Gc{getConfig(){return{}}}class Dk extends Ok{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Xc((()=>{const t=Fk(e,this.axis),n=Zl(t,0,this.maxValue);return Ml(e,bu(n,sl(Sw(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}Dk.className="MaxNorm",Hc(Dk);class Mk extends Ok{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Xc((()=>bu(e,sl(Sw(),Fk(e,this.axis)))))}getConfig(){return{axis:this.axis}}}Mk.className="UnitNorm",Hc(Mk);class Lk extends Ok{apply(e){return ud(e)}}Lk.className="NonNeg",Hc(Lk);class Pk extends Ok{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Xc((()=>{const t=Fk(e,this.axis),n=sl(Ml(this.rate,Zl(t,this.minValue,this.maxValue)),Ml(1-this.rate,t));return Ml(e,bu(n,sl(Sw(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}Pk.className="MinMaxNorm",Hc(Pk);const zk={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Bk(e){return Ux(e)}function Wk(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Gx(e,jc.getMap().classNameMap,t,"constraint")}function Uk(e){if(null==e)return null;if("string"===typeof e){return Wk({className:e in zk?zk[e]:e,config:{}})}return e instanceof Ok?e:Wk(e)}async function Vk(e){if(null==e)return;const t=[],n=[],a=[];for(const r in e){const s=e[r];if("number"!==typeof s){const e=s;t.push(e.data()),n.push(r),a.push(e)}}if(t.length>0){const r=await Promise.all(t);for(let t=0;t<r.length;++t)e[n[t]]=r[t][0];Yc(a)}}function Gk(e){if(null!=e)for(const t in e){const n=e[t];"number"!==typeof n&&n.dispose()}}var jk;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(jk||(jk={}));class Hk{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class Kk{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class qk extends Hk{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const a in t){const e=t[a];if("number"===typeof e)this.totals.hasOwnProperty(a)||(this.totals[a]=0),this.totals[a]=this.totals[a]+e*n;else{let t;a in this.totals?t=this.totals[a]:this.totals[a]=0;const r=Xc((()=>sl(this.totals[a],Ml(e,n))));this.totals[a]=r,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?t[n]=this.totals[n]/this.seen:Xc((()=>{const e=Ml(bu(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),Zc(t[n])})))}}class Xk extends Hk{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){const e=[],t=[],n=[];for(const r in this.history){const a=this.history[r];for(let s=0;s<a.length;++s)if("number"!==typeof a[s]){const o=a[s];e.push(o.data()),t.push(r),n.push(s)}}const a=await Promise.all(e);for(let r=0;r<a.length;++r){this.history[t[r]][n[r]].dispose(),this.history[t[r]][n[r]]=a[r][0]}}}class Yk extends Hk{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Pf,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");qt(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let a,r=null!=n?n():Xs();return function(){const s=null!=n?n():Xs();return s-r<t||(r=s,a=e(...arguments)),a}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const a=[];null!=this.yield&&(await Vk(n),a.push(this.yield(e,t,n))),a.push(this.nextFrameFunc()),await Promise.all(a)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await Vk(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await Vk(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await Vk(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await Vk(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):qt(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await Vk(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await Vk(e),await this.trainEnd(e))}}function Zk(e,t){if(null==e&&(e={}),e instanceof Hk)return[e];if(Array.isArray(e)&&e[0]instanceof Hk)return e;return Px(e).map((e=>new Yk(e,t)))}class Qk{constructor(){}static registerCallbackConstructor(e,t){Et(e>=0&&Number.isInteger(e),(()=>"Verbosity level is expected to be an integer >= 0, "+"but got ".concat(e))),Qk.checkForDuplicate(t),null==Qk.constructors[e]&&(Qk.constructors[e]=[]),Qk.constructors[e].push(t)}static checkForDuplicate(e){for(const t in Qk.constructors){Qk.constructors[+t].forEach((t=>{if(t===e)throw new Rx("Duplicate callback constructor.")}))}}static clear(){Qk.constructors={}}static createCallbacks(e){const t=[];for(const n in Qk.constructors){const a=+n;e>=a&&t.push(...Qk.constructors[a])}return t.map((e=>new e))}}function Jk(e,t,n,a,r,s,o,i,c){const l=new Xk,u=[new qk,...Qk.createCallbacks(t)];null!=e&&u.push(...e),u.push(l);const h=new Kk(u);return h.setParams({epochs:n,initialEpoch:a,samples:r,steps:s,batchSize:o,verbose:t,doValidation:i,metrics:c}),{callbackList:h,history:l}}function $k(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Gx(e,jc.getMap().classNameMap,t,"layer",n)}function eS(e,t){return Xc((()=>{"float32"!==e.dtype&&(e=Xi(e,"float32"));const n=Wu(Mw(e),t,!0),a=Yl(n.shape,Sw()),r=zu(Ch(n,a));return bu(e,r)}))}function tS(e,t){return Xc((()=>Th(Mw(ph(t,e)),-1)))}function nS(e,t){return Xc((()=>Th(nl(ph(t,e)),-1)))}function aS(e,t){return Xc((()=>{const n=ph(e,t),a=Zl(nl(e),Sw(),Number.MAX_VALUE),r=nl(bu(n,a));return Ml(100,Th(r,-1))}))}function rS(e,t){return Xc((()=>{const n=Zl(t,Sw(),Number.MAX_VALUE),a=ch(sl(1,n)),r=Zl(e,Sw(),Number.MAX_VALUE),s=ch(sl(1,r));return Th(Mw(ph(a,s)),-1)}))}function sS(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Xc((()=>{if(n)t=Rd(t);else{const e=Wu(t,t.shape.length-1,!0);t=bu(t,e)}return t=Zl(t,Sw(),1-Sw()),uh(Wu(Ml(Xi(e,"float32"),ch(t)),t.shape.length-1))}))}function oS(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Xc((()=>{const a=Xi(Yu(function(e){const t=[bw(e.shape)];return Al(e,t)}(e)),"int32"),r=(t=Zl(t,Sw(),1-Sw())).shape;return sS(Al(zh(a,r[r.length-1]),r),t,n)}))}function iS(e,t){return Xc((()=>{let n;return n=Zl(t,Sw(),1-Sw()),n=ch(bu(n,ph(1,n))),Th(function(e,t){if(!Ot(e.shape,t.shape))throw new Rx("logits and labels must have the same shape, but got shapes "+"".concat(JSON.stringify(e.shape)," and ").concat(JSON.stringify(t.shape)));return Xc((()=>{const n=ud(t),a=uh(nl(t));return sl(ph(n,Ml(t,e)),lh(ju(a)))}))}(e,n),-1)}))}function cS(e,t){return Xc((()=>{const n=Zl(e,Sw(),1),a=Zl(t,Sw(),1);return Wu(Ml(e,ch(bu(n,a))),-1)}))}function lS(e,t){return Xc((()=>{const n=eS(e,-1),a=eS(t,-1),r=Ml(n,a);return uh(Wu(r,-1))}))}Qk.constructors={};const uS={meanSquaredError:tS,meanAbsoluteError:nS,meanAbsolutePercentageError:aS,meanSquaredLogarithmicError:rS,squaredHinge:function(e,t){return Xc((()=>{const n=Ch(0,ph(1,Ml(e,t)));return Th(Mw(n),-1)}))},hinge:function(e,t){return Xc((()=>{const n=Ch(0,ph(1,Ml(e,t)));return Th(n,-1)}))},categoricalHinge:function(e,t){return Xc((()=>{const n=Wu(Ml(e,t),-1),a=Mu(Ml(ph(1,e),t),-1);return Ch(0,sl(1,ph(a,n)))}))},logcosh:function(e,t){return Xc((()=>{const n=Math.log(2),a=ph(t,e),r=ph(sl(a,hh(Ml(-2,a))),n);return Th(r,-1)}))},categoricalCrossentropy:sS,sparseCategoricalCrossentropy:oS,binaryCrossentropy:iS,kullbackLeiblerDivergence:cS,poisson:function(e,t){return Xc((()=>{const n=ch(sl(Sw(),t));return Th(ph(t,Ml(e,n)),-1)}))},cosineProximity:lS};function hS(e){if("string"===typeof e){if(e in uS)return uS[e];let t="Unknown loss ".concat(e);throw e.toLowerCase().includes("softmaxcrossentropy")&&(t="Unknown loss ".concat(e,". ")+'Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new Rx(t)}return e}function dS(e,t){return Xc((()=>{const n=Ml(.5,Bh(t)),a=Iw(Qu(t,n),e.dtype);return Th(vu(e,a),-1)}))}function pS(e,t){return Xc((()=>Iw(vu(ll(e,-1),ll(t,-1)),"float32")))}function fS(e,t){return Xc((()=>Xi(Wu(gh(vu(e,1),vu(t,1))),"float32")))}function mS(e,t){return iS(e,t)}function gS(e,t){return e.rank===t.rank&&(e=Ld(e,[e.rank-1])),(t=ll(t,-1)).dtype!==e.dtype&&(t=Xi(t,e.dtype)),Xi(vu(e,t),"float32")}const yS=sS,bS=oS,vS={binaryAccuracy:dS,categoricalAccuracy:pS,precision:function(e,t){return Xc((()=>{const n=fS(e,t),a=function(e,t){return Xc((()=>Xi(Wu(gh(vu(e,0),vu(t,1))),"float32")))}(e,t),r=sl(n,a);return Xi(xu(Qu(r,0),bu(n,r),0),"float32")}))},categoricalCrossentropy:yS,sparseCategoricalCrossentropy:bS,mse:tS,MSE:tS,mae:nS,MAE:nS,mape:aS,MAPE:aS,cosine:lS};function xS(e){if("string"===typeof e&&e in vS)return vS[e];if("string"!==typeof e&&null!=e)return e;throw new Rx("Unknown metric ".concat(e))}function wS(e){if(Dx(null!==e,"Unknown LossOrMetricFn ".concat(e)),"string"===typeof e)return e;{let t;for(const n of Object.keys(uS))if(uS[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(vS))if(vS[n]===e){t=n;break}return void 0!==t?t:e.name}}const kS=1048576;function SS(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!==typeof e||Object.getPrototypeOf(e)!==Object.prototype||!IS(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>kS&&console.warn('User-defined metadata of model "'.concat(t,'" is too large in ')+"size (length=".concat(n.length," when serialized). It is not ")+"recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= "+"".concat(kS,"."))}}function IS(e){if(null===e)return!0;if("object"===typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!==typeof n)return!1;if(!IS(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!IS(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function NS(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const r=function(e){let t=!0;const n=[],a=[];for(const r in e.nodesByDepth)n.push(e.nodesByDepth[r]);for(const r of n){if(r.length>1||1===r.length&&r[0].inboundLayers.length>1){t=!1;break}a.push(...r)}if(t)for(const r of e.layers){let e=!1;for(const n of r.inboundNodes)if(-1!==a.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),s=["Layer (type)","Input Shape","Output shape","Param #"];let o;if(r?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!r){s.push("Receives inputs"),o=[];for(const t in e.nodesByDepth)o.push(...e.nodesByDepth[t])}a("_".repeat(t)),CS(s,n,a),a("=".repeat(t));const i=e.layers;for(let u=0;u<i.length;++u)r?TS(i[u],n,a):ES(i[u],n,o,a),a((u===i.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const c=function(e){let t;t=null!=e.collectedTrainableWeights?dk(e.collectedTrainableWeights):dk(e.trainableWeights);return t}(e),l=dk(e.nonTrainableWeights);a("Total params: ".concat(c+l)),a("Trainable params: ".concat(c)),a("Non-trainable params: ".concat(l)),a("_".repeat(t))}function CS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,a="";for(let r=0;r<e.length;++r)r>0&&(a=a.slice(0,a.length-1)+" "),a+=e[r],a=a.slice(0,t[r]),a+=" ".repeat(t[r]-a.length);n(a)}function TS(e,t,n){let a,r;try{r=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(XV){r="multiple"}try{a=JSON.stringify(e.outputShape)}catch(XV){a="multiple"}const s=e.name,o=e.getClassName();CS(["".concat(s," (").concat(o,")"),r,a,e.countParams().toString()],t,n)}function ES(e,t,n,a){let r,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(XV){s="multiple"}try{r=JSON.stringify(e.outputShape)}catch(XV){r="multiple"}const o=[];for(const u of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(let e=0;e<u.inboundLayers.length;++e){const t=u.inboundLayers[e].name,n=u.nodeIndices[e],a=u.tensorIndices[e];o.push("".concat(t,"[").concat(n,"][").concat(a,"]"))}const i=e.name,c=e.getClassName(),l=0===o.length?"":o[0];CS(["".concat(i," (").concat(c,")"),s,r,e.countParams().toString(),l],t,a);for(let u=1;u<o.length;++u)CS(["","","","",o[u]],t,a)}function RS(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"===typeof n}function AS(e,t){if(null===e)return null;if("string"===typeof e)return Bx(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],a=e.length;for(let r=0;r<a;++r){const a=e[r];RS(t,r,a)?n.push(a):n.push(AS(a,t))}return n}{const t={};for(const n of Object.keys(e)){const a=e[n];if("name"===n&&"string"===typeof a)t[n]=a;else{const e=Bx(n);t[e]=AS(a,e)}}return t}}function _S(e,t){if(null===e||void 0===e)return null;if("string"===typeof e)return zx(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],a=e.length;for(let r=0;r<a;++r){const a=e[r];RS(t,r,a)?n.push(a):n.push(_S(a,t))}return n}{const t={};for(const n of Object.keys(e)){const a=e[n],r=zx(n);t[r]="name"!==n&&"className"!==n||"string"!==typeof a?_S(a,n):a}return t}}const FS="3.21.0";class OS extends kk{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=tw(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Hx(this.inputs).length!==this.inputs.length)throw new Rx("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+"".concat(this.inputs.map((e=>e.name))));Hx(this.outputs).length!==this.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+"".concat(this.outputs.map((e=>e.name)))),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(const y of this.inputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;Dx(0===t,"input layer has >1 nodes"),Dx(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const t=this.inputLayers[y];if(!(t instanceof Ik))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. "+"Received inputs: ".concat(e.inputs,". ")+"Input ".concat(y," (0-based) originates ")+"from layer type ".concat(t.getClassName(),"."));this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},a={},r={},s={},o=[],i=(e,t,n,a,r,c)=>{null!=a&&null!=r&&null!=c||(a=e.sourceLayer,r=e.nodeIndex,c=e.tensorIndex);const l=a.inboundNodes[r];if(-1!==n.indexOf(l))throw new Ex("The tensor ".concat(e.name,' at layer "').concat(a.name,'" ')+"is part of a cycle.");if(-1!==t.indexOf(l))return;this.containerNodes.add(OS.nodeKey(a,r)),a.id in s||(s[a.id]=Object.keys(s).length),-1===n.indexOf(l)&&n.push(l);const u=l.inboundLayers.length;for(let s=0;s<u;s++){const e=l.inputTensors[s],a=l.inboundLayers[s],r=l.nodeIndices[s],o=l.tensorIndices[s];i(e,t,n,a,r,o)}for(t.push(l);n.indexOf(l)>=0;)n.splice(n.indexOf(l),1);o.push(l)},c=[],l=[];for(const y of this.outputs)i(y,c,l);const u=o.slice().reverse();for(const y of u){n[y.id]=y,y.id in t||(t[y.id]=0);let e=t[y.id];const s=null==a[y.outboundLayer.id]?0:a[y.outboundLayer.id];e=Math.max(e,s),a[y.outboundLayer.id]=e,r[y.outboundLayer.id]=y.outboundLayer,t[y.id]=e;for(let a=0;a<y.inboundLayers.length;a++){const r=y.inboundLayers[a],s=y.nodeIndices[a],o=r.inboundNodes[s],i=null==t[o.id]?0:t[o.id];t[o.id]=Math.max(e+1,i),n[o.id]=o}}const h={};for(const y in t){const e=t[y];e in h||(h[e]=[]),h[e].push(n[y])}const d={};for(const y in a){const e=a[y];e in d||(d[e]=[]),d[e].push(r[y])}let p=Object.keys(d).map((e=>parseInt(e,10))).sort(jx);this.layers=[];for(const y of p){const e=d[y];e.sort(((e,t)=>{const n=s[e.id],a=s[t.id];return n<a?-1:n>a?1:0}));for(const t of e)t instanceof OS&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=d,p=Object.keys(h).map((e=>parseInt(e,10))).sort(jx);const f=this.inputs.slice(),m=[];for(const y of p)for(const e of h[y]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new Ex("Graph disconnected: cannot obtain value for tensor ".concat(n)+' at layer "'.concat(t.name,'". ')+"The following previous layers were accessed without "+"issue: ".concat(m));for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=h;const g=this.layers.map((e=>e.name));for(const y of g){const e=g.filter((e=>e===y)).length;if(1!==e)throw new Ex('The name "'.concat(y,'" is used ').concat(e," times ")+"in the model. All layer names should be unique. Layer names: "+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new xk({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error("Container '".concat(this.name,"' is already disposed."))}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new Rx("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let a=0;for(const s of this.layers)for(const e of s.weights){if(null!=n[e.originalName])throw new Rx("Duplicate weight name: ".concat(e.originalName));n[e.originalName]=e,a++}const r=[];for(const s in e){let a=s;if(null==n[s]){const e=s.split("/");a=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[a])r.push([n[a],e[s]]);else if(t)throw new Rx("Provided weight data has no target variable: ".concat(s));delete n[a]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new Rx("".concat(e.length," of ").concat(a," weights are not set: ")+"".concat(e))}gk(r)}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion="tfjs-layers ".concat(FS),t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=_S(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return Xc((()=>{e=Px(e);const n=new Nk;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return Ek(this.outputs,n,t)}))}computeMask(e,t){return Xc((()=>{let n;return e=Px(e),n=null==t?Ox(null,e.length):Px(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=lk(e);if(t.length!==this.inputLayers.length)throw new Rx("Invalid inputShape argument ".concat(e,": ")+"model has ".concat(this.inputLayers.length," tensor inputs."));const n={};for(let o=0;o<t.length;o++){const e=this.inputLayers[o],a=t[o];n[e.name+"_0_0"]=a}const a=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(jx);if(a.length>1)for(const o of a){const e=this.nodesByDepth[o];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;const a=[];for(let o=0;o<t.inboundLayers.length;o++){const e=t.inboundLayers[o],r=t.nodeIndices[o],s=t.tensorIndices[o],i=n["".concat(e.name,"_").concat(r,"_").concat(s)];a.push(i)}const r=lk(e.computeOutputShape(Lx(a))),s=e.inboundNodes.indexOf(t);for(let t=0;t<r.length;t++){n["".concat(e.name,"_").concat(s,"_").concat(t)]=r[t]}}}const r=[],s=[];for(let o=0;o<this.outputLayers.length;o++){const e=this.outputLayers[o],t=this.outputLayersNodeIndices[o],n=this.outputLayersTensorIndices[o],a="".concat(e.name,"_").concat(t,"_").concat(n);s.push(a)}for(let o=0;o<s.length;o++){const e=s[o];Dx(e in n),r.push(n[e])}return Lx(r)}runInternalGraph(e,t){null==t&&(t=Ox(null,e.length));const n={};for(let i=0;i<this.inputs.length;++i){const a=this.inputs[i],r=e[i],s=t[i];n[a.id]=[r,s]}const a=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(jx);for(const i of a){const e=this.nodesByDepth[i];for(const t of e){const e=t.outboundLayer,a=t.inputTensors,r=t.outputTensors,s=new Array;for(const t of a)t.id in n&&s.push(n[t.id]);if(s.length===a.length){let a,o,i,c,l={};if(null!=t.callArgs&&(l=t.callArgs),1===s.length){const[t,n]=s[0];null==l.mask&&(l.mask=n),i=Px(e.call(t,l)),c=Px(e.computeMask(t,n)),a=[t],o=[n]}else a=s.map((e=>e[0])),o=s.map((e=>e[1])),null==l.mask&&(l.mask=o),i=Px(e.call(a,l)),c=Px(e.computeMask(a,o));if(e.activityRegularizer)throw new Ax("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<r.length;++e){const t=r[e],a=i[e],s=c[e];n[t.id]=[a,s]}}}}const r=[],s=[],o=[];for(const i of this.outputs){Dx(i.id in n,"Could not compute output ".concat(i.name," : ").concat(i.id));const[e,t]=n[i.id];o.push(e.shape),r.push(e),s.push(t)}return[r,s,o]}buildNodeConversionMap(e){const t={};let n;for(const a of this.layers){n=a instanceof OS?1:0;for(let e=0;e<a.inboundNodes.length;e++){const r=OS.nodeKey(a,e);this.containerNodes.has(r)&&(t[r]=n,n+=1)}}return t}getLayer(e,t){if(null!=t){if(this.layers.length<=t)throw new Rx("Was asked to retrieve layer at index ".concat(t,", but model only ")+"has ".concat(this.layers.length," layer(s)."));return this.layers[t]}if(null==e)throw new Rx("Provide either a layer name or layer index");for(const n of this.layers)if(n.name===e)return n;throw new Rx("No such layer: ".concat(e))}calculateLosses(){return Xc((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const a=OS.nodeKey(t,n);this.containerNodes.has(a)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const s of this.layers){const e=s.getClassName(),a=s.getConfig(),r=[];for(let n=0;n<s.inboundNodes.length;n++){const e=s.inboundNodes[n],a=OS.nodeKey(s,n);let o={};if(this.containerNodes.has(a)){if(e.callArgs)try{JSON.stringify(e.callArgs),o=e.callArgs}catch(XV){console.warn("Layer ".concat(s.name," was passed ")+"non-serializable keyword arguments: "+"".concat(e.callArgs,". They will not be included ")+"in the serialized model (and thus will be missing at deserialization time)."),o={}}if(e.inboundLayers.length>0){const n=[];for(let a=0;a<e.inboundLayers.length;a++){const r=e.inboundLayers[a],s=e.nodeIndices[a],i=e.tensorIndices[a];let c=t[OS.nodeKey(r,s)];null==c&&(c=0),n.push([r.name,c,i,o])}r.push(n)}}}const o={};o.name=s.name,o.className=e,o.config=a,o.inboundNodes=r,n.push(o)}e.layers=n;const a=[];for(let s=0;s<this.inputLayers.length;s++){const e=this.inputLayers[s],n=this.inputLayersNodeIndices[s],r=OS.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let o=t[r];null!==o&&void 0!==o||(o=0);const i=this.inputLayersTensorIndices[s];a.push([e.name,o,i])}e.inputLayers=a;const r=[];for(let s=0;s<this.outputLayers.length;s++){const e=this.outputLayers[s],n=this.outputLayersNodeIndices[s],a=OS.nodeKey(e,n);if(!this.containerNodes.has(a))continue;let o=t[a];null!==o&&void 0!==o||(o=0);const i=this.outputLayersTensorIndices[s];r.push([e.name,o,i])}return e.outputLayers=r,e}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={},r={};function s(e,t){e.name in r?r[e.name].push(t):r[e.name]=[t]}function o(e,t){const n=[];let r;for(const o of t){const i=o[0],c=o[1],l=o[2];if(r=null==o[3]?{}:o[3],!(i in a))return void s(e,t);const u=a[i];if(u.inboundNodes.length<=c)return void s(e,t);const h=u.inboundNodes[c];n.push(h.outputTensors[l])}n.length>0&&e.apply(Lx(n),r)}function i(e){const r=e.name,o=$k(e,null!=t.customObjects?t.customObjects:{});o.setFastWeightInitDuringBuild(n),a[r]=o;e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new Rx("Corrupted configuration, expected array for nodeData: ".concat(e));s(o,e)}))}const c=t.name,l=t.layers;for(const f of l)i(f);for(;!Kx(r);)for(const e of l){const t=a[e.name];if(t.name in r){const e=r[t.name];delete r[t.name];for(const n of e)o(t,n)}}const u=[],h=[],d=t.inputLayers;for(const f of d){const e=f[0],t=f[1],n=f[2];Dx(e in a);const r=a[e].inboundNodes[t].outputTensors;u.push(r[n])}const p=t.outputLayers;for(const f of p){const e=f[0],t=f[1],n=f[2];Dx(e in a);const r=a[e].inboundNodes[t].outputTensors;h.push(r[n])}return new e({inputs:u,outputs:h,name:c})}get stateful(){if(this._stateful)throw new Rx("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Xc((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}function DS(e,t,n){const a=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===a)return Array.isArray(e)&&1===e.length?e:"object"===typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==a)throw new Error("Provided ".concat(n," is an array of ").concat(e.length," ")+"element(s), but the model has ".concat(a," outputs. ")+"Make sure a set of weights is provided for each model output.");return e}if("object"===typeof e&&Object.keys(e).length>0&&"object"===typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error("The model has multiple (".concat(a,") outputs, ")+"so ".concat(n," must be either an array with ")+"".concat(a," elements or an object with ").concat(t," keys. ")+"Provided ".concat(n," not understood: ").concat(JSON.stringify(e)))}function MS(e,t){return DS(e,t,"classWeight")}async function LS(e,t,n,a){if(null!=t||null!=a)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=Xc((()=>{if(1===e.shape.length)return Yi(e);if(2===e.shape.length){if(e.shape[1]>1){return ll(e,1)}if(1===e.shape[1])return Al(e,[e.shape[0]]);throw new Error("Encountered unexpected last-dimension size (".concat(e.shape[1],") ")+"during handling of class weights. The size is expected to be >= 1.")}throw new Error("Unexpected rank of target (y) tensor (".concat(e.rank,") during ")+"handling of class weights. The rank is expected to be 1 or 2.")})),a=Array.from(await t.data());Yc(t);const r=[];return a.forEach((e=>{if(null==n[e])throw new Error("classWeight must contain all classes in the training data. "+"The class ".concat(e," exists in the data but not in ")+"classWeight");r.push(n[e])})),Ud(r,"float32")}return null}function PS(e,t){return Ml(e,t)}function zS(e,t){let n,a;const r=t;n=r.xs,a=r.ys,Et(null!=n&&null!=a,(()=>"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+"".concat(t)));const s=BS("input",e.inputNames,n),o=BS("output",e.outputNames,a),i=s[0].shape[0];Et(s.length===e.inputs.length,(()=>"LayersModel has ".concat(e.inputs.length," inputs, but the dataset ")+"provides ".concat(s.length," inputs.  (Expected input keys: ")+"".concat(JSON.stringify(e.inputNames),")"))),Et(o.length===e.outputs.length,(()=>"LayersModel has ".concat(e.outputs.length," outputs, but the dataset ")+"provides ".concat(o.length," outputs.  (Expected output keys: ")+"".concat(JSON.stringify(e.outputNames),")")));for(let c=0;c<s.length;c++)Et(s[c].shape[0]===i,(()=>"Batch size mismatch: input "+"".concat(e.inputNames[c]," has ").concat(s[c].shape[0],"; ")+"expected  ".concat(i," based on input ").concat(e.inputNames[0],".")));for(let c=0;c<o.length;c++)Et(o[c].shape[0]===i,(()=>"Batch size mismatch: output "+"".concat(e.outputNames[c]," has ").concat(o[c].shape[0],"; ")+"expected  ".concat(i," based on input ").concat(e.inputNames[0],".")));return{xs:s,ys:o}}function BS(e,t,n){if(n instanceof po)return[n];if(Array.isArray(n))return Et(n.length===t.length,(()=>"Received an array of ".concat(n.length," Tensors, but expected ").concat(t.length," to match the ").concat(e," keys ").concat(t,"."))),n;{const a=[];for(const r of t){if(null==n[r])throw new Rx("The feature data generated by the dataset lacks the required "+"".concat(e," key '").concat(r,"'."));a.push(n[r])}return a}}async function WS(e,t,n){const a=null!=n.batchesPerEpoch;if(Et(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),Et(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),Et(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>"For fitDataset(), config.epochs is expected to be a positive "+"integer, but got ".concat(n.epochs))),Et(!a||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>"For fitDataset(), config.batchesPerEpoch is expected to be a "+"positive integer if specified, but got ".concat(n.batchesPerEpoch))),Et(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const r=null!=n.validationData;let s,o;if(r)if(US(n.validationData))Et(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, "+"but got ".concat(n.validationBatches)));else{const e=function(e){if(3===e.length)throw new Ax("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);s=e.xs,o=e.ys}const i=e.makeTrainFunction(),c=e.getDedupedMetricsNames();let l;l=r?c.slice().concat(c.map((e=>"val_"+e))):c.slice();const u=Zk(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=Jk(u,h,n.epochs,null,null,function(e,t){let n=null;null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size);return n}(t,n),null,r,l);d.setModel(e),e.history=p,await d.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){const l={};await d.onEpochBegin(f);let u=0,h=0;for(a||(m=await t.iterator());!a||u<n.batchesPerEpoch;){const t=await m.next();if(a&&t.done){console.warn("You provided `batchesPerEpoch` as "+"".concat(n.batchesPerEpoch,", ")+"but your dataset iterator ran out of data after "+"".concat(u," batches; ")+"interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+"".concat(n.batchesPerEpoch*n.epochs," batches). ")+"You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:a,ys:r}=zS(e,t.value),s={};s.batch=h,s.size=a[0].shape[0],await d.onBatchBegin(h,s);const o=[];if(null!=n.classWeight){const t=MS(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)o.push(await LS(r[e],null,t[e]))}const l=a.concat(r).concat(o),p=i(l);Yc(l);for(let e=0;e<c.length;++e){const t=c[e],n=p[e];s[t]=n,Zc(n)}await d.onBatchEnd(h,s),Gk(s),h++,u++}if(a?u>=n.batchesPerEpoch:t.done){if(r){let t;t=US(n.validationData)?Px(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):Px(e.evaluate(s,o,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)l["val_".concat(e.metricsNames[n])]=t[n]}break}if(e.stopTraining_)break}if(await d.onEpochEnd(f,l),f++,e.stopTraining_)break}return await d.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function US(e){return"function"===typeof e.iterator}function VS(e){Et(e>0&&Number.isInteger(e),(()=>"batchSize is required to be a positive integer, but got ".concat(e)))}function GS(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>Cw(e,t,n-t))):Cw(e,t,n-t)}function jS(e,t){return Xc((()=>null==e?null:Array.isArray(e)?e.map((e=>jS(e,t))):Dw(e,"int32"===t.dtype?t:Xi(t,"int32"))))}function HS(e,t){const n=[];let a=0,r=null;for(;a<e;)r=a+t,r>=e&&(r=e),n.push([a,r]),a=r;return n}async function KS(e,t,n){let a,r,s,o,i,c,l,u,h,d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const p=null==d.batchSize?32:d.batchSize;VS(p);const f=!1,m=await e.standardizeUserData(t,n,d.sampleWeight,d.classWeight,f,p);a=m[0],r=m[1],h=m[2];let g,y=!1;if(null!=d.validationData&&d.validationData.length>0){if(y=!0,2!==d.validationData.length)throw 3===d.validationData.length?new Ax("validationData including sample weights is not supported yet."):new Rx("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+"".concat(d.validationData," is invalid."));i=d.validationData[0],c=d.validationData[1];const t=!0,n=await e.standardizeUserData(i,c,null,null,t,p);l=n[0],u=n[1],g=l.concat(u)}else if(null!=d.validationSplit&&d.validationSplit>0&&d.validationSplit<1){y=!0;const e=Math.floor(a[0].shape[0]*(1-d.validationSplit)),t=a[0].shape[0];l=GS(a,e,t),s=a,a=GS(a,0,e),u=GS(r,e,t),o=r,r=GS(r,0,e),g=l.concat(u)}else null!=d.validationSteps&&(y=!0);const b=a.concat(r).concat(h);e.checkTrainableWeightsConsistency();const v=e.makeTrainFunction(),x=e.getDedupedMetricsNames();let w,k;y?(e.makeTestFunction(),w=e.testFunction,k=x.slice().concat(x.map((e=>"val_"+e)))):(w=null,g=[],k=x.slice());const S=Zk(d.callbacks,d.yieldEvery),I=await async function(e,t,n,a,r,s,o,i,c,l,u,h,d,p,f){null==r&&(r=32),null==s&&(s=1),null==u&&(u=!0),null==d&&(d=0);let m=!1;if(null!=c&&null!=l&&(m=!0),null!=f&&(m=!0,null==p))throw new Rx("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=e.checkNumSamples(n,r,p,"steps_per_epoch");let y;null!=g&&(y=ww(0,g)),null==o&&(o=1);const{callbackList:b,history:v}=Jk(i,o,s,d,g,p,r,m,h);b.setModel(e),e.history=v,await b.onTrainBegin(),e.stopTraining_=!1;for(let x=d;x<s;++x){await b.onEpochBegin(x);const s={};if(null!=p)throw new Ax("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new Ax("batch shuffling is not implemneted yet");u&&It(y);const o=Ud(y),i=HS(g,r);for(let u=0;u<i.length;++u){const h={};if(await b.onBatchBegin(u,h),Xc((()=>{const d=i[u][0],p=i[u][1],f=Cw(o,d,p-d);h.batch=u,h.size=p-d;const g=jS(n,f),y=t(g);for(let e=0;e<a.length;++e){const t=a[e],n=y[e];h[t]=n,Zc(n)}if(u===i.length-1&&m){const t=e.testLoop(c,l,r);for(let e=0;e<a.length;++e){const n=a[e],r=t[e];Zc(r),s["val_"+n]=r}}})),await b.onBatchEnd(u,h),Gk(h),e.stopTraining_)break}o.dispose()}if(await b.onEpochEnd(x,s),e.stopTraining_)break}return await b.onTrainEnd(),await e.history.syncData(),e.history}(e,v,b,x,p,d.epochs,d.verbose,S,w,g,d.shuffle,k,d.initialEpoch,null,null);return I}finally{e.isTraining=!1,XS(a,t),XS(r,n),XS(s,t),XS(o,n),XS(l,i),XS(u,c),null!=h&&Yc(h)}}function qS(e){const t=[];e instanceof po&&(e=[e]);for(let n=0;n<e.length;++n){const a=e[n];if(1===a.rank)t.push(Nw(a,1));else{if(0===a.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(a)}}return t}function XS(e,t){if(null==e)return;const n=[];if(t instanceof po)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const r in t){const e=t[r];n.push(e.id)}const a=[];if(e instanceof po)-1===n.indexOf(e.id)&&a.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&a.push(e)}));else if(null!=e)for(const r in e){const t=e[r];-1===n.indexOf(t.id)&&a.push(t)}a.forEach((e=>{e.isDisposed||e.dispose()}))}function YS(e){return Array.isArray(e)}function ZS(e){return!function(e){return e instanceof po}(e)&&!YS(e)}function QS(e,t,n){let a,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(YS(e)&&e.length>0)t=!0;else if(ZS(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new Rx("Error when checking model ".concat(s," expected no data, ")+"but got ".concat(e))}return[]}if(null==e)return t.map((e=>null));if(ZS(e)){a=[];for(const n of t){if(null==e[n])throw new Rx('No data provided for "'.concat(n,'". Need data for each key in: ')+"".concat(t));a.push(e[n])}}else if(YS(e)){if(e.length!==t.length)throw new Rx("Error when checking model ".concat(s,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"model expected. Expected to see ".concat(t.length," Tensor(s), but ")+"instead got the following list of Tensor(s): ".concat(e));a=e}else{if(t.length>1)throw new Rx("The model ".concat(s," expects ").concat(t.length," Tensor(s), ")+"but only received one Tensor. Found: Tensor with shape ".concat(e.shape));a=[e]}if(a=qS(a),null!=n)for(let o=0;o<t.length;++o){if(null==n[o])continue;const e=a[o];if(e.shape.length!==n[o].length)throw new Rx("Error when checking ".concat(s,": expected ").concat(t[o]," ")+"to have ".concat(n[o].length," dimension(s). but got array with ")+"shape ".concat(e.shape));for(let t=0;t<n[o].length;++t){if(0===t&&!r)continue;const a=e.shape[t],i=n[o][t];if(null!=i&&i>=0&&a!==i)throw new Rx("".concat(s," expected a batch of elements where each ")+"example has shape [".concat(n[o].slice(1,n[o].length),"] ")+"(i.e.,tensor shape [*,".concat(n[o].slice(1,n[o].length),"])")+" but the ".concat(s," received an input with ").concat(e.shape[0])+" examples, each with shape [".concat(e.shape.slice(1,e.shape.length),"]")+" (tensor shape [".concat(e.shape,"])"))}}return a}function JS(e,t,n){let a,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new Rx("Error when checking model ".concat(s,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"the model expected. Expected to see ".concat(t.length," Tensor(s),")+" but instead got ".concat(e.length," Tensors(s)."));a=e}else{if(t.length>1)throw new Rx("The model expects ".concat(t.length," ").concat(s," Tensors, ")+"but only received one Tensor. Found: array with shape "+"".concat(JSON.stringify(e.shape),"."));a=[e]}if(null!=n)for(let o=0;o<t.length;++o){if(null==n[o])continue;const e=a[o];if(e.shape.length!==n[o].length)throw new Rx("Error when checking ".concat(s,": expected ").concat(t[o]," ")+"to have ".concat(n[o].length," dimension(s), but got array with ")+"shape ".concat(JSON.stringify(e.shape)));for(let a=0;a<n[o].length;++a){if(0===a&&!r)continue;const i=e.shape[a],c=n[o][a];if(null!=c&&c!==i)throw new Rx("Error when checking ".concat(s,": expected ")+"".concat(t[o]," to have shape ").concat(JSON.stringify(n[o])," but ")+"got array with shape ".concat(JSON.stringify(e.shape),"."))}}}class $S extends OS{constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new Rx("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");NS(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"===typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>Mf.adagrad(.01),Adadelta:()=>Mf.adadelta(1,.95,Sw()),Adam:()=>Mf.adam(.001,.9,.999,Sw()),Adamax:()=>Mf.adamax(.002,.9,.999,Sw(),0),RMSProp:()=>Mf.rmsprop(.001,.9,0,Sw()),SGD:()=>Mf.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new Rx("Unknown Optimizer ".concat(e))}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof tl))throw new Rx("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"===typeof e.loss||"function"===typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new Rx("When passing an Array as loss, it should have one entry per "+"model output. The model has ".concat(this.outputs.length," output(s), ")+"but you passed loss=".concat(e.loss,"."));const n=e.loss;t=n.map((e=>hS(e)))}else{const n=hS(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new Rx('Unknown entry in loss dictionary: "'.concat(t,'". ')+"Only expected the following keys: ".concat(this.outputNames));for(const n of this.outputNames)null==e.loss[n]&&console.warn('Output "'.concat(n,'" is missing from loss dictionary. We assume ')+"this was done on purpose, and we will not be expecting data "+"to be passed to ".concat(n," during training")),t.push(hS(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){const e=this.internalOutputShapes[s],t=this.outputNames[s];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[s])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],pw("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const a=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"===typeof e||"function"===typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!==typeof e)throw new TypeError("Type of metrics argument not understood. Expected an string,"+"function, Array, or Object, found: ".concat(e));n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const a of t){let t=n.hasOwnProperty(a)?n[a]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),r=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};pw("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,a,s;for(const o of t){if("string"===typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){const t=this.internalOutputShapes[e];let r;1===t[t.length-1]||this.lossFunctions[e]===iS?-1!==["accuracy","acc"].indexOf(o)?a=dS:-1!==["crossentropy","ce"].indexOf(o)&&(a=mS):this.lossFunctions[e]===oS?-1!==["accuracy","acc"].indexOf(o)?a=gS:-1!==["crossentropy","ce"].indexOf(o)&&(a=bS):-1!==["accuracy","acc"].indexOf(o)?a=pS:-1!==["crossentropy","ce"].indexOf(o)&&(a=yS),-1!==["accuracy","acc"].indexOf(o)?r="acc":-1!==["crossentropy","ce"].indexOf(o)&&(r="ce"),s=a,n=""+r}else{const e=xS(o);s=e,n=""+wS(o)}let t;pw(n,(()=>{t=s})),r(e,n,t)}})(a[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=null==n.batchSize?32:n.batchSize;VS(a);const r=this.standardizeUserDataXY(e,t,!0,a);try{const e=r[0].concat(r[1]);this.makeTestFunction();const t=this.testFunction;return Lx(this.testLoop(t,e,a,n.verbose,n.steps))}finally{XS(r[0],e),XS(r[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const a=null!=(n=n||{}).batches,r=e.testFunction;let s=[];if(n.verbose>0)throw new Ax("Verbose mode is not implemented yet.");Et(!a||n.batches>0&&Number.isInteger(n.batches),(()=>"Test loop expects `batches` to be a positive integer, but "+"received ".concat(JSON.stringify(n.batches))));const o="function"===typeof t.next?t:await t.iterator();let i=0,c=0;for(;!a||c<n.batches;){const t=await o.next();if(s=Xc((()=>{if(t.value){const{xs:n,ys:a}=zS(e,t.value),o=n.concat(a),l=Xc((()=>r(o)));if(Yc(o),0===c)for(let e=0;e<l.length;++e)s.push(el(0));const u=o[0].shape[0];for(let e=0;e<l.length;++e){const t=l[e],n=s[e];s[e]=Xc((()=>sl(s[e],Ml(u,t)))),c>0&&Yc(n)}Yc(l),i+=u,++c}return s})),t.done){a&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` "+"batches (in this case, ".concat(n.batches," batches). ")+"You may need to use the repeat() function when building your dataset.");break}}for(let l=0;l<s.length;++l){const e=s[l];s[l]=bu(s[l],i),Yc(e)}return Lx(s)}(this,e,t)}checkNumSamples(e,t,n){let a,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(a=null,null!=t)throw new Rx("If ".concat(r," is set, batchSize must be null or undefined.")+"Got batchSize = ".concat(t))}else{if(null==e)throw new Rx("Either the input data should have a defined shape, or "+"".concat(r," shoud be specified."));a=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return a}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new Rx("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),a=n?t:[t],r=this.retrieveSymbolicTensors(a),s=new Nk;if(e instanceof po&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new Rx("The number of inputs provided (".concat(e.length,") ")+"does not match the number of inputs of this model "+"(".concat(this.inputs.length,")."));for(let t=0;t<this.inputs.length;++t)s.add(this.inputs[t],e[t])}else for(const i of this.inputs){const t=e[i.name];if(null==t)throw new Rx("No value is provided for the model's input ".concat(i.name));s.add(i,t)}const o=Ek(r,s);return n?o:o[0]}retrieveSymbolicTensors(e){const t=Ox(null,e.length);let n=e.length;for(const a of this.layers){const r=Array.isArray(a.output)?a.output:[a.output],s=r.map((e=>e.name));for(let a=0;a<e.length;++a){const o=s.indexOf(e[a]);if(-1!==o&&(t[a]=r[o],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,a)=>{null==t&&n.push(e[a])})),new Rx("Cannot find SymbolicTensors for output name(s): "+"".concat(JSON.stringify(n)))}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Xc((()=>{const a=this.checkNumSamples(e);if(n)throw new Ax("Verbose predictLoop() is not implemented yet.");const r=HS(a,t),s=this.outputs.map((e=>[]));for(let t=0;t<r.length;++t){Xc((()=>{const n=r[t][0],a=r[t][1],s=GS(e,n,a),o=[];if(Array.isArray(s))for(let e=0;e<s.length;++e)o.push({key:this.inputs[e],value:s[e]});else o.push({key:this.inputs[0],value:s});const i=new Nk(o);return Ek(this.outputs,i)})).forEach(((e,t)=>s[t].push(e)))}return Lx(s.map((e=>Ol(e,0))))}))}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=qS(e);JS(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return VS(e),this.predictLoop(n,e)}finally{XS(n,e)}}predictOnBatch(e){JS(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new Ex("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const a=[];for(let r=0;r<this.feedOutputShapes.length;++r){const e=this.feedOutputShapes[r];this.feedLossFns[r]===oS?a.push(e.slice(0,e.length-1).concat([1])):a.push(e)}if(function(e,t,n){const a=Hx(e.map((e=>e.shape[0])));a.sort();const r=Hx(t.map((e=>e.shape[0])));if(r.sort(),a.length>1)throw new Rx("All input Tensors (x) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(e.map((e=>e.shape)))));if(r.length>1)throw new Rx("All target Tensors (y) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(t.map((e=>e.shape)))));if(a.length>0&&r.length>0&&!Ot(a,r))throw new Rx("Input Tensors should have the same number of samples as target "+"Tensors. Found ".concat(a[0]," input sample(s) and ").concat(r[0]," target ")+"sample(s).")}(e=QS(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=QS(t,this.feedOutputNames,a,!1,"target")),function(e,t,n){const a=[tS,iS,sS];for(let r=0;r<e.length;++r){const s=e[r],o=t[r],i=n[r];if(null!=o){if(o===sS&&1===s.shape[s.shape.length-1])throw new Rx("You are passing a target array of shape ".concat(s.shape," while using ")+"a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==a.indexOf(o)){const e=s.shape.slice(1),t=i.slice(1);for(let n=0;n<e.length;++n){const a=e[n],r=t[n];if(null!=r&&a!==r)throw new Rx("A target Tensor with shape ".concat(s.shape," was passed for an ")+"output of shape ".concat(i,", while using a loss function that ")+"expects targets to have the same shape as the output.")}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new Rx("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+"".concat(n,". Found: ").concat(e[0].shape[0]," sample(s)."));return[e,t]}async standardizeUserData(e,t,n,a){let r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],s=arguments.length>5?arguments[5]:void 0;const[o,i]=this.standardizeUserDataXY(e,t,r,s);if(null!=n)throw new Error("sample weight is not supported yet.");let c=null;if(null!=a){const e=MS(a,this.outputNames);c=[];for(let t=0;t<e.length;++t)c.push(await LS(i[t],null,e[t]))}return[o,i,c]}testLoop(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4?arguments[4]:void 0;return Xc((()=>{const s=this.checkNumSamples(t,n,r,"steps"),o=[];if(a>0)throw new Ax("Verbose mode is not implemented yet.");if(null!=r)throw new Ax("steps mode in testLoop() is not implemented yet");{const a=HS(s,n),r=Ud(ww(0,s));for(let n=0;n<a.length;++n){const s=a[n][0],i=a[n][1],c=Cw(r,s,i-s),l=jS(t,c),u=e(l);if(0===n)for(let e=0;e<u.length;++e)o.push(el(0));for(let e=0;e<u.length;++e){const t=u[e];o[e]=sl(o[e],Ml(i-s,t))}}for(let e=0;e<o.length;++e)o[e]=bu(o[e],s)}return o}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const a=e[n];let r=a;if(Mx(e,a)>1){const t=Mx(e.slice(0,n),a);r+="_".concat(t)}t.push(r)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],o=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const o=new Nk(e),i=Ek(this.outputs,o,{training:!0});let c;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(a[n],i[n]);null!=r[n]&&(e=PS(e,r[n]));const s=Th(e);t.push(s),c=0===n?e:sl(c,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][0],r=this.metricsTensors[n][1];e=Th(t(a[r],i[r]))}Zc(e),s.push(e)}return c=Th(c),this.calculateLosses().forEach((e=>{c=sl(c,e)})),c}),!0,o)].concat(s)}}makeTestFunction(){this.testFunction=e=>Xc((()=>{const t=[];let n;const a=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let e=0;e<this.inputs.length;++e)s.push({key:this.inputs[e],value:a[e]});const o=new Nk(s),i=Ek(this.outputs,o);for(let e=0;e<this.lossFunctions.length;++e){const a=this.lossFunctions[e],s=Th(a(r[e],i[e]));n=0===e?s:sl(n,s),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],a=this.metricsTensors[e][1],s=Th(n(r[a],i[a]));t.push(s)}return t}))}async fit(e,t){return KS(this,e,t,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{})}async fitDataset(e,t){return WS(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),a=n[0],r=n[1],s=this.makeTrainFunction()(a.concat(r)),o=[];for(const i of s){const e=await i.data();o.push(e[0])}return Yc(s),XS(n[0],e),XS(n[1],t),Lx(o)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,a=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let s=0;s<a.length;++s)n&&!a[s].trainable||t.push({name:a[s].originalName,tensor:r[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=qc().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-qc().numTensors}return e}getLossIdentifiers(){let e;if("string"===typeof this.loss)e=zx(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!==typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>zx(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const a of t){if("string"!==typeof n[a])throw new Error("Serialization of non-string loss is not supported.");e[a]=zx(n[a])}}return e}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[zx(wS(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>zx(wS(e))));{const e={};for(const t in this.metrics)e[t]=zx(wS(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=$k(AS(e.optimizer_config));let n,a;if("string"===typeof e.loss)n=Bx(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>Bx(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=Bx(e.loss[t])}if(Array.isArray(e.metrics))a=e.metrics.map((e=>Bx(e)));else if(null!=e.metrics){a={};for(const t in e.metrics)a[t]=Bx(e.metrics[t])}this.compile({loss:n,metrics:a,optimizer:t})}async save(e,t){if("string"===typeof e){const t=di(e);if(0===t.length)throw new Rx("Cannot find any save handlers for URL '".concat(e,"'"));if(t.length>1)throw new Rx("Found more than one (".concat(t.length,") save handlers for ")+"URL '".concat(e,"'"));e=t[0]}if(null==e.save)throw new Rx("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await Zo(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v".concat(FS),convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){a.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:r}=await Zo(await this.optimizer.getWeights(),e);n.specs.push(...r),n.data=ti([n.data,t])}if(null!=this.userDefinedMetadata){const e=!0;SS(this.userDefinedMetadata,this.name,e),a.userDefinedMetadata=this.userDefinedMetadata}return a.weightData=n.data,a.weightSpecs=n.specs,e.save(a)}setUserDefinedMetadata(e){SS(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}$S.className="Model",Hc($S);class eI extends $S{}async function tI(e,t){if(null==t&&(t={}),"string"===typeof e){const n=pi(e,t);if(0===n.length)n.push(lc(e,t));else if(n.length>1)throw new Rx("Found more than one (".concat(n.length,") load handlers for ")+"URL '".concat(e,"'"));e=n[0]}return async function(e,t,n){null==n&&(n={});if(null==e.load)throw new Rx("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const a=await e.load();let r=a.modelTopology;null!=r.model_config&&(r=r.model_config);const s=null==n.strict||n.strict,o=null!=a.weightData&&null!=a.weightSpecs&&s,i=$k(AS(r),t,o),c=a.trainingConfig;null!=c&&i.loadTrainingConfig(c);null!=a.userDefinedMetadata&&i.setUserDefinedMetadata(a.userDefinedMetadata);if(null!=a.weightData){if(null==a.weightSpecs)throw new Rx("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:e,optimizerWeights:t}=function(e,t){const n=Qo(e,t),a={},r=[];return t.forEach((e=>{"optimizer"===e.group?r.push({name:e.name,tensor:n[e.name]}):a[e.name]=n[e.name]})),{modelWeights:a,optimizerWeights:r}}(a.weightData,a.weightSpecs);i.loadWeights(e,s),null!=i.optimizer&&t.length>0&&await i.optimizer.setWeights(t),Yc(e),Yc(t.map((e=>e.tensor)))}return i}(e,void 0,t)}eI.className="Functional",Hc(eI);class nI extends $S{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:tw("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new Rx("Negative dimension size caused by adding layer "+"".concat(e.name," with input shape [")+"".concat(e.inboundNodes[0].inputTensors[0].shape,"]"))}add(e){const t=e instanceof nI||e instanceof $S;let n;if(t){if(n=e,1!==n.outputs.length)throw new Rx("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new Rx("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new Rx("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new Rx("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new Ik({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new Rx("A layer added to a Sequential model must not already be "+"connected somewhere else. LayersModel received layer ".concat(e.name," ")+"which has ".concat(e.inboundNodes.length," pre-existing inbound ")+"connections.");if(1!==e.inboundNodes[0].outputTensors.length)throw new Rx("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=Sk(this.outputs[0])}this.inboundNodes=[],new xk({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Ox(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(hk(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new $S({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new Ex("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new Ex("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new Ex("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new Ex("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t){let n,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new Rx("Legacy serialization format not supported yet.");n=t}else Et(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),n=t.layers,delete t.layers,r=t;const s=new e(r);if(!(s instanceof nI))throw new Ax("Sequential.fromConfig called on non-Sequential input: ".concat(s));for(const o of n){const e=$k(o,void 0,a);a&&e.setFastWeightInitDuringBuild(!0),s.add(e)}return s}set stopTraining(e){if(null==this.model)throw new Rx("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new Rx("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}nI.className="Sequential",Hc(nI);class aI extends Gc{getConfig(){return{}}}class rI extends aI{apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new Ax("Support for alpha values other than 1 (".concat(t,") is not implemented ")+"yet.");return Nu(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}rI.className="elu",Hc(rI);class sI extends aI{apply(e){return vd(e)}}sI.className="selu",Hc(sI);class oI extends aI{apply(e){return ud(e)}}oI.className="relu",Hc(oI);class iI extends aI{apply(e){return Xc((()=>_h(6,ud(e))))}}iI.className="relu6",Hc(iI);class cI extends aI{apply(e){return e}}cI.className="linear",Hc(cI);class lI extends aI{apply(e){return Ll(e)}}lI.className="sigmoid",Hc(lI);class uI extends aI{apply(e){return function(e){return Xc((()=>{const t=sl(.5,Ml(.2,e));return Zl(t,0,1)}))}(e)}}uI.className="hardSigmoid",Hc(uI);class hI extends aI{apply(e){return hh(e)}}hI.className="softplus",Hc(hI);class dI extends aI{apply(e){return function(e){return Xc((()=>bu(e,sl(nl(e),1))))}(e)}}dI.className="softsign",Hc(dI);class pI extends aI{apply(e){return zl(e)}}pI.className="tanh",Hc(pI);class fI extends aI{apply(e){return Rd(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}fI.className="softmax",Hc(fI);class mI extends aI{apply(e){return fh(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}mI.className="logSoftmax",Hc(mI);class gI extends aI{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return Xc((()=>Ml(Ll(Ml(e,t)),e)))}}gI.className="swish",Hc(gI);class yI extends aI{apply(e){return Xc((()=>Ml(e,zl(hh(e)))))}}function bI(e){return e.getClassName()}function vI(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Gx(e,jc.getMap().classNameMap,t,"activation")}function xI(e){if(null==e){const e={className:"linear",config:{}};return vI(e)}if("string"===typeof e){const t={};return t.className=e,t.config={},vI(t)}return e instanceof aI?e:vI(e)}function wI(e){if(null!=e&&"object"!==typeof e)throw new Error("Argument to L1L2 regularizer's constructor is expected to be an "+"object, but received: ".concat(e))}yI.className="mish",Hc(yI);class kI extends Gc{}class SI extends kI{constructor(e){super(),wI(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return Xc((()=>{let t=Eh([1]);return this.hasL1&&(t=sl(t,Wu(Ml(this.l1,nl(e))))),this.hasL2&&(t=sl(t,Wu(Ml(this.l2,Mw(e))))),Al(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}SI.className="L1L2",Hc(SI);const II={l1l2:"L1L2"};function NI(e){return Ux(e)}function CI(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Gx(e,jc.getMap().classNameMap,t,"regularizer")}function TI(e){if(null==e)return null;if("string"===typeof e){return CI({className:e in II?II[e]:e,config:{}})}return e instanceof kI?e:CI(e)}class EI extends kk{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=uk(e);let n=ud(e);return null!=this.maxValue&&(n=Zl(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}EI.className="ReLU",Hc(EI);class RI extends kk{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=uk(e);return ah(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}RI.className="LeakyReLU",Hc(RI);class AI extends kk{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=ik(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=TI(e.alphaRegularizer),this.alphaConstraint=Uk(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!==typeof e.sharedAxes)throw new Rx("Expected sharedAxes to be a number or an array of numbers, "+"but got ".concat(e.sharedAxes));this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=hk(e)).slice(1);if(null!=this.sharedAxes)for(const a of this.sharedAxes)t[a-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let a=1;a<e.length;++a)n[a]=e[a];this.inputSpec=[new yk({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=uk(e),Xh(e,this.alpha.read())}getConfig(){const e={alphaInitializer:ok(this.alphaInitializer),alphaRegularizer:NI(this.alphaRegularizer),alphaConstraint:Bk(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}AI.className="PReLU",Hc(AI);class _I extends kk{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new Ax("Non-default alpha value (".concat(e.alpha,") is not supported by the ")+"ELU layer yet.");this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=uk(e);return Nu(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}_I.className="ELU",Hc(_I);class FI extends kk{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=uk(e);return Ml(n,Xi(Qu(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}FI.className="ThresholdedReLU",Hc(FI);class OI extends kk{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new fI).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){const n=uk(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function DI(e,t,n){if("number"===typeof e)return Ox(e,t);if(e.length!==t)throw new Rx("The ".concat(n," argument must be an integer or tuple of ").concat(t," integers.")+" Received: ".concat(e.length," elements."));for(let r=0;r<t;++r){const s=e[r];if((a=s)!==parseInt(a.toString(),10))throw new Rx("The ".concat(n," argument must be an integer or tuple of ").concat(t)+" integers. Received: ".concat(JSON.stringify(e)," including a")+" non-integer number ".concat(s))}return e;var a}function MI(e,t,n,a){if(null==e)return e;let r;return r="same"===n?e:e-(t+(t-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((r+a-1)/a)}function LI(e,t,n,a){if(null==e)return null;if("valid"===a)e=e*t+xw([n-t,0]);else{if("same"!==a)throw new Rx("Unsupport padding mode: ".concat(a,"."));e*=t}return e}function PI(e,t){return Xc((()=>(cw(t),"channelsFirst"===t?np(e,[0,2,3,1]):e)))}function zI(e,t){return Xc((()=>(cw(t),"channelsFirst"===t?np(e,[0,2,3,4,1]):e)))}function BI(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return Xc((()=>{if(null==s&&(s="channelsLast"),cw(s),3!==e.shape.length)throw new Rx("The input of a conv1dWithBias operation should be 3, but is "+"".concat(e.shape.length," instead."));if(3!==t.shape.length)throw new Rx("The kernel for a conv1dWithBias operation should be 3, but is "+"".concat(t.shape.length," instead"));if(null!=n&&1!==n.shape.length)throw new Rx("The bias for a conv1dWithBias operation should be 1, but is "+"".concat(t.shape.length," instead"));if("channelsFirst"===s&&(e=np(e,[0,2,1])),"causal"===r)throw new Ax("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=nu(e,t,a,"same"===r?"same":"valid","NWC",o);return null!=n&&(i=Pw(i,n)),i}))}function WI(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return Xc((()=>{if(null==s&&(s="channelsLast"),cw(s),3!==e.rank&&4!==e.rank)throw new Rx("conv2dWithBiasActivation expects input to be of rank 3 or 4, "+"but received ".concat(e.rank,"."));if(3!==t.rank&&4!==t.rank)throw new Rx("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, "+"but received ".concat(e.rank,"."));let c=PI(e,s);if("causal"===r)throw new Ax("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return c=vp({x:c,filter:t,strides:a,pad:"same"===r?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:i}),"channelsFirst"===s&&(c=np(c,[0,3,1,2])),c}))}function UI(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6?arguments[6]:void 0;return Xc((()=>{if(null==s&&(s="channelsLast"),cw(s),4!==e.rank&&5!==e.rank)throw new Rx("conv3dWithBias expects input to be of rank 4 or 5, but received "+"".concat(e.rank,"."));if(4!==t.rank&&5!==t.rank)throw new Rx("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+"".concat(e.rank,"."));let i=zI(e,s);if("causal"===r)throw new Ax("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=su(i,t,a,"same"===r?"same":"valid","NDHWC",o),null!=n&&(i=Pw(i,n)),"channelsFirst"===s&&(i=np(i,[0,4,1,2,3])),i}))}OI.className="Softmax",Hc(OI);class VI extends kk{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",VI.verifyArgs(t),this.rank=e,Yx(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new Ax("Convolution layer for rank other than 1, 2, or 3 (".concat(this.rank,") is ")+"not implemented yet.");if(this.kernelSize=DI(t.kernelSize,e,"kernelSize"),this.strides=DI(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,lw(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,cw(this.dataFormat),this.activation=xI(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=ik(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Uk(t.biasConstraint),this.biasRegularizer=TI(t.biasRegularizer),this.activityRegularizer=TI(t.activityRegularizer),this.dilationRate=DI(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new Rx("dilationRate must be a number or an array of a single number for 1D convolution, but received "+"".concat(JSON.stringify(this.dilationRate)));if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new Rx("dilationRate must be a number or array of two numbers for 2D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new Rx("dilationRate must be a number or array of three numbers for 3D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}static verifyArgs(e){if(Dx("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!==typeof e.kernelSize&&!Xx(e.kernelSize,"number",1,3))throw new Rx("BaseConv expects config.kernelSize to be number or number[] with "+"length 1, 2, or 3, but received ".concat(JSON.stringify(e.kernelSize),"."))}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:bI(this.activation),useBias:this.useBias,biasInitializer:ok(this.biasInitializer),biasRegularizer:NI(this.biasRegularizer),activityRegularizer:NI(this.activityRegularizer),biasConstraint:Bk(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class GI extends VI{constructor(e,t){super(e,t),this.kernel=null,GI.verifyArgs(t),this.filters=t.filters,Yx(this.filters,"filters"),this.kernelInitializer=ik(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Uk(t.kernelConstraint),this.kernelRegularizer=TI(t.kernelRegularizer)}build(e){e=hk(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Rx("The channel dimension of the input should be defined. "+"Found ".concat(e[t]));const n=e[t],a=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return Xc((()=>{let t;e=uk(e);const n=null==this.bias?null:this.bias.read(),a=Qx(this.activation.getClassName());if(null!=a&&2===this.rank)t=WI(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(1===this.rank)t=BI(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=WI(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new Ax("convolutions greater than 3D are not implemented yet.");t=UI(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=hk(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let r=0;r<n.length;++r){const e=MI(n[r],this.kernelSize[r],this.padding,this.strides[r],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[r]);t.push(e)}let a=[e[0]];return"channelsLast"===this.dataFormat?(a=a.concat(t),a.push(this.filters)):(a.push(this.filters),a=a.concat(t)),a}getConfig(){const e={filters:this.filters,kernelInitializer:ok(this.kernelInitializer),kernelRegularizer:NI(this.kernelRegularizer),kernelConstraint:Bk(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!==typeof e.filters||e.filters<1)throw new Rx("Convolution layer expected config.filters to be a 'number' > 0 "+"but got ".concat(JSON.stringify(e.filters)))}}class jI extends GI{constructor(e){super(2,e),jI.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!Xx(e.kernelSize,"number",1,2))throw new Rx("Conv2D expects config.kernelSize to be number or number[] with "+"length 1 or 2, but received ".concat(JSON.stringify(e.kernelSize),"."))}}jI.className="Conv2D",Hc(jI);class HI extends GI{constructor(e){super(3,e),HI.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new Rx("Conv3D expects config.kernelSize to be number or"+" [number, number, number], but received ".concat(JSON.stringify(e.kernelSize),"."))}}HI.className="Conv3D",Hc(HI);class KI extends jI{constructor(e){if(super(e),this.inputSpec=[new yk({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new Rx("Conv2DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(e){if(4!==(e=hk(e)).length)throw new Rx("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Rx("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new yk({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return Xc((()=>{let t=uk(e);if(4!==t.shape.length)throw new Rx("Conv2DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(t.shape.length));const n=t.shape,a=n[0];let r,s;"channelsFirst"===this.dataFormat?(r=2,s=3):(r=1,s=2);const o=n[r],i=n[s],c=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],h=this.strides[1],d=[a,LI(o,u,c,this.padding),LI(i,h,l,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=np(t,[0,2,3,1]));let p=ru(t,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=np(p,[0,3,1,2])),null!=this.bias&&(p=Pw(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(e){const t=(e=hk(e)).slice();let n,a,r;"channelsFirst"===this.dataFormat?(n=1,a=2,r=3):(n=3,a=1,r=2);const s=this.kernelSize[0],o=this.kernelSize[1],i=this.strides[0],c=this.strides[1];return t[n]=this.filters,t[a]=LI(t[a],i,s,this.padding),t[r]=LI(t[r],c,o,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}KI.className="Conv2DTranspose",Hc(KI);class qI extends HI{constructor(e){if(super(e),this.inputSpec=[new yk({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new Rx("Conv3DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(e){if(5!==(e=hk(e)).length)throw new Rx("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Rx("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new yk({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return Xc((()=>{let t=uk(e);if(5!==t.shape.length)throw new Rx("Conv3DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(t.shape.length));const n=t.shape,a=n[0];let r,s,o;"channelsFirst"===this.dataFormat?(o=2,r=3,s=4):(o=1,r=2,s=3);const i=n[o],c=n[r],l=n[s],u=this.kernelSize[0],h=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[a,LI(i,p,u,this.padding),LI(c,f,h,this.padding),LI(l,m,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=np(t,[0,2,3,4,1]));let y=iu(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=np(y,[0,4,1,2,3])),null!==this.bias&&(y=Pw(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y}))}computeOutputShape(e){const t=(e=hk(e)).slice();let n,a,r,s;"channelsFirst"===this.dataFormat?(n=1,a=2,r=3,s=4):(n=4,a=1,r=2,s=3);const o=this.kernelSize[0],i=this.kernelSize[1],c=this.kernelSize[2],l=this.strides[0],u=this.strides[1],h=this.strides[2];return t[n]=this.filters,t[a]=LI(t[a],l,o,this.padding),t[r]=LI(t[r],u,i,this.padding),t[s]=LI(t[s],h,c,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}qI.className="Conv3DTranspose",Hc(qI);class XI extends GI{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new Rx("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new Rx("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new Rx("SeparableConv".concat(this.rank,"D supports only padding modes: ")+"'same' and 'valid', but received ".concat(JSON.stringify(t.padding)));this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=ik(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=TI(t.depthwiseRegularizer),this.depthwiseConstraint=Uk(t.depthwiseConstraint),this.pointwiseInitializer=ik(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=TI(t.pointwiseRegularizer),this.pointwiseConstraint=Uk(t.pointwiseConstraint)}build(e){if((e=hk(e)).length<this.rank+2)throw new Rx("Inputs to SeparableConv".concat(this.rank,"D should have rank ")+"".concat(this.rank+2,", but received input shape: ")+"".concat(JSON.stringify(e)));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new Rx("The channel dimension of the inputs should be defined, "+"but found ".concat(JSON.stringify(e[t])));const n=e[t],a=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let o=0;o<this.rank;++o)r.push(1);r.push(n*this.depthMultiplier,this.filters);const s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",a,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new yk({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return Xc((()=>{let t;if(e=uk(e),1===this.rank)throw new Ax("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=np(e,[0,2,3,1])),t=xd(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=Pw(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=np(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=ok(this.depthwiseInitializer),e.pointwiseInitializer=ok(this.pointwiseInitializer),e.depthwiseRegularizer=NI(this.depthwiseRegularizer),e.pointwiseRegularizer=NI(this.pointwiseRegularizer),e.depthwiseConstraint=Bk(this.depthwiseConstraint),e.pointwiseConstraint=Bk(this.pointwiseConstraint),e}}XI.className="SeparableConv";class YI extends XI{constructor(e){super(2,e)}}YI.className="SeparableConv2D",Hc(YI);class ZI extends GI{constructor(e){super(1,e),ZI.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!Xx(e.kernelSize,"number",1,1))throw new Rx("Conv1D expects config.kernelSize to be number or number[] with "+"length 1, but received ".concat(JSON.stringify(e.kernelSize),"."))}}ZI.className="Conv1D",Hc(ZI);class QI extends kk{constructor(e){super(e),"number"===typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"===typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Xc((()=>{if(e=uk(e),"channelsLast"===this.dataFormat){const t=Ew(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Ew(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=Ew(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Ew(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}QI.className="Cropping2D",Hc(QI);class JI extends kk{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,cw(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,qx(aw,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return Xc((()=>{let t=uk(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=np(t,[0,2,3,1]);const e=this.size[0]*n[2],a=this.size[1]*n[3],r="nearest"===this.interpolation?kf.resizeNearestNeighbor(t,[e,a]):kf.resizeBilinear(t,[e,a]);return np(r,[0,3,1,2])}{const e=this.size[0]*n[1],a=this.size[1]*n[2];return"nearest"===this.interpolation?kf.resizeNearestNeighbor(t,[e,a]):kf.resizeBilinear(t,[e,a])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}JI.className="UpSampling2D",Hc(JI);class $I extends VI{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=ik(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Uk(e.depthwiseConstraint),this.depthwiseRegularizer=TI(e.depthwiseRegularizer)}build(e){if((e=hk(e)).length<4)throw new Rx("Inputs to DepthwiseConv2D should have rank 4. "+"Received input shape: ".concat(JSON.stringify(e),"."));const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new Rx("The channel dimension of the inputs to DepthwiseConv2D should "+"be defined, but is not (".concat(e[t],")."));const n=e[t],a=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",a,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Xc((()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",r=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0;return Xc((()=>{null==r&&(r="channelsLast"),cw(r);let o=PI(e,r);if(4!==e.rank)throw new Rx("Input for depthwiseConv2d is required to be 4-D, but is instead "+"".concat(e.rank,"-D"));if(4!==t.rank)throw new Rx("depthwiseKernel is required to be 4-D, but is instead "+"".concat(t.rank,"-D"));return o=fu(o,t,n,"same"===a?"same":"valid","NHWC",s),"channelsFirst"===r&&(o=np(o,[0,3,1,2])),o}))}(e=uk(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=Pw(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=hk(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],a="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=MI(t,this.kernelSize[0],this.padding,this.strides[0]),s=MI(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],a,r,s]:[e[0],r,s,a]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=ok(this.depthwiseInitializer),e.depthwiseRegularizer=NI(this.depthwiseRegularizer),e.depthwiseConstraint=Bk(this.depthwiseRegularizer),e}}function eN(e,t,n,a){if(Array.isArray(e)){if(null!=t||null!=n)throw new Rx("When inputs is an array, neither initialState or constants should be provided");null!=a&&(n=e.slice(e.length-a,e.length),e=e.slice(0,e.length-a)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function r(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=r(t),constants:n=r(n)}}function tN(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return Xc((()=>{const c=t.shape.length;if(c<3)throw new Rx("Input should be at least 3D, but is ".concat(c,"D."));const l=[1,0].concat(ww(2,c));if(t=np(t,l),null!=s)throw new Ax("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&(r=Xi(Xi(r,"bool"),"float32"),r.rank===c-1&&(r=Hu(r,-1)),r=np(r,l)),a&&(t=dd(t,0),null!=r&&(r=dd(r,0)));const u=[];let h,d=n;const p=t.shape[0],f=Zd(t);let m,g;null!=r&&(m=Zd(r));for(let t=0;t<p;++t){const n=f[t],a=Xc((()=>e(n,d)));if(null==r)h=a[0],d=a[1];else{const e=Xc((()=>{const e=m[t],n=ph(Bh(e),e);return{output:sl(Ml(a[0],e),Ml(d[0],n)),newStates:d.map(((t,r)=>sl(Ml(a[1][r],e),Ml(t,n))))}}));h=e.output,d=e.newStates}i&&u.push(h)}if(i){g=Pd(u,1)}return[h,g,d]}))}$I.className="DepthwiseConv2D",Hc($I);class nN extends kk{constructor(e){let t;if(super(e),null==e.cell)throw new Rx("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new uN({cells:e.cell}):e.cell,null==t.stateSize)throw new Rx("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new yk({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return ww(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){ck(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let a;if(a=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const a of t)n.push([e[0],a]);return[a].concat(n)}return a}computeMask(e,t){return Xc((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new Ax("Constants support is not implemented in RNN yet.");ck(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new yk({shape:[t,null,...n]});const a=[e[0]].concat(e.slice(2));let r;if(this.cell.build(a),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Ot(this.stateSpec.map((e=>e.shape[e.shape.length-1])),r))throw new Rx("An initialState was passed that is not compatible with "+"cell.stateSize. Received stateSpec=".concat(this.stateSpec,"; ")+"However cell.stateSize is ".concat(this.cell.stateSize))}else this.stateSpec=r.map((e=>new yk({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];Xc((()=>{if(!this.stateful)throw new Tx("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new Rx("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>Eh([n,e]))):this.states_=[Eh([n,this.cell.stateSize])];else if(null==e)Yc(this.states_),null!=this.keptStates&&(Yc(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>Eh([n,e]))):this.states_[0]=Eh([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Rx("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(e.length," state value(s). Input ")+"received: ".concat(e));!0===t?this.keptStates.push(this.states_.slice()):Yc(this.states_);for(let t=0;t<this.states_.length;++t){const a=e[t],r=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,s=[n,r];if(!Ot(a.shape,s))throw new Rx("State ".concat(t," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(s,", received shape=").concat(a.shape));this.states_[t]=a}}this.states_=this.states_.map((e=>Zc(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,a=null==t?null:t.constants;null==t&&(t={});const r=eN(e,n,a,this.numConstants);e=r.inputs,n=r.initialState,a=r.constants;let s=[],o=[];if(null!=n){t.initialState=n,s=s.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new yk({shape:e.shape}));o=o.concat(this.stateSpec)}null!=a&&(t.constants=a,s=s.concat(a),this.numConstants=a.length);if(s[0]instanceof bk){const n=[e].concat(s),a=this.inputSpec.concat(o),r=this.inputSpec;this.inputSpec=a;const i=super.apply(n,t);return this.inputSpec=r,i}return super.apply(e,t)}call(e,t){return Xc((()=>{const n=null==t?null:t.mask,a=null==t?null:t.training;let r=null==t?null:t.initialState;e=uk(e),null==r&&(r=this.stateful?this.states_:this.getInitialState(e));const s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==s)throw new Rx("RNN Layer has ".concat(s," state(s) but was passed ")+"".concat(r.length," initial state(s)."));this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:a},i=tN(((e,t)=>{const n=this.cell.call([e].concat(t),o);return[n[0],n.slice(1)]}),e,r,this.goBackwards,n,null,this.unroll,this.returnSequences),c=i[0],l=i[1],u=i[2];this.stateful&&this.resetStates(u,a);const h=this.returnSequences?l:c;return this.returnState?[h].concat(u):h}))}getInitialState(e){return Xc((()=>{let t=Eh(e.shape);return t=Wu(t,[1,2]),t=Nw(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?_w(t,[1,e]):t)):this.cell.stateSize>1?[_w(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===nN.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,e,t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=$k(t.cell,n);return new e(Object.assign(t,{cell:a}))}}nN.className="RNN",Hc(nN);class aN extends kk{}class rN extends aN{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Yx(this.units,"units"),this.activation=xI(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=ik(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ik(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ik(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=TI(e.kernelRegularizer),this.recurrentRegularizer=TI(e.recurrentRegularizer),this.biasRegularizer=TI(e.biasRegularizer),this.kernelConstraint=Uk(e.kernelConstraint),this.recurrentConstraint=Uk(e.recurrentConstraint),this.biasConstraint=Uk(e.biasConstraint),this.dropout=vw([1,xw([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=vw([1,xw([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=hk(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Xc((()=>{if(2!==e.length)throw new Rx("SimpleRNNCell expects 2 input Tensors, got ".concat(e.length,"."));let n=e[1];e=e[0];const a=null!=t.training&&t.training;let r;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=hN({ones:()=>Bh(e),rate:this.dropout,training:a,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=hN({ones:()=>Bh(n),rate:this.recurrentDropout,training:a,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;r=Ow(null!=s?Ml(e,s):e,this.kernel.read()),null!=this.bias&&(r=Pw(r,this.bias.read())),null!=o&&(n=Ml(n,o));let i=sl(r,Ow(n,this.recurrentKernel.read()));return null!=this.activation&&(i=this.activation.apply(i)),[i,i]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:bI(this.activation),useBias:this.useBias,kernelInitializer:ok(this.kernelInitializer),recurrentInitializer:ok(this.recurrentInitializer),biasInitializer:ok(this.biasInitializer),kernelRegularizer:NI(this.kernelRegularizer),recurrentRegularizer:NI(this.recurrentRegularizer),biasRegularizer:NI(this.biasRegularizer),activityRegularizer:NI(this.activityRegularizer),kernelConstraint:Bk(this.kernelConstraint),recurrentConstraint:Bk(this.recurrentConstraint),biasConstraint:Bk(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},e,t)}}rN.className="SimpleRNNCell",Hc(rN);class sN extends nN{constructor(e){e.cell=new rN(e),super(e)}call(e,t){return Xc((()=>{null!=this.cell.dropoutMask&&(Yc(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Yc(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}static fromConfig(e,t){return new e(t)}}sN.className="SimpleRNN",Hc(sN);class oN extends aN{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Rx("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Yx(this.units,"units"),this.activation=xI(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=xI(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=ik(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ik(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ik(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=TI(e.kernelRegularizer),this.recurrentRegularizer=TI(e.recurrentRegularizer),this.biasRegularizer=TI(e.biasRegularizer),this.kernelConstraint=Uk(e.kernelConstraint),this.recurrentConstraint=Uk(e.recurrentConstraint),this.biasConstraint=Uk(e.biasConstraint),this.dropout=vw([1,xw([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=vw([1,xw([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=hk(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Xc((()=>{if(2!==e.length)throw new Rx("GRUCell expects 2 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));const n=null!=t.training&&t.training;let a=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=hN({ones:()=>Bh(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=hN({ones:()=>Bh(a),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,s=this.recurrentDropoutMask;let o,i,c;0<this.dropout&&this.dropout<1&&(e=Ml(e,r[0]));let l=Ow(e,this.kernel.read());this.useBias&&(l=Pw(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(a=Ml(a,s[0]));const u=this.recurrentKernel.read(),[h,d]=Od(u,[2*this.units,this.units],u.rank-1),p=Ow(a,h),[f,m,g]=Od(l,3,l.rank-1),[y,b]=Od(p,2,p.rank-1);o=this.recurrentActivation.apply(sl(f,y)),i=this.recurrentActivation.apply(sl(m,b));const v=Ow(Ml(i,a),d);c=this.activation.apply(sl(g,v));const x=sl(Ml(o,a),Ml(sl(1,uh(o)),c));return[x,x]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:bI(this.activation),recurrentActivation:bI(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ok(this.kernelInitializer),recurrentInitializer:ok(this.recurrentInitializer),biasInitializer:ok(this.biasInitializer),kernelRegularizer:NI(this.kernelRegularizer),recurrentRegularizer:NI(this.recurrentRegularizer),biasRegularizer:NI(this.biasRegularizer),activityRegularizer:NI(this.activityRegularizer),kernelConstraint:Bk(this.kernelConstraint),recurrentConstraint:Bk(this.recurrentConstraint),biasConstraint:Bk(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},e,t)}}oN.className="GRUCell",Hc(oN);class iN extends nN{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new oN(e),super(e)}call(e,t){return Xc((()=>{null!=this.cell.dropoutMask&&(Yc(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Yc(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}iN.className="GRU",Hc(iN);class cN extends aN{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Yx(this.units,"units"),this.activation=xI(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=xI(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=ik(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ik(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ik(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=TI(e.kernelRegularizer),this.recurrentRegularizer=TI(e.recurrentRegularizer),this.biasRegularizer=TI(e.biasRegularizer),this.kernelConstraint=Uk(e.kernelConstraint),this.recurrentConstraint=Uk(e.recurrentConstraint),this.biasConstraint=Uk(e.biasConstraint),this.dropout=vw([1,xw([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=vw([1,xw([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=hk(e))[e.length-1];let a;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;a=new((t=class extends Vw{apply(t,a){const r=e.apply([n]),s=(new jw).apply([n]),o=e.apply([2*n]);return Aw(Aw(r,s),o)}}).className="CustomInit",t)}else a=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,a,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Xc((()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new Rx("LSTMCell expects 3 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));let a=e[1];const r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=hN({ones:()=>Bh(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=hN({ones:()=>Bh(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;let i,c,l,u;0<this.dropout&&this.dropout<1&&(e=Ml(e,s[0]));let h=Ow(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(a=Ml(a,o[0])),h=sl(h,Ow(a,this.recurrentKernel.read())),this.useBias&&(h=Pw(h,this.bias.read()));const[d,p,f,m]=Od(h,4,h.rank-1);i=this.recurrentActivation.apply(d),c=this.recurrentActivation.apply(p),l=sl(Ml(c,r),Ml(i,this.activation.apply(f))),u=this.recurrentActivation.apply(m);const g=Ml(u,this.activation.apply(l));return[g,g,l]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:bI(this.activation),recurrentActivation:bI(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ok(this.kernelInitializer),recurrentInitializer:ok(this.recurrentInitializer),biasInitializer:ok(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:NI(this.kernelRegularizer),recurrentRegularizer:NI(this.recurrentRegularizer),biasRegularizer:NI(this.biasRegularizer),activityRegularizer:NI(this.activityRegularizer),kernelConstraint:Bk(this.kernelConstraint),recurrentConstraint:Bk(this.recurrentConstraint),biasConstraint:Bk(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},e,t)}}cN.className="LSTMCell",Hc(cN);class lN extends nN{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new cN(e),super(e)}call(e,t){return Xc((()=>{null!=this.cell.dropoutMask&&(Yc(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Yc(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}lN.className="LSTM",Hc(lN);class uN extends aN{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Xc((()=>{let n=e.slice(1);const a=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?a.push(n.splice(0,e.stateSize.length)):a.push(n.splice(0,1));a.reverse();const r=[];let s;for(let o=0;o<this.cells.length;++o){const i=this.cells[o];n=a[o],s=0===o?[e[0]].concat(n):[s[0]].concat(n),s=i.call(s,t),r.push(s.slice(1))}n=[];for(const e of r.slice().reverse())n.push(...e);return[s[0]].concat(n)}))}build(e){let t;ck(e)&&(e=e[0]),this.cells.forEach(((n,a)=>{pw("RNNCell_".concat(a),(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign({},e,t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=[];for(const r of t.cells)a.push($k(r,n));return new e({cells:a})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return mk(e)}setWeights(e){const t=[];for(const n of this.cells){const a=n.weights.length,r=e.splice(a);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],r[e]])}gk(t)}}function hN(e){const{ones:t,rate:n,training:a=!1,count:r=1,dropoutFunc:s}=e,o=()=>null!=s?s(t(),n):zw(t(),n),i=()=>Bw(o,t,a);if(!r||r<=1)return Zc(i().clone());return Array(r).fill(void 0).map(i).map((e=>Zc(e.clone())))}uN.className="StackedRNNCells",Hc(uN);var dN=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var r=0;for(a=Object.getOwnPropertySymbols(e);r<a.length;r++)t.indexOf(a[r])<0&&Object.prototype.propertyIsEnumerable.call(e,a[r])&&(n[a[r]]=e[a[r]])}return n};class pN extends nN{constructor(e){if(e.unroll)throw new Ax("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Ax("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new yk({ndim:5})]}call(e,t){return Xc((()=>{if(null!=this.cell.dropoutMask&&(Yc(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Yc(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new Rx("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return Xc((()=>{const{stateSize:t}=this.cell,n=e.shape,a=this.computeSingleOutputShape(n),r=Eh([a[0],...a.slice(2)]);return Array.isArray(t)?Array(t.length).fill(r):[r]}))}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];Xc((()=>{if(!this.stateful)throw new Tx("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,a=this.computeSingleOutputShape(n),r=[a[0],...a.slice(2)];if(null==n[0])throw new Rx("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>Eh(r))):this.states_=[Eh(r)];else if(null==e)Yc(this.states_),null!=this.keptStates&&(Yc(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>Eh(r))):this.states_[0]=Eh(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Rx("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(e.length," state value(s). Input ")+"received: ".concat(e));t?this.keptStates.push(this.states_.slice()):Yc(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],a=r;if(!Ot(n.shape,a))throw new Rx("State ".concat(t," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(a,", received shape=").concat(n.shape));this.states_[t]=n}}this.states_=this.states_.map((e=>Zc(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:a,padding:r,strides:s,dilationRate:o}=this.cell,i="channelsFirst"===t,c=e[i?3:2],l=e[i?4:3],u=MI(c,a[0],r,s[0],o[0]),h=MI(l,a[1],r,s[1],o[1]);return[...e.slice(0,2),...i?[n,u,h]:[u,h,n]]}}pN.className="ConvRNN2D";class fN extends cN{constructor(e){const{filters:t,kernelSize:n,strides:a,padding:r,dataFormat:s,dilationRate:o}=e;super(Object.assign({},e,{units:t})),this.filters=t,Yx(this.filters,"filters"),this.kernelSize=DI(n,2,"kernelSize"),this.kernelSize.forEach((e=>Yx(e,"kernelSize"))),this.strides=DI(a||1,2,"strides"),this.strides.forEach((e=>Yx(e,"strides"))),this.padding=r||"valid",lw(this.padding),this.dataFormat=s||"channelsLast",cw(this.dataFormat),this.dilationRate=DI(o||1,2,"dilationRate"),this.dilationRate.forEach((e=>Yx(e,"dilationRate")))}build(e){var t;e=hk(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new Rx("The channel dimension of the input should be defined. "+"Found ".concat(e[n]));const a=e[n],r=this.kernelSize.concat([a,4*this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,a=this.filters;e=new((t=class extends Vw{apply(e,t){return Rw([n.apply([a]),Rh([a]),n.apply([2*a])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return Xc((()=>{if(3!==e.length)throw new Rx("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));const n=t.training||!1,a=e[0],r=e[1],s=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=hN({ones:()=>Bh(a),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,i=(e,t,n)=>t&&t[n]?Ml(t[n],e):e;let c=i(a,o,0),l=i(a,o,1),u=i(a,o,2),h=i(a,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=hN({ones:()=>Bh(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const d=this.recurrentDropoutMask;let p=i(r,d,0),f=i(r,d,1),m=i(r,d,2),g=i(r,d,3);const[y,b,v,x]=Od(this.kernel.read(),4,3),[w,k,S,I]=this.useBias?Od(this.bias.read(),4):[null,null,null,null];c=this.inputConv(c,y,w,this.padding),l=this.inputConv(l,b,k,this.padding),u=this.inputConv(u,v,S,this.padding),h=this.inputConv(h,x,I,this.padding);const[N,C,T,E]=Od(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,N),f=this.recurrentConv(f,C),m=this.recurrentConv(m,T),g=this.recurrentConv(g,E);const R=this.recurrentActivation.apply(sl(c,p)),A=this.recurrentActivation.apply(sl(l,f)),_=sl(Ml(A,s),Ml(R,this.activation.apply(sl(u,m)))),F=Ml(this.recurrentActivation.apply(sl(h,g)),this.activation.apply(_));return[F,F,_]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=dN(e,["units"]),a={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},n,a)}inputConv(e,t,n,a){const r=tu(e,t,this.strides,a||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?Pw(r,n,this.dataFormat):r}recurrentConv(e,t){return tu(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}fN.className="ConvLSTM2DCell",Hc(fN);class mN extends pN{constructor(e){const t=new fN(e);super(Object.assign({},e,{cell:t}))}static fromConfig(e,t){return new e(t)}}mN.className="ConvLSTM2D",Hc(mN);class gN extends kk{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let a=0;a<this.noiseShape.length;++a)n.push(null==this.noiseShape[a]?t[a]:this.noiseShape[a]);return n}call(e,t){return Xc((()=>{this.invokeCallHook(e,t);const n=uk(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,a=this.getNoiseShape(n);return Bw((()=>zw(n,this.rate,a,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}gN.className="Dropout",Hc(gN);class yN extends gN{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}yN.className="SpatialDropout1D",Hc(yN);class bN extends kk{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Yx(this.units,"units"),this.activation=xI(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=ik(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=ik(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Uk(e.kernelConstraint),this.biasConstraint=Uk(e.biasConstraint),this.kernelRegularizer=TI(e.kernelRegularizer),this.biasRegularizer=TI(e.biasRegularizer),this.activityRegularizer=TI(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=hk(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=hk(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return Xc((()=>{this.invokeCallHook(e,t);const n=uk(e),a=Qx(this.activation.getClassName());let r;return null!=a?r=Ow(n,this.kernel.read(),a,this.bias?this.bias.read():null):(r=Ow(n,this.kernel.read()),null!=this.bias&&(r=Pw(r,this.bias.read())),null!=this.activation&&(r=this.activation.apply(r))),r}))}getConfig(){const e={units:this.units,activation:bI(this.activation),useBias:this.useBias,kernelInitializer:ok(this.kernelInitializer),biasInitializer:ok(this.biasInitializer),kernelRegularizer:NI(this.kernelRegularizer),biasRegularizer:NI(this.biasRegularizer),activityRegularizer:NI(this.activityRegularizer),kernelConstraint:Bk(this.kernelConstraint),biasConstraint:Bk(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}bN.className="Dense",Hc(bN);class vN extends kk{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=hk(e);for(const t of e.slice(1))if(null==t)throw new Rx('The shape of the input to "Flatten" is not fully defined '+"(got ".concat(e.slice(1),"). Make sure to pass a complete ")+'"input_shape" or "batch_input_shape" argument to the first layer in your model.');return[e[0],bw(e,1)]}call(e,t){return Xc((()=>{this.invokeCallHook(e,t);let n=uk(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=np(n,e)}return function(e){if(e.rank<=1)throw new Rx("batchFlatten requires a minimum rank of 2. Got rank: ".concat(e.rank,"."));const t=[e.shape[0],bw(e.shape,1)];return Al(e,t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}vN.className="Flatten",Hc(vN);class xN extends kk{constructor(e){super(e),this.supportsMasking=!0,this.activation=xI(e.activation)}call(e,t){return Xc((()=>{this.invokeCallHook(e,t);const n=uk(e);return this.activation.apply(n)}))}getConfig(){const e={activation:bI(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}xN.className="Activation",Hc(xN);class wN extends kk{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Xc((()=>{return e=uk(e),t=e,n=this.n,Xc((()=>{if(2!==t.shape.length)throw new Rx("repeat() expects a rank-2 tensor, but received a "+"rank-".concat(t.shape.length," tensor."));return _w(Nw(t,1),[1,n,1])}));var t,n}))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}wN.className="RepeatVector",Hc(wN);class kN extends kk{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",a=t.slice();let r=1,s=null;for(let i=0;i<a.length;++i){const e=a[i];if(this.isUnknown(e)){if(null!==s)throw new Rx("Can only specifiy one unknown dimension.");s=i}else r*=e}const o=bw(e);if(null!==s){if(0===r||o%r!==0)throw new Rx(n);a[s]=o/r}else if(o!==r)throw new Rx(n);return a}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Xc((()=>{this.invokeCallHook(e,t);const n=uk(e),a=n.shape,r=a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape));return Al(n,r)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}kN.className="Reshape",Hc(kN);class SN extends kk{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+"".concat(e.dims," instead."));const t=ww(1,e.dims.length+1);if(!Ot(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new yk({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=hk(e)).slice();return this.dims.forEach(((n,a)=>{t[a+1]=e[n]})),t}call(e,t){return np(uk(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}SN.className="Permute",Hc(SN);class IN extends kk{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=uk(e);return cl(Ph(n,this.maskValue),-1)}call(e,t){return Xc((()=>{this.invokeCallHook(e,t);const n=uk(e),a=cl(Ph(n,this.maskValue),-1,!0);return Ml(n,Xi(a,n.dtype))}))}}IN.className="Masking",Hc(IN);class NN extends kk{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Px(e.inputLength))}this.inputDim=e.inputDim,Yx(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Yx(this.outputDim,"outputDim"),this.embeddingsInitializer=ik(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=TI(e.embeddingsRegularizer),this.activityRegularizer=TI(e.activityRegularizer),this.embeddingsConstraint=Uk(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Xc((()=>this.maskZero?(e=uk(e),Ph(e,wu(e))):null))}computeOutputShape(e){if(e=hk(e),null==this.inputLength)return[...e,this.outputDim];const t=Px(this.inputLength);if(t.length!==e.length-1)throw new Rx('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(e));{let n=0;for(let a=0;a<t.length;++a){const r=t[a],s=e[a+1];if(null!=r&&null!=s&&r!==s)throw new Rx('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(e));null==r&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return Xc((()=>{this.invokeCallHook(e,t);let n=uk(e);"int32"!==n.dtype&&(n=Iw(n,"int32"));const a=Dw(this.embeddings.read(),Al(n,[n.size]));return Al(a,hk(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:ok(this.embeddingsInitializer),embeddingsRegularizer:NI(this.embeddingsRegularizer),activityRegularizer:NI(this.activityRegularizer),embeddingsConstraint:Bk(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}NN.className="Embedding",Hc(NN);class CN extends kk{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Ax}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let a=0;a<t.length;++a){const r=e[e.length-t.length+a],s=t[a];if(null==r||null==s||r<0||s<0)n.push(null);else if(1===r)n.push(s);else if(1===s)n.push(r);else{if(r!==s)throw new Rx("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(r)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[hk(e)]),e.length<2)throw new Rx("A merge layer should be called on an Array of at least 2 inputs."+" Got ".concat(e.length," input(s)."));let t=[];for(const r of e)null!=r&&null!==r[0]&&t.push(r[0]);if(t=Hx(t),t.length>1)throw new Rx("Can not merge tensors with different batch sizes. "+"Got tensors with shapes: ".concat(JSON.stringify(e),"."));let n=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){const t=null==e[r]?null:e[r].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const a=e.map((e=>e.length));-1===e.indexOf(null)&&1===Hx(a).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return Xc((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const a=xw(n);for(let n of e){const e=n.rank;for(let t=0;t<a-e;++t)n=Nw(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const s of e){const e=s.rank;if(null==e){const e=s.shape,a=e[0],r=e.slice(1).concat([a]);let o=Al(s,[a].concat(bw(e.slice(1))));o=np(o,[1,0]),o=Al(o,r),t.push(o),n=!0}else if(e>1){const a=ww(1,e).concat([0]);t.push(np(s,a)),n=!0}else t.push(s)}let a=this.mergeFunction(t);const r=a.rank;if(n)if(null==r){const e=a.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));a=Al(np(Al(a,[-1,t]),[1,0]),n)}else if(r>1){const e=[r-1].concat(ww(0,r-1));a=np(a,e)}return a}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){const n=null==e[a]?null:e[a].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const a of e)null!=a&&null!==a[0]&&n.push(a[0]);return n=Hx(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return Xc((()=>{if(null==t)return null;if(!Array.isArray(t))throw new Rx("`mask` should be an Array");if(!Array.isArray(e))throw new Rx("`inputs` should be an Array");if(t.length!==e.length)throw new Rx("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths "+"(".concat(e.length," vs ").concat(t.length,")"));if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:Hu(e,0))))[0];for(let e=1;e<t.length-1;++e)n=gh(n,t[e]);return n}))}}class TN extends CN{constructor(e){super(e)}mergeFunction(e){return Xc((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=sl(t,e[n]);return t}))}}TN.className="Add",Hc(TN);class EN extends CN{constructor(e){super(e)}mergeFunction(e){return Xc((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Ml(t,e[n]);return t}))}}EN.className="Multiply",Hc(EN);class RN extends CN{constructor(e){super(e)}mergeFunction(e){return Xc((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=sl(t,e[n]);return Ml(1/e.length,t)}))}}RN.className="Average",Hc(RN);class AN extends CN{constructor(e){super(e)}mergeFunction(e){return Xc((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Ch(t,e[n]);return t}))}}AN.className="Maximum",Hc(AN);class _N extends CN{constructor(e){super(e)}mergeFunction(e){return Xc((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=_h(t,e[n]);return t}))}}_N.className="Minimum",Hc(_N);class FN extends CN{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new Rx("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const a of e)if(null!=a){t=!1;break}if(t)return;const n=[];for(let a=0;a<e.length;++a){const t=e[a].slice();t.splice(this.axis,1);let r=!1;for(const e of n)if(Ot(e,t)){r=!0;break}r||n.push(t)}if(n.length>1)throw new Rx("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Xc((()=>Rw(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new Rx("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),a=this.axis<0?n.length+this.axis:this.axis;for(const r of t.slice(1)){if(null==n[a]||null==r[a]){n[a]=null;break}n[a]+=r[a]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new Rx("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new Rx("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new Rx("Mismatch in the length of mask (".concat(t.length,") ")+"and the legnth of inputs (".concat(e.length,")"));return Xc((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const a=[];for(let s=0;s<e.length;++s)null==t[s]?a.push(Xi(Bh(e[s]),"bool")):t[s].rank<e[s].rank?a.push(Hu(t[s],-1)):a.push(t[s]);const r=Ol(a,this.axis);return il(r,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function ON(e,t){for(;e<0;)e+=t;return e}FN.className="Concatenate",Hc(FN);class DN extends CN{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){Et(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Ax("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(t,n);if(t[a[0]]!==n[a[1]])throw new Rx("Dimension incompatibility: "+"".concat(t[a[0]]," !== ").concat(n[a[1]]))}mergeFunction(e){if(2!==e.length)throw new Rx("A `Dot` layer must be called on exactly 2 inputs, "+"but received ".concat(e.length," input(s)."));let t,n=e[0],a=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>ON(t,e[n].shape.length))):[ON(this.axes,n.shape.length),ON(this.axes,a.shape.length)],this.normalize&&(n=eS(n,t[0]),a=eS(a,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Ax("batchDot is not implemented for tensors of 4D or higher rank yet");if(Et(e.shape.length>=2,(()=>"batchDot requires the rank of x to be >= 2, "+"but got ".concat(e.shape.length))),Et(e.shape.length>=2,(()=>"batchDot requires the rank of y to be >= 2, "+"but got ".concat(t.shape.length))),"number"===typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new Ax("batchDot is not implemented for complex64-type Tensors yet.");const a=e.shape.length,r=t.shape.length;null==n&&(n=[a-1,r-2]);const s=n;return Xc((()=>{let n,o;if(a>r){n=a-r;const e=[];for(let t=0;t<n;++t)e.push(1);t=Al(t,t.shape.concat(e))}else if(r>a){n=r-a;const t=[];for(let e=0;e<n;++e)t.push(1);e=Al(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)o=s[0]===s[1]?Wu(Ml(e,t),s[0]):Wu(Ml(np(e,[1,0]),t),s[1]);else{const n=s[0]!==e.shape.length-1,a=s[1]===t.shape.length-1;o=Dl(e,t,n,a)}if(n>0){let e;e=a>r?a+r-3:a-1;const t=[];for(let a=e;a<e+n;++a)t.push(a);o=Ld(o,t)}return 1===o.shape.length&&(o=Hu(o,1)),o}))}(n,a,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[ON(this.axes,e.length),ON(this.axes,t.length)],n}computeOutputShape(e){Et(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Ax("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(t,n);t.splice(a[0],1),n.splice(a[1],1),n.splice(0,1);const r=t.concat(n);return 1===r.length&&r.push(1),r}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}DN.className="Dot",Hc(DN);class MN extends kk{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Xc((()=>{this.invokeCallHook(e,t);const n=uk(e);return Bw((()=>sl(Fw(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}}MN.className="GaussianNoise",Hc(MN);class LN extends kk{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Xc((()=>{this.invokeCallHook(e,t);const n=uk(e);if(this.rate>0&&this.rate<1){return Bw((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return Ml(n,Fw(n.shape,1,e))}),(()=>n),t.training||!1)}return n}))}}LN.className="GaussianDropout",Hc(LN);class PN extends kk{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||uk(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Xc((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),a=()=>{const t=uk(e),a=-1.7580993408473766;let r=Ju(od(n),this.rate);r=Iw(r,"float32");const s=((1-this.rate)*(1+this.rate*a**2))**-.5,o=-s*a*this.rate,i=sl(Ml(t,r),Ml(sl(r,-1),a));return sl(Ml(i,s),o)};return Bw(a,(()=>uk(e)),t.training||!1)}return e}))}}function zN(e,t,n,a,r){let s,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)s=Vl(e,t,n,a,r,o);else if(3===e.rank)s=Gl(e,t,n,a,r,o);else{if(4!==e.rank)throw new Ax("batchNormalization is not implemented for array of rank ".concat(e.rank," ")+"yet");s=jl(e,t,n,a,r,o)}return s}function BN(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Ot(a.slice().sort(),ww(0,e.rank-1))?function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Xc((()=>{const s=Dh(e,a),o=s.mean,i=s.variance;return[zN(e,o,i,n,t,r),o,i]}))}(e,t,n,a,r):function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Xc((()=>{const s=Dh(e,a),o=s.mean,i=s.variance,c=[];for(const t of ww(0,e.rank))-1!==a.indexOf(t)?c.push(1):c.push(e.shape[t]);const l=Al(o,c),u=Al(i,c),h=null==t?null:Al(t,c),d=null==n?null:Al(n,c);return[zN(e,l,u,d,h,r),o,i]}))}(e,t,n,a,r)}PN.className="AlphaDropout",Hc(PN);class WN extends kk{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=ik(e.betaInitializer||"zeros"),this.gammaInitializer=ik(e.gammaInitializer||"ones"),this.movingMeanInitializer=ik(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=ik(e.movingVarianceInitializer||"ones"),this.betaConstraint=Uk(e.betaConstraint),this.gammaConstraint=Uk(e.gammaConstraint),this.betaRegularizer=TI(e.betaRegularizer),this.gammaRegularizer=TI(e.gammaRegularizer)}build(e){e=hk(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new Rx("Axis ".concat(t," of input tensor should have a defined dimension but ")+"the layer received an input with shape "+"".concat(JSON.stringify(e),"."));this.inputSpec=[new yk({ndim:e.length,axes:{[t]:n}})];const a=[n];this.scale&&(this.gamma=this.addWeight("gamma",a,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",a,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",a,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",a,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Xc((()=>{const n=null!=t.training&&t.training,a=uk(e),r=a.shape,s=r.length,o=ww(0,s),i=this.axis>=0?this.axis:this.axis+s;o.splice(i,1);const c=Ox(1,s);c[i]=r[i];const l=o.slice();l.sort();const u=!Ot(l,ww(0,s).slice(0,s-1));if(!n)return(()=>{if(u){const e=Al(this.movingMean.read(),c),t=Al(this.movingVariance.read(),c),n=this.center?Al(this.beta.read(),c):null,r=this.scale?Al(this.gamma.read(),c):null;return zN(a,e,t,n,r,this.epsilon)}return zN(a,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=BN(a,this.gamma.read(),this.beta.read(),o,this.epsilon),f=(e,t,n)=>{Xc((()=>{const a=1-n,r=e.read(),s=Ml(ph(r,t),a);e.write(ph(r,s))}))};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ok(this.betaInitializer),gammaInitializer:ok(this.gammaInitializer),movingMeanInitializer:ok(this.movingMeanInitializer),movingVarianceInitializer:ok(this.movingVarianceInitializer),betaRegularizer:NI(this.betaRegularizer),gammaRegularizer:NI(this.gammaRegularizer),betaConstraint:Bk(this.betaConstraint),gammaConstraint:Bk(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}WN.className="BatchNormalization",Hc(WN);class UN extends kk{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error("Expected axis to be an integer, but received ".concat(this.axis))}else{if(!Array.isArray(this.axis))throw new Error("Expected axis to be an integer or an array of integers, "+"but received ".concat(JSON.stringify(this.axis)));for(const e of this.axis)if(!Number.isInteger(e))throw new Error("Expected axis to be an array of integers, "+"but received ".concat(JSON.stringify(this.axis)))}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=ik(e.betaInitializer||"zeros"),this.gammaInitializer=ik(e.gammaInitializer||"ones"),this.betaRegularizer=TI(e.betaRegularizer),this.gammaRegularizer=TI(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=hk(e)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(const a of this.axis)if(a<0||a>=t)throw new Error("Invalid axis: ".concat(a));if(this.axis.length!==Hx(this.axis).length)throw new Error("Found duplicate axes in: ".concat(this.axis));const n=this.axis.map((t=>e[t]));this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,true):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,true):this.beta=null,this.built=!0}call(e,t){const n=uk(e),a=n.shape,r=a.length;return Xc((()=>{let{mean:e,variance:t}=Dh(n,this.axis,!0);const s=Ox(1,r);for(const n of this.axis)s[n]=a[n];const o=e=>null!=e&&e.shape.length!==r?Al(e,s):e;let i=this.scale?o(this.gamma.read()):null,c=this.center?o(this.beta.read()):null;const l=[],u=[];for(let n=0;n<r;++n)-1!==this.axis.indexOf(n)?(l.push(a[n]),u.push(1)):(l.push(1),u.push(a[n]));return e=qu(e,l),t=qu(t,l),null!=i&&(i=qu(i,u)),null!=c&&(c=qu(c,u)),zN(n,e,t,c,i,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ok(this.betaInitializer),gammaInitializer:ok(this.gammaInitializer),betaRegularizer:NI(this.betaRegularizer),gammaRegularizer:NI(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}UN.className="LayerNormalization",Hc(UN);class VN extends kk{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new Rx("ZeroPadding2D expects padding to be a length-2 array, but "+"received a length-".concat(e.padding.length," array."));let t,n;if("number"===typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new Rx("ZeroPadding2D expects height padding to be a length-2 array, "+"but received a length-".concat(e.padding[0].length," array."));if(t=e.padding[0],2!==e.padding[1].length)throw new Rx("ZeroPadding2D expects width padding to be a length-2 array, "+"but received a length-".concat(e.padding[1].length," array."));n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new yk({ndim:4})]}computeOutputShape(e){let t,n;return e=hk(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return Xc((()=>{return t=uk(e),n=this.padding,a=this.dataFormat,Xc((()=>{if(4!==t.rank)throw new Rx("temporalPadding expects input tensor to be 4-D, but received a "+"".concat(t.rank,"-D tensor."));if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new Rx("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==a&&(a="channelsLast"),"channelsLast"!==a&&"channelsFirst"!==a)throw new Rx("Unknown data format: ".concat(a,". ")+"Supported data formats are 'channelsLast' and 'channelsFirst.");let e;return e="channelsFirst"===a?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],Uh(t,e)}));var t,n,a}))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function GN(e,t,n,a,r,s){return Xc((()=>{let o;cw(r),uw(s),lw(a),null==n&&(n=[1,1]),null==a&&(a="valid"),null==r&&(r="channelsLast"),null==s&&(s="max"),e=PI(e,r);const i="same"===a?"same":"valid";return o="max"===s?Sh(e,t,n,i):_l(e,t,n,i),"channelsFirst"===r&&(o=np(o,[0,3,1,2])),o}))}function jN(e,t,n,a,r,s){return Xc((()=>{let o;cw(r),uw(s),lw(a),null==n&&(n=[1,1,1]),null==a&&(a="valid"),null==r&&(r="channelsLast"),null==s&&(s="max"),e=zI(e,r);const i="same"===a?"same":"valid";return o="max"===s?Ih(e,t,n,i):Fl(e,t,n,i),"channelsFirst"===r&&(o=np(o,[0,4,1,2,3])),o}))}VN.className="ZeroPadding2D",Hc(VN);class HN extends kk{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"===typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!==typeof e.poolSize[0])throw new Rx("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(e.poolSize)));this.poolSize=e.poolSize}if(Yx(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"===typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!==typeof e.strides[0])throw new Rx("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(e.strides)));this.strides=e.strides}Yx(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,lw(this.padding),this.inputSpec=[new yk({ndim:3})]}computeOutputShape(e){const t=MI((e=hk(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Xc((()=>{this.invokeCallHook(e,t),e=Nw(uk(e),2);const n=this.poolingFunction(uk(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Ld(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class KN extends HN{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return cw(r),lw(a),GN(e,t,n,a,r,"max")}}KN.className="MaxPooling1D",Hc(KN);class qN extends HN{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return cw(r),lw(a),GN(e,t,n,a,r,"avg")}}qN.className="AveragePooling1D",Hc(qN);class XN extends kk{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new Rx("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+"".concat(e.strides.length,"."));this.strides=e.strides}else this.strides=[e.strides,e.strides];Yx(this.poolSize,"poolSize"),Yx(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,cw(this.dataFormat),lw(this.padding),this.inputSpec=[new yk({ndim:4})]}computeOutputShape(e){e=hk(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=MI(t,this.poolSize[0],this.padding,this.strides[0]),n=MI(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return Xc((()=>(this.invokeCallHook(e,t),this.poolingFunction(uk(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class YN extends XN{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return cw(r),lw(a),GN(e,t,n,a,r,"max")}}YN.className="MaxPooling2D",Hc(YN);class ZN extends XN{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return cw(r),lw(a),GN(e,t,n,a,r,"avg")}}ZN.className="AveragePooling2D",Hc(ZN);class QN extends kk{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new Rx("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+"".concat(e.strides.length,"."));this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Yx(this.poolSize,"poolSize"),Yx(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,cw(this.dataFormat),lw(this.padding),this.inputSpec=[new yk({ndim:5})]}computeOutputShape(e){e=hk(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],a="channelsFirst"===this.dataFormat?e[4]:e[3];return t=MI(t,this.poolSize[0],this.padding,this.strides[0]),n=MI(n,this.poolSize[1],this.padding,this.strides[1]),a=MI(a,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,a]:[e[0],t,n,a,e[4]]}call(e,t){return Xc((()=>(this.invokeCallHook(e,t),this.poolingFunction(uk(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class JN extends QN{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return cw(r),lw(a),jN(e,t,n,a,r,"max")}}JN.className="MaxPooling3D",Hc(JN);class $N extends QN{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return cw(r),lw(a),jN(e,t,n,a,r,"avg")}}$N.className="AveragePooling3D",Hc($N);class eC extends kk{constructor(e){super(e),this.inputSpec=[new yk({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Ax}}class tC extends eC{constructor(e){super(e||{})}call(e,t){return Xc((()=>{const t=uk(e);return Th(t,1)}))}}tC.className="GlobalAveragePooling1D",Hc(tC);class nC extends eC{constructor(e){super(e||{})}call(e,t){return Xc((()=>{const t=uk(e);return Mu(t,1)}))}}nC.className="GlobalMaxPooling1D",Hc(nC);class aC extends kk{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,cw(this.dataFormat),this.inputSpec=[new yk({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Ax}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class rC extends aC{call(e,t){return Xc((()=>{const t=uk(e);return"channelsLast"===this.dataFormat?Th(t,[1,2]):Th(t,[2,3])}))}}rC.className="GlobalAveragePooling2D",Hc(rC);class sC extends aC{call(e,t){return Xc((()=>{const t=uk(e);return"channelsLast"===this.dataFormat?Mu(t,[1,2]):Mu(t,[2,3])}))}}sC.className="GlobalMaxPooling2D",Hc(sC);class oC extends kk{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=$k(t.layer,n);delete t.layer;const r={layer:a};return Object.assign(r,t),new e(r)}}class iC extends oC{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=hk(e)).length<3)throw new Rx("TimeDistributed layer expects an input shape >= 3D, but received "+"input shape ".concat(JSON.stringify(e)));this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=hk(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),a=e[1];return[n[0],a].concat(n.slice(1))}call(e,t){return Xc((()=>tN(((e,n)=>[uk(this.layer.call(e,t)),[]]),e=uk(e),[],!1,null,null,!1,!0)[1]))}}iC.className="TimeDistributed",Hc(iC);class cC extends oC{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=$k(n),t.goBackwards=!0!==t.goBackwards;const a={};var r;if(a.className=e.layer.getClassName(),a.config=t,this.backwardLayer=$k(a),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,r=this.mergeMode,qx(ow,"BidirectionalMergeMode",r),e.weights)throw new Ax("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,a,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState?(a=r.slice(1),t=r[0]):t=r[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(a).concat(a.slice()):[t].concat(a).concat(a.slice()):Lx(n)}apply(e,t){let n=null==t?null:t.initialState,a=null==t?null:t.constants;null==t&&(t={});const r=eN(e,n,a,this.numConstants);if(e=r.inputs,n=r.initialState,a=r.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==a)return super.apply(e,t);const s=[],o=[];if(null!=n){const e=n.length;if(e%2>0)throw new Rx("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);const a=n.map((e=>new yk({shape:e.shape})));this.forwardLayer.stateSpec=a.slice(0,e/2),this.backwardLayer.stateSpec=a.slice(e/2),o.push(...a)}if(null!=a)throw new Ax("Support for constants in Bidirectional layers is not implemented yet.");const i=s[0]instanceof bk;for(const c of s)if(c instanceof bk!==i)throw new Rx("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(i){const n=[e].concat(s),a=this.inputSpec.concat(o),r=this.inputSpec;this.inputSpec=a;const i=super.apply(n,t);return this.inputSpec=r,i}return super.apply(e,t)}call(e,t){return Xc((()=>{const n=t.initialState;let a,r,s,o;if(null==n)a=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{const s=n.slice(0,n.length/2),o=n.slice(n.length/2);a=this.forwardLayer.call(e,Object.assign(t,{initialState:s})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:o}))}return this.returnState&&(Array.isArray(a)&&(s=a.slice(1).concat(r.slice(1))),a=a[0],r=r[0]),this.returnSequences&&(r=dd(r,1)),"concat"===this.mergeMode?o=Rw([a,r]):"sum"===this.mergeMode?o=sl(a,r):"ave"===this.mergeMode?o=Ml(.5,sl(a,r)):"mul"===this.mergeMode?o=Ml(a,r):null==this.mergeMode&&(o=[a,r]),this.returnState?null==this.mergeMode?o.concat(s):[o].concat(s):o}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){pw(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),pw(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=$k(t.layer);if(delete t.layer,null!=t.numConstants)throw new Ax("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const a=t;return a.layer=n,new e(a)}}cC.className="Bidirectional",Hc(cC);class lC extends kk{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Xc((()=>("float32"!==(e=uk(e)).dtype&&(e=Iw(e,"float32")),sl(Ml(e,this.scale),this.offset))))}}lC.className="Rescaling",Hc(lC);function uC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"===typeof Blob&&e instanceof Blob)return e.slice();if(a.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const r=t(e);if(r.recurse&&null!==r.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse){if(fC(e)){const r=Array.isArray(e)?[]:{};a.add(e);for(const s in e){const o=uC(e[s],t,n,a);r[s]=o}return a.delete(e),e.__proto__&&(r.__proto__=e.__proto__),r}throw new Error("Can't recurse into non-iterable type: ".concat(e))}return n.set(e,r.value),r.value}function hC(e){return dC(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:pC)}function dC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const a=e[0];if(n.has(a))throw new Error("Circular references are not supported.");const r=t(e);if(r.recurse&&null!==r.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse){if(fC(a)){const r=Array.isArray(a)?[]:{};n.add(a);for(const s in a){const a=dC(e.map((e=>e[s])),t,n);r[s]=a}return n.delete(a),r}throw new Error("Can't recurse into non-iterable type: ".concat(a))}return r.value}function pC(e){return null===e?null:fC(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function fC(e){let t=!1;if(hn().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:a}=n(830);t=e instanceof a}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"===typeof e&&!(e instanceof po)&&!(e instanceof Promise)&&!t)}function mC(e){return function(e,t){return uC(e,t)}(e,gC)}function gC(e){return e instanceof po?{value:e.clone(),recurse:!1}:fC(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class yC{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class bC extends yC{constructor(){super(bC.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let a=0;a<n;a++)t[a]=this.get(this.wrap(this.begin+a));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function vC(e){return new SC(e)}function xC(e,t){return new DC(e,t)}bC.INITIAL_CAPACITY=32;class wC{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new AC(this,e)}filter(e){return new EC(this,e)}map(e){return new RC(this,e)}mapAsync(e){return new _C(this,e)}serialMapAsync(e){return new _C(this,e).serial()}flatmap(e){return new OC(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e){return new TC(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:pC;return this.rowMajorBatch(e,t).map((e=>hC(e,n)))}concatenate(e,t){return new DC(new kC([this,e]),t)}take(e){return e<0||null==e?this:new CC(this,e)}skip(e){return e<0||null==e?this:new NC(this,e)}prefetch(e){return new LC(this,e)}shuffle(e,t){return new PC(this,e,t)}serial(){return new IC(this)}}class kC extends wC{constructor(e){super(),this.items=e,this.trav=0}summary(){return"Array of ".concat(this.items.length," items")}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:mC(e),done:!1}}}class SC extends wC{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(qV){throw qV.message="Error thrown while iterating through a dataset: ".concat(qV.message),qV}}}class IC extends wC{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Serial")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class NC extends wC{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Skip")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;Yc(e.value)}return this.upstream.next()}}class CC extends wC{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return"".concat(this.upstream.summary()," -> Take")}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class TC extends wC{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> RowMajorBatch")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class EC extends wC{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Filter")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Yc(e.value)}}}class RC extends wC{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> Map")}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Co(e.value),n=this.transform(e.value),a=Co(n);for(const r of t)No(r,a)||r.dispose();return{value:n,done:!1}}}class AC extends wC{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> handleErrors")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(qV){if(!this.handler(qV))return{value:null,done:!0}}}}class _C extends wC{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> AsyncMap")}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Co(e.value),n=await this.transform(e.value),a=Co(n);for(const r of t)No(r,a)||r.dispose();return{value:n,done:!1}}}class FC extends wC{constructor(){super(),this.outputQueue=new bC,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class OC extends FC{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> Flatmap")}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=Co(e.value),n=this.transform(e.value),a=Co(n);this.outputQueue.pushAll(n);for(const r of t)No(r,a)||r.dispose();return!0}}class DC extends wC{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"".concat("TODO: fill in upstream of chained summaries"," -> Chained")}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var MC;!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(MC||(MC={}));class LC extends wC{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new yC(t)}summary(){return"".concat(this.upstream.summary()," -> Prefetch")}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class PC extends LC{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=$h.alea(n||Xs().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class zC{constructor(){this.size=null}batch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let a;return Et(e>0,(()=>"batchSize needs to be positive, but it is\n      ".concat(e))),a=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),BC((async()=>(await n.iterator()).columnMajorBatch(e,t,WC)),a)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,BC((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,BC((async()=>(await t.iterator()).filter((t=>Xc((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return BC((async()=>(await t.iterator()).map((t=>Xc((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return BC((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return BC((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,BC((async()=>xC(vC((async()=>({value:await t.iterator(),done:!1}))).take(e))),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,BC((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting "+"bufferSize to the dataset size (".concat(this.size," elements)"));const a=this,r=$h.alea(t||Xs().toString());return BC((async()=>{let t=r.int32();return n&&(t+=r.int32()),(await a.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,BC((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function BC(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends zC{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function WC(e){if(null===e)return null;if(function(e){return null==e||null===(t=e)||"object"!==typeof t&&"function"!==typeof t||Array.isArray(e)||"object"===typeof e&&e instanceof po||jt(e);var t}(e[0])){return{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof po?Pd(e):qo(e)}(e),recurse:!1}}return{value:null,recurse:!0}}zC.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");function UC(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Et("complex64"!==e.dtype,(()=>"".concat(t," does not support complex64 tensors in the CPU backend.")))}))}const VC=$d;class GC extends kt{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new wt(this,Kc())}nextDataId(){return GC.nextDataId++}write(e,t,n){this.firstUse&&(this.firstUse=!1,hn().get("IS_NODE")&&ks("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const a={id:this.nextDataId()};return this.data.set(a,{values:e,dtype:n,refCount:1}),a}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&Kt(n[0])){const r=n.map((e=>Ys(e)));a=this.write(r,e,t)}else a=this.write(n,e,t);return{dataId:a,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,a,r){this.data.set(e,{values:t,dtype:a,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){return cm(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return this.data.get(e).values}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>Zs(e)));return qi(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return qi(e.shape,e.dtype,t)}makeOutput(e,t,n){return Kc().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Xs();e();return{kernelMs:Xs()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){UC([e],"where");const t=this.readSync(e.dataId);return VC(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}GC.nextDataId=0;function jC(e,t,n){return a=>{let{inputs:r,attrs:s,backend:o}=a;const{x:i}=r;if(UC(i,e),"string"===i.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const c=o,l=c.data.get(i.dataId).values,u=Ft(i.shape),h=n||i.dtype,d=Vt(h,u);for(let e=0;e<u;++e)d[e]=t(l[e],s);return c.makeTensorInfo(i.shape,h,d)}}function HC(e,t,n){return a=>{let{inputs:r,attrs:s,backend:o}=a;const{x:i}=r;if(UC(i,e),"string"===i.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const c=o,l=c.data.get(i.dataId).values,u=n||i.dtype,h=t(l,u,s);return c.makeTensorInfo(i.shape,u,h)}}Jc("cpu",(()=>new GC),1);const KC=jC(da,(e=>e>=0?e:Math.exp(e)-1)),qC={kernelName:da,backendName:"cpu",kernelFunc:KC};function XC(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const YC={kernelName:Ra,backendName:"cpu",kernelFunc:XC};function ZC(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:s}=a;UC([r],"leakyRelu");const o=Ft(r.shape),i=n.data.get(r.dataId).values,c=Ut("float32",o);for(let l=0;l<i.length;l++)c[l]=i[l]<0?s*i[l]:i[l];return n.makeTensorInfo(r.shape,"float32",c)}const QC={kernelName:Ma,backendName:"cpu",kernelFunc:ZC};function JC(e){return(t,n,a,r,s)=>{const o=vc(t,n),i=o.length,c=Qt(o),l=Ut(s,Ft(o)),u=t.length,h=n.length,d=Qt(t),p=Qt(n),f=yc(t,o),m=yc(n,o);if(f.length+m.length===0)for(let g=0;g<l.length;++g)l[g]=e(a[g%a.length],r[g%r.length]);else for(let g=0;g<l.length;++g){const t=sn(g,i,c),n=t.slice(-u);f.forEach((e=>n[e]=0));const s=rn(n,u,d),o=t.slice(-h);m.forEach((e=>o[e]=0));const y=rn(o,h,p);l[g]=e(a[s],r[y])}return[l,o]}}const $C=JC(((e,t)=>e<0?t*e:e));function eT(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t;UC([a,r],"prelu");const s=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,[i,c]=$C(a.shape,r.shape,s,o,"float32");return n.makeTensorInfo(c,"float32",i)}const tT={kernelName:gr,backendName:"cpu",kernelFunc:eT},nT=jC(Sr,(e=>Math.max(0,e))),aT={kernelName:Sr,backendName:"cpu",kernelFunc:nT},rT=jC(Rr,(e=>Math.min(Math.max(0,e),6))),sT={kernelName:Rr,backendName:"cpu",kernelFunc:rT};function oT(e){return(t,n,a)=>{const r=Ut(n,t.length);for(let s=0;s<t.length;++s)r[s]=e(t[s],a);return r}}const iT=oT((e=>1/(1+Math.exp(-e)))),cT=jC(Ur,(e=>1/(1+Math.exp(-e)))),lT={kernelName:Ur,backendName:"cpu",kernelFunc:cT};function uT(e,t,n,a,r){if("linear"===n)return XC({inputs:{x:t},backend:e});if("relu"===n)return nT({inputs:{x:t},backend:e});if("elu"===n)return KC({inputs:{x:t},backend:e});if("relu6"===n)return rT({inputs:{x:t},backend:e});if("prelu"===n)return eT({inputs:{x:t,alpha:a},backend:e});if("leakyrelu"===n)return ZC({inputs:{x:t},backend:e,attrs:{alpha:r}});if("sigmoid"===n)return cT({inputs:{x:t},backend:e});throw new Error("Activation ".concat(n," has not been implemented for the CPU backend."))}function hT(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,i=n.makeTensorInfo(a.shape,"complex64");return n.data.get(i.dataId).complexTensorInfos={real:n.makeTensorInfo(a.shape,"float32",s),imag:n.makeTensorInfo(r.shape,"float32",o)},i}const dT={kernelName:Un,backendName:"cpu",kernelFunc:hT};function pT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return hT({inputs:{real:pT(e,t,"float32"),imag:pT(e,t,"float32")},backend:e})}const a=tn(Ft(t),n);return e.makeTensorInfo(t,n,a)}function fT(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.real,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}const mT={kernelName:wr,backendName:"cpu",kernelFunc:fT};function gT(e,t,n,a){if("int32"===a){return[t,"int32",Int32Array.from(e)]}if("bool"===a){const a=qs([0],n),[r,s]=JC(((e,t)=>e!==t?1:0))(t,[],e,a,"bool");return[s,"bool",r]}throw new Error("Error in Cast: failed to cast ".concat(n," to ").concat(a))}function yT(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:s}=a;if("complex64"===s){if("complex64"===r.dtype)return XC({inputs:{x:r},backend:n});const e=pT(n,r.shape,r.dtype),t=yT({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),a=hT({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),a}if("complex64"===r.dtype){const e=fT({inputs:{input:r},backend:n}),t=yT({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!Gt(r.dtype,s)){const e=XC({inputs:{x:r},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}const o=n.data.get(r.dataId).values,[i,c,l]=gT(o,r.shape,r.dtype,s);return n.makeTensorInfo(i,c,l)}const bT={kernelName:zn,backendName:"cpu",kernelFunc:yT};function vT(e,t,n,a){return null==n?n=>{let{inputs:r,backend:s}=n;const{a:o,b:i}=r,c=s;UC([o,i],e);const l=c.data.get(o.dataId).values,u=c.data.get(i.dataId).values,h="string"===o.dtype?Vm(l):l,d="string"===o.dtype?Vm(u):u,p=a||o.dtype,[f,m]=t(o.shape,i.shape,h,d,p);return c.makeTensorInfo(m,p,f)}:e=>{let{inputs:r,backend:s}=e;const{a:o,b:i}=r,c=s;if("complex64"===o.dtype||"complex64"===i.dtype){const e=yT({inputs:{x:o},backend:c,attrs:{dtype:"complex64"}}),t=c.data.get(e.dataId),a=t.complexTensorInfos.real,r=t.complexTensorInfos.imag,s=c.data.get(a.dataId).values,l=c.data.get(r.dataId).values,u=yT({inputs:{x:i},backend:c,attrs:{dtype:"complex64"}}),h=c.data.get(u.dataId),d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,f=c.data.get(d.dataId).values,m=c.data.get(p.dataId).values,[g,y,b]=n(o.shape,i.shape,s,l,f,m),v=c.makeTensorInfo(b,"float32",g),x=c.makeTensorInfo(b,"float32",y),w=hT({inputs:{real:v,imag:x},backend:c});return c.disposeIntermediateTensorInfo(e),c.disposeIntermediateTensorInfo(u),c.disposeIntermediateTensorInfo(v),c.disposeIntermediateTensorInfo(x),w}{const e=c.data.get(o.dataId).values,n=c.data.get(i.dataId).values,r=a||o.dtype,[s,l]=t(o.shape,i.shape,e,n,r);return c.makeTensorInfo(l,r,s)}}}function xT(e){return(t,n,a,r,s,o)=>{const i=vc(t,n),c=Ft(i),l=i.length,u=Qt(i),h=Ut("float32",c),d=Ut("float32",c),p=yc(t,i),f=yc(n,i),m=cm(a,r),g=cm(s,o),y=t.length,b=Qt(t),v=n.length,x=Qt(n);if(p.length+f.length===0)for(let w=0;w<h.length;w++){const t=w%m.length,n=w%g.length,a=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);h[w]=a.real,d[w]=a.imag}else for(let w=0;w<h.length;w++){const t=sn(w,l,u),n=t.slice(-y);p.forEach((e=>n[e]=0));const a=rn(n,y,b),r=t.slice(-v);f.forEach((e=>r[e]=0));const s=rn(r,v,x),o=e(m[2*a],m[2*a+1],g[2*s],g[2*s+1]);h[w]=o.real,d[w]=o.imag}return[h,d,i]}}const wT=JC(((e,t)=>e+t)),kT=xT(((e,t,n,a)=>({real:e+n,imag:t+a}))),ST=vT(vn,wT,kT),IT={kernelName:vn,backendName:"cpu",kernelFunc:ST};function NT(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:s}=a,o=Ft(r.shape),i=zt(s,o),c=Ft(i);Et(o===c,(()=>"The new shape (".concat(i,") has ").concat(c," elements and the old ")+"shape (".concat(r.shape,") has ").concat(o," elements. The new shape and old ")+"shape must have the same number of elements.")),n.incRef(r.dataId);const l=n.data.get(r.dataId);if(null!=l.complexTensorInfos){const e=l.complexTensorInfos.real,t=l.complexTensorInfos.imag;e.shape=i,t.shape=i}return{dataId:r.dataId,shape:i,dtype:r.dtype}}const CT={kernelName:Ir,backendName:"cpu",kernelFunc:NT};function TT(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:o,transposeB:i}=a;UC([r,s],"matMul");const c=r.shape.length,l=s.shape.length,u=o?r.shape[c-2]:r.shape[c-1],h=i?s.shape[l-1]:s.shape[l-2],d=o?r.shape[c-1]:r.shape[c-2],p=i?s.shape[l-2]:s.shape[l-1],f=r.shape.slice(0,-2),m=s.shape.slice(0,-2),g=Ft(f),y=Ft(m),b=vc(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,p]);Et(u===h,(()=>"Error in matMul: inner shapes (".concat(u,") and (")+"".concat(h,") of Tensors with shapes ").concat(r.shape," and ")+"".concat(s.shape," and transposeA=").concat(o)+" and transposeB=".concat(i," must match.")));const v=i?[y,p,h]:[y,h,p],x=NT({inputs:{x:r},backend:n,attrs:{shape:o?[g,u,d]:[g,d,u]}}),w=NT({inputs:{x:s},backend:n,attrs:{shape:v}}),k=o?x.shape[1]:x.shape[2],S=o?x.shape[2]:x.shape[1],I=i?w.shape[1]:w.shape[2],N=Math.max(g,y),C=n.data.get(x.dataId).values,T=n.data.get(w.dataId).values,E=Qt(x.shape),R=Qt(w.shape),[A,_,F]=o?[E[0],1,E[1]]:[E[0],E[1],1],[O,D,M]=i?[1,R[1],R[0]]:[R[1],1,R[0]],L=S*I,P=qi([N,S,I],x.dtype),z=P.values,B=n.blockSize;for(let W=0;W<N;W++)for(let e=0;e<S;e+=B)for(let t=0;t<I;t+=B)for(let n=0;n<k;n+=B){const a=Math.min(e+B,S),r=Math.min(t+B,I),s=Math.min(n+B,k);for(let o=e;o<a;o++)for(let e=t;e<r;e++){let t=0;for(let a=n;a<s;a++){const n=Math.min(W,g-1)*A,r=Math.min(W,y-1)*M;t+=C[n+o*_+a*F]*T[a*O+e*D+r]}z[W*L+(o*I+e)]+=t}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(b,P.dtype,P.values)}const ET={kernelName:Dn,backendName:"cpu",kernelFunc:TT};const RT={kernelName:vs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:o,preluActivationWeights:i}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:h}=a;let d,p,f;const m=[];d=TT({inputs:{a:r,b:s},attrs:{transposeA:c,transposeB:l},backend:n}),o&&(p=ST({inputs:{a:d,b:o},backend:n}),m.push(d),d=p),u&&(f=uT(n,d,u,i,h),m.push(d),d=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return d}};function AT(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const _T={kernelName:gn,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;UC(t,"abs");let a=new Float32Array(Ft(t.shape));return a=AT(n.data.get(t.dataId).values),n.makeOutput(a,t.shape,t.dtype)}},FT=jC(yn,(e=>Math.acos(e))),OT={kernelName:yn,backendName:"cpu",kernelFunc:FT},DT=jC(bn,(e=>Math.acosh(e))),MT={kernelName:bn,backendName:"cpu",kernelFunc:DT};const LT={kernelName:xn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,a=t;UC(t,"addN");const r=a.map((e=>n.data.get(e.dataId).values)),s=qi(a[0].shape,a[0].dtype),o=s.values;for(let i=0;i<a.length;i++){const e=r[i];for(let t=0;t<o.length;t++)o[t]+=e[t]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}};function PT(e,t,n,a,r){const s=t.length,o=Ft(t),i=Qt(t),c=Qt(r),l=Ut(n,Ft(r));for(let u=0;u<o;++u){const t=sn(u,s,i),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[a[e]];l[rn(n,s,c)]=e[u]}return l}function zT(e){const{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{perm:s}=n;UC(r,"transpose");const o=r.shape.length,i=new Array(o);for(let l=0;l<i.length;l++)i[l]=r.shape[s[l]];const c=PT(a.data.get(r.dataId).values,r.shape,r.dtype,s,i);return{dataId:a.write(c,i,r.dtype),shape:i,dtype:r.dtype}}const BT={kernelName:hs,backendName:"cpu",kernelFunc:zT};const WT={kernelName:wn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;UC(r,"all");const i=Bt(s,r.shape);let c=i;const l=Fu(c,r.shape.length);let u=r;null!=l&&(u=zT({inputs:{x:r},backend:n,attrs:{perm:l}}),c=Du(c.length,r.shape.length)),_u("all",c,u.shape.length);const[h,d]=Ru(u.shape,c),p=Ft(d),f=tn(Ft(h),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];t=t&&a}f[y]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(h,u.dtype,f);if(o){const e=NT({inputs:{x:g},backend:n,attrs:{shape:Au(h,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const UT={kernelName:kn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;UC(r,"any");const i=Bt(s,r.shape);let c=i;const l=Fu(c,r.shape.length);let u=r;null!=l&&(u=zT({inputs:{x:r},backend:n,attrs:{perm:l}}),c=Du(c.length,r.shape.length)),_u("any",c,u.shape.length);const[h,d]=Ru(u.shape,c),p=Ft(d),f=tn(Ft(h),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];t=t||a}f[y]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(h,u.dtype,f);if(o){const e=NT({inputs:{x:g},backend:n,attrs:{shape:Au(h,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const VT={kernelName:Sn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;UC(r,"argMax");let o=Bt(s,r.shape);const i=Fu(o,r.shape.length);let c=r;const l=[];null!=i&&(c=zT({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),o=Du(o.length,c.shape.length)),o=[o[0]],_u("argMax",o,c.shape.length);const[u,h]=Ru(c.shape,o),d=tn(Ft(u),"int32"),p=Ft(h),f=n.data.get(c.dataId).values;for(let m=0;m<d.length;++m){const e=m*p;let t=f[e],n=0;for(let a=0;a<p;++a){const r=f[e+a];r>t&&(t=r,n=a)}d[m]=n}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u,"int32",d)}};const GT={kernelName:In,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;UC(r,"argMin");let o=Bt(s,r.shape);const i=Fu(o,r.shape.length);let c=r;const l=[];null!=i&&(c=zT({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),o=Du(o.length,c.shape.length)),o=[o[0]],_u("argMin",o,c.shape.length);const[u,h]=Ru(c.shape,o),d=tn(Ft(u),"int32"),p=Ft(h),f=n.data.get(c.dataId).values;for(let m=0;m<d.length;++m){const e=m*p;let t=f[e],n=0;for(let a=0;a<p;++a){const r=f[e+a];r<t&&(t=r,n=a)}d[m]=n}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u,"int32",d)}},jT=jC(Nn,(e=>Math.asin(e))),HT={kernelName:Nn,backendName:"cpu",kernelFunc:jT},KT=jC(Cn,(e=>Math.asinh(e))),qT={kernelName:Cn,backendName:"cpu",kernelFunc:KT},XT=jC(Tn,(e=>Math.atan(e))),YT={kernelName:Tn,backendName:"cpu",kernelFunc:XT},ZT=JC(((e,t)=>Math.atan2(e,t))),QT=vT(Rn,ZT),JT={kernelName:Rn,backendName:"cpu",kernelFunc:QT},$T=jC(En,(e=>Math.atanh(e))),eE={kernelName:En,backendName:"cpu",kernelFunc:$T};function tE(e,t,n,a,r,s){const o=r.strideHeight,i=r.strideWidth,c=r.dilationHeight,l=r.dilationWidth,u=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=qi(r.outShape,n),g=m.values,y=r.outShape[1]*r.outShape[2]*r.outShape[3],b=r.outShape[2]*r.outShape[3],v=r.outShape[3];for(let x=0;x<r.batchSize;++x){const t=x*y,n=x*a[0];for(let m=0;m<r.inChannels;++m)for(let y=0;y<r.outHeight;++y){const x=y*o-d,w=Math.max(0,x),k=Math.min(r.inHeight,u+x),S=t+y*b;for(let t=0;t<r.outWidth;++t){const o=t*i-p,u=Math.max(0,o),d=Math.min(r.inWidth,h+o);let y=f,b=0,x=0;for(let t=w;t<k;t+=c){const r=n+t*a[1];for(let t=u;t<d;t+=l){const n=e[r+t*a[2]+m];"max"===s&&n>y?y=n:"avg"===s&&(b+=n,x++)}if(isNaN(y))break}g[S+t*v+m]="avg"===s?b/x:y}}}return m}function nE(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=qi(a.outShape,"int32"),i=a.strideHeight,c=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,h=a.effectiveFilterHeight,d=a.effectiveFilterWidth,p=a.padInfo.top,f=a.padInfo.left,m=qi(t,n,e);for(let g=0;g<a.batchSize;++g)for(let e=0;e<a.inChannels;++e)for(let t=0;t<a.outHeight;++t){const n=t*i-p;let y=n;for(;y<0;)y+=l;const b=Math.min(a.inHeight,h+n);for(let i=0;i<a.outWidth;++i){const h=i*c-f;let p=h;for(;p<0;)p+=u;const v=Math.min(a.inWidth,d+h);let x=Number.NEGATIVE_INFINITY,w=-1;for(let t=y;t<b;t+=l){const o=t-n;for(let n=p;n<v;n+=u){const i=n-h,c=m.get(g,t,n,e);c>x&&(x=c,w=r?s?((g*a.inHeight+t)*a.inWidth+n)*a.inChannels+e:(t*a.inWidth+n)*a.inChannels+e:o*d+i)}}o.set(w,g,t,i,e)}}return o}function aE(e,t,n,a,r,s){const o=r.strideDepth,i=r.strideHeight,c=r.strideWidth,l=r.dilationDepth,u=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,y=r.padInfo.left,b="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=qi(r.outShape,n),x=v.values,w=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[2]*r.outShape[3]*r.outShape[4],S=r.outShape[3]*r.outShape[4],I=r.outShape[4];for(let N=0;N<r.batchSize;++N){const t=N*w,n=N*a[0];for(let v=0;v<r.inChannels;++v)for(let w=0;w<r.outDepth;++w){const N=w*o-m;let C=N;for(;C<0;)C+=l;const T=Math.min(r.inDepth,d+N),E=t+w*k;for(let t=0;t<r.outHeight;++t){const o=t*i-g;let d=o;for(;d<0;)d+=u;const m=Math.min(r.inHeight,p+o),w=E+t*S;for(let t=0;t<r.outWidth;++t){const o=t*c-y;let i=o;for(;i<0;)i+=h;const p=Math.min(r.inWidth,f+o),g=w+t*I;let k=b,S=0,N=0;for(let t=C;t<T;t+=l){const r=n+t*a[1];for(let t=d;t<m;t+=u){const n=r+t*a[2];for(let t=i;t<p;t+=h){const r=e[n+t*a[3]+v];if("max"===s&&r>k?k=r:"avg"===s&&(S+=r,N++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}x[g+v]="avg"===s?S/N:k}}}}return v}const rE={kernelName:An,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;UC(r,"avgPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:c}=a;Et(Tl(o,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'")));const l=yl(r.shape,s,o,1,i,c);let u;if(1===l.filterWidth&&1===l.filterHeight&&Ot(l.inShape,l.outShape))u=XC({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=Qt(r.shape),a=tE(e,r.shape,r.dtype,t,l,"avg");u=n.makeTensorInfo(l.outShape,r.dtype,a.values)}return u}};const sE={kernelName:Fn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:c,dataFormat:l}=a;UC(r,"avgPool3d");const u=bl(r.shape,s,o,1,i,c,l),h=aE(n.data.get(r.dataId).values,r.shape,r.dtype,Qt(r.shape),u,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}};const oE={kernelName:On,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:o,strides:i,pad:c,dimRoundingMode:l}=a;UC([r,s],"avgPool3DGrad");const u=bl(s.shape,o,i,1,c,l),h=u.strideDepth,d=u.strideHeight,p=u.strideWidth,f=u.filterDepth,m=u.filterHeight,g=u.filterWidth,y=u.dilationDepth,b=u.dilationHeight,v=u.dilationWidth,x=u.effectiveFilterDepth,w=u.effectiveFilterHeight,k=u.effectiveFilterWidth,S=x-1-u.padInfo.front,I=k-1-u.padInfo.left,N=w-1-u.padInfo.top,C=qi(s.shape,"float32"),T=1/(f*m*g),E=n.bufferSync(r);for(let R=0;R<u.batchSize;++R)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inDepth;++t)for(let n=0;n<u.inHeight;++n)for(let a=0;a<u.inWidth;++a){const r=t-S,s=n-N,o=a-I;let i=0;for(let t=0;t<x;t+=y){const n=(r+t)/h;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=b){const a=(s+t)/d;if(!(a<0||a>=u.outHeight||Math.floor(a)!==a))for(let t=0;t<k;t+=v){const r=(o+t)/p;if(r<0||r>=u.outWidth||Math.floor(r)!==r)continue;i+=E.get(R,n,a,r,e)}}}C.set(i*T,R,t,n,a,e)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}};const iE={kernelName:_n,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,o=s;UC([r,s],"avgPoolGrad");const{filterSize:i,strides:c,pad:l}=a,u=yl(o.shape,i,c,1,l),h=u.strideHeight,d=u.strideWidth,p=u.filterHeight,f=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,y=u.effectiveFilterHeight,b=u.effectiveFilterWidth,v=b-1-u.padInfo.left,x=y-1-u.padInfo.top,w=qi(o.shape,"float32"),k=1/(p*f),S=n.data.get(r.dataId).values,I=qi(r.shape,"float32",S);for(let N=0;N<u.batchSize;++N)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inHeight;++t)for(let n=0;n<u.inWidth;++n){const a=t-x,r=n-v;let s=0;for(let t=0;t<y;t+=m){const n=(a+t)/h;if(!(n<0||n>=u.outHeight||Math.floor(n)!==n))for(let t=0;t<b;t+=g){const a=(r+t)/d;if(a<0||a>=u.outWidth||Math.floor(a)!==a)continue;s+=I.get(N,n,a,e)}}w.set(s*k,N,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const cE={kernelName:Ia,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,scale:s,offset:o,mean:i,variance:c}=t;Et(i.shape.length===c.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Et(null==o||i.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Et(null==s||i.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),UC([r,i,c,s,o],"batchNorm");let{varianceEpsilon:l}=a;null==l&&(l=.001);const u=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,d=n.data.get(c.dataId).values,p=s?n.data.get(s.dataId).values:new Float32Array([1]),f=o?n.data.get(o.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=f.length,y=p.length,b=d.length,v=h.length;let x=0,w=0,k=0,S=0;for(let I=0;I<u.length;++I)m[I]=f[x++]+(u[I]-h[w++])*p[k++]/Math.sqrt(d[S++]+l),x>=g&&(x=0),w>=v&&(w=0),k>=y&&(k=0),S>=b&&(S=0);return n.makeTensorInfo(r.shape,r.dtype,m)}};function lE(e,t,n,a,r){const s=zc(a,t,n),o=Ft(n),i=Qt(a);if(s){const n=Bc(t,i);return"string"===r?e.slice(n,n+o):e.subarray(n,n+o)}const c=qi(a,r,"string"===r?Vm(e):e),l=qi(n,r);for(let u=0;u<l.size;++u){const e=l.indexToLoc(u),n=e.map(((e,n)=>e+t[n]));l.set(c.get(...n),...e)}return"string"===r?Gm(l.values):l.values}function uE(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:o}=a;UC(r,"slice");const[i,c]=Wc(r,s,o);Cc(r,i,c);const l=lE(n.data.get(r.dataId).values,i,c,r.shape,r.dtype);return n.makeTensorInfo(c,r.dtype,l)}const hE={kernelName:Pr,backendName:"cpu",kernelFunc:uE};const dE={kernelName:Mn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:o}=a;UC([r],"batchToSpaceND");const i=s.reduce(((e,t)=>e*t)),c=Xf(r.shape,s,i),l=Yf(c.length,s.length),u=Zf(r.shape,s,i),h=Qf(o,s.length),d=Jf(u,o,s.length),p=NT({inputs:{x:r},backend:n,attrs:{shape:c}}),f=zT({inputs:{x:p},backend:n,attrs:{perm:l}}),m=NT({inputs:{x:f},backend:n,attrs:{shape:u}}),g=uE({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function pE(e,t,n,a,r){const s=Ft(a),o=tn(r,n);for(let i=0;i<e.length;i++){const n=e[i];if(n<0)throw new Error("Input x must be non-negative!");n>=r||(o[n]+=s>0?t[i]:1)}return o}function fE(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=e.shape[0],s=e.shape[1],o=qi([r,n],t.dtype);for(let i=0;i<r;i++)for(let r=0;r<s;r++){const s=e.get(i,r);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(a?o.set(1,i,s):t.size>0?o.set(o.get(i,s)+t.get(i,r),i,s):o.set(o.get(i,s)+1,i,s))}return o}const mE={kernelName:Ln,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:o}=a,i=pE(n.data.get(r.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,i)}};const gE={kernelName:Pn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,i=vc(Array.from(s),Array.from(o));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},yE=oT((e=>Math.ceil(e))),bE=HC(Bn,yE),vE={kernelName:Bn,backendName:"cpu",kernelFunc:bE},xE=jC(Wn,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),wE={kernelName:Wn,backendName:"cpu",kernelFunc:xE},kE={kernelName:Vn,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,a=new Float32Array(Ft(t.shape)),r=n.data.get(t.dataId),s=r.complexTensorInfos.real,o=r.complexTensorInfos.imag,i=n.data.get(s.dataId).values,c=n.data.get(o.dataId).values;for(let l=0;l<i.length;l++){const e=i[l],t=c[l];a[l]=Math.hypot(e,t)}return n.makeOutput(a,t.shape,"float32")}};function SE(e,t,n,a){const r=Vt(n,Ft(t));if(a&&"string"!==n){let t=0;e.forEach((e=>{const n=Ft(e.shape);r.set(e.vals,t),t+=n}))}else{let a=0;e.forEach((e=>{const s="string"===n?Vm(e.vals):e.vals;let o=0;for(let n=0;n<e.shape[0];++n){const i=n*t[1]+a;for(let t=0;t<e.shape[1];++t)r[i+t]=s[o++]}a+=e.shape[1]}))}return r}function IE(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.imag,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}const NE={kernelName:_a,backendName:"cpu",kernelFunc:IE};function CE(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=Bt(r,t[0].shape)[0],o=t.map((e=>e.shape));zf(o,s);let i=Bf(t.map((e=>e.shape)),s);if(0===Ft(i))return n.makeTensorInfo(i,t[0].dtype,[]);const c=t.filter((e=>Ft(e.shape)>0));if(1===c.length)return XC({inputs:{x:c[0]},backend:n});if("complex64"===c[0].dtype){const e=c.map((e=>fT({inputs:{input:e},backend:n}))),t=c.map((e=>IE({inputs:{input:e},backend:n}))),a=CE({inputs:e,backend:n,attrs:{axis:s}}),r=CE({inputs:t,backend:n,attrs:{axis:s}}),o=hT({inputs:{real:a,imag:r},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(r),o}const l=c.map((e=>{const t=Ft(e.shape.slice(s));return NT({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),u=l.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));i=Bf(l.map((e=>e.shape)),1);const h=1===l[0].shape[0],d=SE(u,i,t[0].dtype,h),p=Bf(c.map((e=>e.shape)),s),f=n.makeTensorInfo(p,t[0].dtype,d);return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}const TE={kernelName:Gn,backendName:"cpu",kernelFunc:CE};function EE(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dataFormat:c,dilations:l,dimRoundingMode:u}=a;UC([r,s],"conv2d");const h=El(c),d=vl(r.shape,s.shape,o,l,i,u,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,b=d.padInfo.top,v="channelsLast"===d.dataFormat,x=new co(d.outShape,r.dtype),w=Qt(r.shape),k=Qt(s.shape),S=w[0],I=v?w[1]:w[2],N=v?w[2]:1,C=v?1:w[1],T=x.strides[0],E=v?x.strides[1]:x.strides[2],R=v?x.strides[2]:1,A=v?1:x.strides[1],_=n.data.get(r.dataId).values,F=n.data.get(s.dataId).values,O=x.values;for(let D=0;D<d.batchSize;++D){const e=D*S,t=D*T;for(let n=0;n<d.outHeight;++n){const a=t+n*E,r=n*d.strideHeight-b;for(let t=0;t<p;++t){const n=r+t*m;if(n<0||n>=d.inHeight)continue;const s=t*k[0],o=e+n*I;for(let e=0;e<d.outWidth;++e){const t=a+e*R,n=e*d.strideWidth-y;for(let e=0;e<f;++e){const a=n+e*g;if(a<0||a>=d.inWidth)continue;const r=o+a*N;let i=s+e*k[1];for(let e=0;e<d.inChannels;++e){const n=_[r+e*C];for(let e=0;e<d.outChannels;++e)O[t+e*A]+=n*F[i+e];i+=d.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,O)}const RE={kernelName:jn,backendName:"cpu",kernelFunc:EE};const AE={kernelName:Hn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,pad:i,dataFormat:c,dimRoundingMode:l,filterShape:u}=a;UC([r,s],"conv2dBackpropFilter");const h=El(c),d=vl(r.shape,u,o,1,i,l,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,y="channelsLast"===d.dataFormat,b=new co(d.filterShape,"float32"),v=d.padInfo.left,x=d.padInfo.top,w=n.data.get(r.dataId).values,k=n.data.get(s.dataId).values,S=new co(r.shape,r.dtype,w),I=new co(s.shape,s.dtype,k);for(let N=0;N<m;++N){const e=Math.max(0,Math.ceil((x-N)/p)),t=Math.min(d.outHeight,(d.inHeight+x-N)/p);for(let n=0;n<g;++n){const a=Math.max(0,Math.ceil((v-n)/f)),r=Math.min(d.outWidth,(d.inWidth+v-n)/f);for(let s=0;s<d.inChannels;++s)for(let o=0;o<d.outChannels;++o){let i=0;for(let c=0;c<d.batchSize;++c)for(let l=e;l<t;++l){const e=N+l*p-x;for(let t=a;t<r;++t){const a=n+t*f-v;i+=y?S.get(c,e,a,s)*I.get(c,l,t,o):S.get(c,s,e,a)*I.get(c,o,l,t)}}b.set(i,N,n,s,o)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const _E={kernelName:Kn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:o,strides:i,pad:c,dataFormat:l,dimRoundingMode:u}=a;UC([r,s],"conv2dBackpropInput");const h=Qt(s.shape),d=Qt(r.shape);let p=El(l);const f=vl(o,s.shape,i,1,c,u,!1,p),m=new co(f.inShape,"float32"),g=m.values,y=n.data.get(r.dataId).values,b=n.data.get(s.dataId).values,[v,x,w]=h,{batchSize:k,filterHeight:S,filterWidth:I,inChannels:N,inHeight:C,inWidth:T,outChannels:E,outHeight:R,outWidth:A,strideHeight:_,strideWidth:F}=f;p=f.dataFormat;const O=S-1-f.padInfo.top,D=I-1-f.padInfo.left,M="channelsLast"===p,L=m.strides[0],P=M?m.strides[1]:m.strides[2],z=M?m.strides[2]:1,B=M?1:m.strides[1],W=d[0],U=M?d[1]:d[2],V=M?d[2]:1,G=M?1:d[1];for(let j=0;j<k;++j)for(let e=0;e<N;++e)for(let t=0;t<C;++t){const n=t-O,a=Math.max(0,Math.ceil(n/_)),r=Math.min(R,(S+n)/_);for(let s=0;s<T;++s){const o=s-D,i=Math.max(0,Math.ceil(o/F)),c=Math.min(A,(I+o)/F);let l=0;for(let t=a;t<r;++t){const a=t*_-n;for(let n=i;n<c;++n){const r=W*j+U*t+V*n,s=v*(S-1-a)+x*(I-1-(n*F-o))+w*e;for(let e=0;e<E;++e){l+=y[r+G*e]*b[s+e]}}}g[L*j+P*t+z*s+B*e]=l}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const FE={kernelName:qn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dilations:c}=a;UC([r,s],"conv3d");const l=xl(r.shape,s.shape,o,c,i),{filterDepth:u,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=l,y=g.front,b=g.left,v=g.top,x=new co(l.outShape,r.dtype),w=n.data.get(r.dataId).values,k=n.data.get(s.dataId).values,S=x.values,I=Qt(r.shape),N=Qt(s.shape);for(let C=0;C<l.batchSize;++C){const e=C*I[0],t=C*x.strides[0];for(let n=0;n<l.outDepth;++n){const a=t+n*x.strides[1],r=n*l.strideDepth-y;for(let t=0;t<u;++t){const n=r+t*p;if(n<0||n>=l.inDepth)continue;const s=t*N[0],o=e+n*I[1];for(let e=0;e<l.outHeight;++e){const t=a+e*x.strides[2],n=e*l.strideHeight-v;for(let e=0;e<h;++e){const a=n+e*f;if(a<0||a>=l.inHeight)continue;const r=s+e*N[1],i=o+a*I[2];for(let e=0;e<l.outWidth;++e){const n=t+e*l.outChannels,a=e*l.strideWidth-b;for(let e=0;e<d;++e){const t=a+e*m;if(t<0||t>=l.inWidth)continue;const s=r+e*N[2],o=i+t*l.inChannels;let c=s;for(let e=0;e<l.inChannels;++e){const t=w[o+e];for(let e=0;e<l.outChannels;++e)S[n+e]+=t*k[c+e];c+=l.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};const OE={kernelName:Xn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,pad:i,filterShape:c}=a;UC([r,s],"conv3dBackpropFilterV2");const l=Qt(r.shape),u=Qt(s.shape),h=xl(r.shape,c,o,1,i),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=new co(h.filterShape,"float32"),v=b.values,[x,w,k,S]=b.strides,I=n.data.get(s.dataId).values,[N,C,T,E]=u,R=n.data.get(r.dataId).values,[A,_,F,O]=l,D=h.padInfo.front,M=h.padInfo.left,L=h.padInfo.top;for(let P=0;P<m;++P){const e=Math.max(0,Math.ceil((D-P)/d)),t=Math.min(h.outDepth,(h.inDepth+D-P)/d),n=P*x;for(let a=0;a<g;++a){const r=Math.max(0,Math.ceil((L-a)/p)),s=Math.min(h.outHeight,(h.inHeight+L-a)/p),o=a*w+n;for(let n=0;n<y;++n){const i=Math.max(0,Math.ceil((M-n)/f)),c=Math.min(h.outWidth,(h.inWidth+M-n)/f),l=n*k+o;for(let o=0;o<h.inChannels;++o){const u=o*S+l;for(let l=0;l<h.outChannels;++l){let m=0;for(let u=0;u<h.batchSize;++u){const h=u*A,g=u*N;for(let u=e;u<t;++u){const e=(P+u*d-D)*_+h,t=u*C+g;for(let u=r;u<s;++u){const r=(a+u*p-L)*F+e,s=u*T+t;for(let e=i;e<c;++e){const t=e*E+s;m+=R[(n+e*f-M)*O+r+o]*I[t+l]}}}}v[u+l]=m}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const DE={kernelName:Yn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:o,strides:i,inputShape:c}=a;UC([r],"conv3dBackpropInputV2");const l=Qt(r.shape),u=Qt(s.shape),h=xl(c,s.shape,i,1,o),d=new co(h.inShape,"float32"),p=d.values,[f,m,g,y]=d.strides,b=n.data.get(r.dataId).values,[v,x,w,k]=l,S=n.data.get(s.dataId).values,[I,N,C,T]=u,{batchSize:E,filterDepth:R,filterHeight:A,filterWidth:_,inChannels:F,inDepth:O,inHeight:D,inWidth:M,outChannels:L,outDepth:P,outHeight:z,outWidth:B,strideDepth:W,strideHeight:U,strideWidth:V}=h,G=R-1-h.padInfo.front,j=A-1-h.padInfo.top,H=_-1-h.padInfo.left;for(let K=0;K<E;++K)for(let e=0;e<F;++e)for(let t=0;t<O;++t){const n=t-G,a=Math.max(0,Math.ceil(n/W)),r=Math.min(P,(R+n)/W);for(let s=0;s<D;++s){const o=s-j,i=Math.max(0,Math.ceil(o/U)),c=Math.min(z,(A+o)/U);for(let l=0;l<M;++l){const u=l-H,h=Math.max(0,Math.ceil(u/V)),d=Math.min(B,(_+u)/V);let E=0;for(let t=a;t<r;++t){const a=t*W-n;for(let n=i;n<c;++n){const r=n*U-o;for(let s=h;s<d;++s){const o=v*K+x*t+w*n+k*s,i=I*(R-1-a)+N*(A-1-r)+C*(_-1-(s*V-u))+T*e;for(let e=0;e<L;++e){E+=b[o+e]*S[i+e]}}}}p[f*K+m*t+g*s+y*l+e]=E}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},ME=jC(Zn,(e=>Math.cos(e))),LE={kernelName:Zn,backendName:"cpu",kernelFunc:ME},PE=jC(Qn,(e=>Math.cosh(e))),zE={kernelName:Qn,backendName:"cpu",kernelFunc:PE};const BE={kernelName:ea,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:o}=t,{cropSize:i,method:c,extrapolationValue:l}=a,[u,h,d,p]=r.shape,f=s.shape[0],[m,g]=i,y=qi([f,m,g,p],"float32"),b=n.data.get(s.dataId).values,v=n.data.get(o.dataId).values,x=n.data.get(r.dataId).values,w=Qt(r.shape),k=Qt(y.shape);for(let S=0;S<f;S++){const e=4*S,t=b[e],n=b[e+1],a=b[e+2],r=b[e+3],s=v[S];if(s>=u)continue;const o=m>1?(a-t)*(h-1)/(m-1):0,i=g>1?(r-n)*(d-1)/(g-1):0;for(let u=0;u<m;u++){const e=m>1?t*(h-1)+u*o:.5*(t+a)*(h-1);if(e<0||e>h-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+S*k[0];y.values[n]=l}else if("bilinear"===c){const t=Math.floor(e),a=Math.ceil(e),o=e-t;for(let e=0;e<g;e++){const c=g>1?n*(d-1)+e*i:.5*(n+r)*(d-1);if(c<0||c>d-1){for(let t=0;t<p;t++){const n=t+e*k[2]+u*k[1]+S*k[0];y.values[n]=l}continue}const h=Math.floor(c),f=Math.ceil(c),m=c-h;for(let n=0;n<p;n++){let r=n+h*w[2]+t*w[1]+s*w[0];const i=x[r];r=n+f*w[2]+t*w[1]+s*w[0];const c=x[r];r=n+h*w[2]+a*w[1]+s*w[0];const l=x[r];r=n+f*w[2]+a*w[1]+s*w[0];const d=i+(c-i)*m,p=l+(x[r]-l)*m;r=n+e*k[2]+u*k[1]+S*k[0],y.values[r]=d+(p-d)*o}}}else for(let t=0;t<g;++t){const a=g>1?n*(d-1)+t*i:.5*(n+r)*(d-1);if(a<0||a>d-1){for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+S*k[0];y.values[n]=l}continue}const o=Math.round(a),c=Math.round(e);for(let e=0;e<p;e++){const n=e+o*w[2]+c*w[1]+s*w[0],a=e+t*k[2]+u*k[1]+S*k[0];y.values[a]=x[n]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const WE={kernelName:Jn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:o,reverse:i}=a;UC(r,"cumprod");const c=Fu([s],r.shape.length);let l=r;null!=c&&(l=zT({inputs:{x:r},backend:n,attrs:{perm:c}}));const u=Du(1,r.shape.length)[0];if(u!==l.shape.length-1)throw new Error("backend.cumprod in CPU expects an inner-most "+"axis=".concat(l.shape.length-1," but got axis=").concat(u));const h=ko(l.dtype,"int32"),d=en(Ft(l.shape),h),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=i?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)d[t]=o?1:p[t];else{const n=m(y,e-1);d[t]=o?p[n]*d[n]:p[t]*d[n]}}const g=n.makeTensorInfo(l.shape,h,d);if(null!=c){const e=zT({inputs:{x:g},backend:n,attrs:{perm:Ou(c)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}};const UE={kernelName:$n,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:o,reverse:i}=a;UC(r,"cumsum");const c=Fu([s],r.shape.length);let l=r;null!=c&&(l=zT({inputs:{x:r},backend:n,attrs:{perm:c}}));const u=Du(1,r.shape.length)[0];if(u!==l.shape.length-1)throw new Error("backend.cumsum in CPU expects an inner-most "+"axis=".concat(l.shape.length-1," but got axis=").concat(u));const h=ko(l.dtype,"int32"),d=tn(Ft(l.shape),h),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=i?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)d[t]=o?0:p[t];else{const n=m(y,e-1);d[t]=o?p[n]+d[n]:p[t]+d[n]}}const g=n.makeTensorInfo(l.shape,h,d);if(null!=c){const e=zT({inputs:{x:g},backend:n,attrs:{perm:Ou(c)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}};const VE={kernelName:ta,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:o,binaryOutput:i}=a;if(1===r.shape.length){const e=pE(n.data.get(r.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,e)}if(2===r.shape.length){const e=fE(n.bufferSync(r),n.bufferSync(s),o,i);return n.makeTensorInfo(e.shape,s.dtype,e.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(r.shape.length,"."))}};const GE={kernelName:na,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:o}=a;Et("NHWC"===o,(()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got ".concat(o)));const i=r.shape[0],c=r.shape[1],l=r.shape[2],u=r.shape[3],h=c*s,d=l*s,p=u/(s*s),f=n.data.get(r.dataId).values,m=new Float32Array(i*h*d*p);let g=0;for(let y=0;y<i;++y)for(let e=0;e<h;++e){const t=Math.floor(e/s),n=e%s;for(let e=0;e<d;++e){const a=Math.floor(e/s),r=(n*s+e%s)*p;for(let e=0;e<p;++e){const n=e+r+u*(a+l*(t+c*y));m[g++]=f[n]}}}return n.makeTensorInfo([i,h,d,p],r.dtype,m)}};function jE(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dilations:c,dimRoundingMode:l}=a;UC([r,s],"depthwiseConv2DNative");const u=Qt(r.shape),h=Qt(s.shape);let d=c;null==d&&(d=[1,1]),Et(Tl(o,d),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(o," and dilations '").concat(d,"'")));const p=vl(r.shape,s.shape,o,d,i,l,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,v=b.left,x=b.top,w=p.outChannels/p.inChannels,k=new co(p.outShape,r.dtype),S=n.data.get(r.dataId).values,I=n.data.get(s.dataId).values,N=k.values;for(let C=0;C<p.batchSize;++C){const e=C*u[0],t=C*k.strides[0];for(let n=0;n<p.outHeight;++n){const a=t+n*k.strides[1],r=n*p.strideHeight-x;for(let t=0;t<f;++t){const n=r+t*g;if(n<0||n>=p.inHeight)continue;const s=t*h[0],o=e+n*u[1];for(let e=0;e<p.outWidth;++e){const t=a+e*k.strides[2],n=e*p.strideWidth-v;for(let e=0;e<m;++e){const a=n+e*y;if(a<0||a>=p.inWidth)continue;const r=s+e*h[1],i=o+a*p.inChannels;let c=t,l=r;for(let e=0;e<p.inChannels;++e){const t=S[i+e];for(let e=0;e<w;++e)N[c+e]+=t*I[l+e];c+=w,l+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const HE={kernelName:aa,backendName:"cpu",kernelFunc:jE};const KE={kernelName:ra,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,dilations:i,pad:c,dimRoundingMode:l,filterShape:u}=a;UC([r,s],"depthwiseConv2dNativeBackpropFilter");const h=vl(r.shape,u,o,i,c,l,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new co(h.filterShape,"float32"),y=h.padInfo.left,b=h.padInfo.top,v=h.outChannels/h.inChannels,x=n.data.get(r.dataId).values,w=new co(r.shape,r.dtype,x),k=n.data.get(s.dataId).values,S=new co(s.shape,s.dtype,k);for(let I=0;I<f;++I){const e=Math.max(0,Math.ceil((b-I)/d)),t=Math.min(h.outHeight,(h.inHeight+b-I)/d);for(let n=0;n<m;++n){const a=Math.max(0,Math.ceil((y-n)/p)),r=Math.min(h.outWidth,(h.inWidth+y-n)/p);for(let s=0;s<h.outChannels;++s){const o=Math.trunc(s/v),i=s%v;let c=0;for(let l=0;l<h.batchSize;++l)for(let i=e;i<t;++i){const e=I+i*d-b;for(let t=a;t<r;++t){const a=n+t*p-y;c+=w.get(l,e,a,o)*S.get(l,i,t,s)}}g.set(c,I,n,o,i)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const qE={kernelName:sa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{strides:o,dilations:i,pad:c,dimRoundingMode:l,inputShape:u}=a;UC([r,s],"depthwiseConv2DNativeBackpropInput");const h=Qt(r.shape),d=Qt(s.shape),p=vl(u,s.shape,o,i,c,l,!0),f=new co(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,v=n.data.get(r.dataId).values,[x,w,k]=h,S=n.data.get(s.dataId).values,[I,N,C]=d,{batchSize:T,filterHeight:E,filterWidth:R,inChannels:A,inHeight:_,inWidth:F,outChannels:O,outHeight:D,outWidth:M,strideHeight:L,strideWidth:P}=p,z=E-1-p.padInfo.top,B=R-1-p.padInfo.left,W=O/A;for(let U=0;U<T;++U)for(let e=0;e<A;++e)for(let t=0;t<_;++t){const n=t-z,a=Math.max(0,Math.ceil(n/L)),r=Math.min(D,(E+n)/L);for(let s=0;s<F;++s){const o=s-B,i=Math.max(0,Math.ceil(o/P)),c=Math.min(M,(R+o)/P);let l=0;for(let t=a;t<r;++t){const a=t*L-n;for(let n=i;n<c;++n){const r=x*U+w*t+k*n,s=I*(E-1-a)+N*(R-1-(n*P-o))+C*e;for(let t=0;t<W;++t){l+=v[r+(e*W+t)]*S[s+t]}}}m[g*U+y*t+b*s+e]=l}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const XE={kernelName:oa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=Ft(a.shape),s=n.data.get(a.dataId).values,o=qi([r,r],a.dtype),i=o.values;for(let l=0;l<s.length;l++)i[l*r+l]=s[l];const c=[...a.shape,...a.shape];return n.makeTensorInfo(c,o.dtype,o.values)}},YE={kernelName:ia,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:s}=t,{strides:o,pad:i,dilations:c}=a,l=n,u=l.data.get(r.dataId).values,h=r.shape.length,d=l.data.get(s.dataId).values,p=s.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:v,padInfo:x,strideHeight:w,strideWidth:k,filterHeight:S,filterWidth:I,dilationHeight:N,dilationWidth:C,outShape:T}=gl(r.shape,s.shape,o,i,"NHWC",c),E=Ft(T),R=T.length,A=Vt(r.dtype,E);for(let _=0;_<f;++_)for(let e=0;e<b;++e){const t=e*w-x.top;for(let n=0;n<v;++n){const a=n*k-x.left;for(let o=0;o<y;++o){let i=Number.MIN_SAFE_INTEGER;for(let e=0;e<S;++e){const n=t+e*N;if(n>=0&&n<m)for(let t=0;t<I;++t){const c=a+t*C;if(c>=0&&c<g){const a=rn([_,n,c,o],h,Qt(r.shape)),l=rn([e,t,o],p,Qt(s.shape)),f=u[a]+d[l];f>i&&(i=f)}}}A[rn([_,e,n,o],R,Qt(T))]=i}}}return{dataId:l.write(qs(A,r.dtype),T,r.dtype),shape:T,dtype:r.dtype}}},ZE={kernelName:la,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:s,dy:o}=t,{strides:i,pad:c,dilations:l}=a,u=n,h=$t(r.shape,u.data.get(r.dataId).values),d=$t(s.shape,u.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:N,outShape:C}=gl(r.shape,s.shape,i,c,"NHWC",l);Et(o.rank===C.length,(()=>"Error in ".concat(la,", dy ")+"must have the same rank as output ".concat(C.length,", but got ")+"".concat(o.rank)));const T=$t(C,u.data.get(o.dataId).values),E=nn(s.shape,s.dtype);for(let R=0;R<p;++R)for(let e=0;e<y;++e){const t=e*x-v.top;for(let n=0;n<b;++n){const a=n*w-v.left;for(let r=0;r<g;++r){let s=Number.MIN_SAFE_INTEGER,o=0,i=0;for(let e=0;e<k;++e){const n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){const c=a+t*N;if(c>=0&&c<m){const a=h[R][n][c][r]+d[e][t][r];a>s&&(s=a,o=e,i=t)}}}E[o][i][r]+=T[R][e][n][r]}}}return{dataId:u.write(qs(E,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},QE={kernelName:ca,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:s,dy:o}=t,{strides:i,pad:c,dilations:l}=a,u=n,h=$t(r.shape,u.data.get(r.dataId).values),d=$t(s.shape,u.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:N,outShape:C}=gl(r.shape,s.shape,i,c,"NHWC",l);Et(o.rank===C.length,(()=>"Error in ".concat(ca,", dy ")+"must have the same rank as output ".concat(C.length,", but got ")+"".concat(o.rank)));const T=$t(C,u.data.get(o.dataId).values),E=nn(r.shape,r.dtype);for(let R=0;R<p;++R)for(let e=0;e<y;++e){const t=e*x-v.top;for(let n=0;n<b;++n){const a=n*w-v.left;for(let r=0;r<g;++r){let s=Number.MIN_SAFE_INTEGER,o=t<0?0:t,i=a<0?0:a;for(let e=0;e<k;++e){const n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){const c=a+t*N;if(c>=0&&c<m){const a=h[R][n][c][r]+d[e][t][r];a>s&&(s=a,o=n,i=c)}}}E[R][o][i][r]+=T[R][e][n][r]}}}return{dataId:u.write(qs(E,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},JE=JC(((e,t)=>e*t)),$E=xT(((e,t,n,a)=>({real:e*n-t*a,imag:e*a+t*n}))),eR=vT(sr,JE,$E),tR={kernelName:sr,backendName:"cpu",kernelFunc:eR};function nR(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;let i;UC(r,"sum"),i="bool"===r.dtype?yT({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):XC({inputs:{x:r},backend:n});const c=i.shape.length,l=Bt(s,i.shape),u=Fu(l,c);let h=l,d=i;null!=u&&(d=zT({inputs:{x:i},backend:n,attrs:{perm:u}}),h=Du(h.length,c)),_u("sum",h,d.shape.length);const[p,f]=Ru(d.shape,h);let m=pT(n,p,ko(d.dtype,"int32"));const g=Ft(f),y=n.data.get(m.dataId).values,b=n.data.get(d.dataId).values;for(let v=0;v<y.length;++v){const e=v*g;let t=0;for(let n=0;n<g;++n)t+=b[e+n];y[v]=t}if(o){const e=m;m=NT({inputs:{x:m},backend:n,attrs:{shape:Au(m.shape,l)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(i),null!=u&&n.disposeIntermediateTensorInfo(d),m}const aR={kernelName:jr,backendName:"cpu",kernelFunc:nR};const rR={kernelName:ha,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,s=t,{allDims:o,summedDims:i,idDims:c}=xm(r,s.length);km(o.length,c,s);const{path:l,steps:u}=Sm(i,c),h=u.length;let d=null,p=o.length;const f=[];for(let m=0;m<h;++m){for(const e of u[m]){const{permutationIndices:t,expandDims:a}=wm(p,c[e]);let r;Im(t)?r=s[e]:(r=zT({inputs:{x:s[e]},backend:n,attrs:{perm:t}}),f.push(r));const o=r.shape.slice();for(let e=0;e<a.length;++e)o.splice(a[e],0,1);Ot(r.shape,o)||(r=NT({inputs:{x:r},backend:n,attrs:{shape:o}}),f.push(r)),null===d?d=r:(d=eR({inputs:{a:r,b:d},backend:n}),f.push(d))}m<h-1&&(l[m]>=0&&(d=nR({inputs:{x:d},backend:n,attrs:{axis:l[m]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}};const sR={kernelName:pa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:a,y:r}=t;UC([a,r],"eluGrad");const s=new Float32Array(Ft(r.shape)),o=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values;for(let c=0;c<o.length;++c){const e=o[c];s[c]=e>=1?i[c]:i[c]*(e+1)}return n.makeTensorInfo(r.shape,"float32",s)}},oR=JC(((e,t)=>e===t?1:0)),iR=vT(ma,oR,null,"bool"),cR={kernelName:ma,backendName:"cpu",kernelFunc:iR},lR=nm,uR=am,hR=rm,dR=sm,pR=om,fR=im,mR=jC(fa,(e=>{const t=Math.sign(e),n=Math.abs(e),a=1/(1+lR*n);return t*(1-((((fR*a+pR)*a+dR)*a+hR)*a+uR)*a*Math.exp(-n*n))})),gR={kernelName:fa,backendName:"cpu",kernelFunc:mR},yR=oT((e=>Math.exp(e))),bR=HC(ga,yR,"float32"),vR={kernelName:ga,backendName:"cpu",kernelFunc:bR};function xR(e){const{inputs:t,backend:n,attrs:a}=e,{input:r}=t,{dim:s}=a,o=r.shape.length,i=r.shape.slice();let c=s;return s<0&&(Et(-(o+1)<=s,(()=>"Axis must be in the interval [".concat(-(o+1),", ").concat(o,"]"))),c=o+s+1),i.splice(c,0,1),NT({inputs:{x:r},backend:n,attrs:{shape:i}})}const wR={kernelName:ya,backendName:"cpu",kernelFunc:xR},kR=oT((e=>Math.expm1(e))),SR=HC(ba,kR),IR={kernelName:ba,backendName:"cpu",kernelFunc:SR},NR=JC(((e,t)=>e/t)),CR=vT(ua,NR),TR={kernelName:ua,backendName:"cpu",kernelFunc:CR},ER=JC(((e,t)=>e-t)),RR=xT(((e,t,n,a)=>({real:e-n,imag:t-a}))),AR=vT(ss,ER,RR),_R={kernelName:ss,backendName:"cpu",kernelFunc:AR};function FR(e,t,n){const a=e.shape,r=a[0],s=a[1],o=n.data.get(e.dataId),i=o.complexTensorInfos.real,c=o.complexTensorInfos.imag,l=[r,s],u=Ft(l),h=Ut("float32",u),d=Ut("float32",u);for(let g=0;g<r;g++){const e=uE({inputs:{x:i},backend:n,attrs:{begin:[g,0],size:[1,s]}}),a=uE({inputs:{x:c},backend:n,attrs:{begin:[g,0],size:[1,s]}}),r=hT({inputs:{real:e,imag:a},backend:n}),{real:o,imag:l}=OR(r,t,n),u=cm(o,l);for(let t=0;t<s;t++){const e=dm(u,t);h[g*s+t]=e.real,d[g*s+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(r)}const p=n.makeTensorInfo(l,"float32",h),f=n.makeTensorInfo(l,"float32",d),m=hT({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function OR(e,t,n){const a=Ft(e.shape),r=n.data.get(e.dataId),s=n.data.get(r.complexTensorInfos.real.dataId).values,o=n.data.get(r.complexTensorInfos.imag.dataId).values;if(0===((i=a)&i-1)){const r=DR(s,o,a,t,n),i=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(i,"float32",r.real),t=n.makeTensorInfo(i,"float32",r.imag),s=n.makeTensorInfo([],"float32",Ks(a,"float32")),o=XC({inputs:{x:s},backend:n}),c=TR.kernelFunc({inputs:{a:e,b:s},backend:n}),l=TR.kernelFunc({inputs:{a:t,b:o},backend:n}),u=n.data.get(c.dataId).values,h=n.data.get(l.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),{real:u,imag:h}}return r}{const e=function(e,t,n){const a=new Float32Array(2*t);for(let r=0;r<t;r++){let s=0,o=0;for(let a=0;a<t;a++){const i=mm(r*a,t,n),c=dm(e,a);s+=c.real*i.real-c.imag*i.imag,o+=c.real*i.imag+c.imag*i.real}n&&(s/=t,o/=t),pm(a,s,o,r)}return a}(cm(s,o),a,t);return lm(e)}var i}function DR(e,t,n,a,r){if(1===n)return{real:e,imag:t};const s=cm(e,t),o=n/2,i=um(s),c=i.real,l=i.imag,u=[c.length],h=r.makeTensorInfo(u,"float32",c),d=r.makeTensorInfo(u,"float32",l),p=hT({inputs:{real:h,imag:d},backend:r}),f=hm(s),m=f.real,g=f.imag,y=[m.length],b=r.makeTensorInfo(y,"float32",m),v=r.makeTensorInfo(y,"float32",g),x=hT({inputs:{real:b,imag:v},backend:r}),w=DR(c,l,o,a,r),k=w.real,S=w.imag,I=[k.length],N=r.makeTensorInfo(I,"float32",k),C=r.makeTensorInfo(I,"float32",S),T=hT({inputs:{real:N,imag:C},backend:r}),E=DR(m,g,o,a,r),R=E.real,A=E.imag,_=[R.length],F=r.makeTensorInfo(_,"float32",R),O=r.makeTensorInfo(_,"float32",A),D=hT({inputs:{real:F,imag:O},backend:r}),M=fm(n,a),L=[M.real.length],P=r.makeTensorInfo(L,"float32",M.real),z=r.makeTensorInfo(L,"float32",M.imag),B=hT({inputs:{real:P,imag:z},backend:r}),W=eR({inputs:{a:B,b:D},backend:r}),U=ST({inputs:{a:T,b:W},backend:r}),V=AR({inputs:{a:T,b:W},backend:r}),G=fT({inputs:{input:U},backend:r}),j=fT({inputs:{input:V},backend:r}),H=IE({inputs:{input:U},backend:r}),K=IE({inputs:{input:V},backend:r}),q=CE({inputs:[G,j],backend:r,attrs:{axis:0}}),X=CE({inputs:[H,K],backend:r,attrs:{axis:0}}),Y=r.data.get(q.dataId).values,Z=r.data.get(X.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(C),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(O),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(K),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(X),{real:Y,imag:Z}}const MR={kernelName:va,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t,r=Ft(a.shape),s=a.shape[a.shape.length-1],o=NT({inputs:{x:a},backend:n,attrs:{shape:[r/s,s]}}),i=FR(o,!1,n),c=NT({inputs:{x:i},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),c}};function LR(e){const{backend:t,attrs:n}=e,{shape:a,value:r,dtype:s}=n,o=s||Xt(r),i=Vt(o,Ft(a));return function(e,t,n){e.fill(t)}(i,r),t.makeTensorInfo(a,o,i)}const PR={kernelName:xa,backendName:"cpu",kernelFunc:LR};const zR={kernelName:wa,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,s=a,o=Ut(r.dtype,Ft(r.shape)),[i,c,l,u]=r.shape,h=s.data.get(r.dataId).values;for(let d=0;d<i;d++){const e=d*l*c*u;for(let t=0;t<c;t++){const n=t*(l*u);for(let t=0;t<l;t++){const a=t*u;for(let r=0;r<u;r++){const s=Math.round(l-t-1),i=e+n+a+r;let c=h[i];if(s>=0&&s<l){c=h[e+n+s*u+r]}o[i]=c}}}}return{dataId:s.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},BR=oT((e=>Math.floor(e))),WR=HC(ka,BR),UR={kernelName:ka,backendName:"cpu",kernelFunc:WR},VR=JC(((e,t)=>Math.floor(e/t))),GR=vT(Sa,VR,null,"int32"),jR={kernelName:Sa,backendName:"cpu",kernelFunc:GR};const HR={kernelName:xs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:o,preluActivationWeights:i}=t,{strides:c,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=a;let m=EE({inputs:{x:r,filter:s},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d}});if(o){const e=m;if("NCHW"===u&&1===o.shape.length&&1!==o.shape[0]){const e=NT({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=ST({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=ST({inputs:{a:m,b:o},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===u&&"prelu"===p&&1===i.shape.length&&1!==i.shape[0]){const e=NT({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=uT(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=uT(n,m,p,i,f);n.disposeIntermediateTensorInfo(e)}return m}};const KR={kernelName:ws,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:o,preluActivationWeights:i}=t,{strides:c,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=a;let m=jE({inputs:{x:r,filter:s},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d}});if(o){const e=m;m=ST({inputs:{a:m,b:o},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=uT(n,m,p,i,f),n.disposeIntermediateTensorInfo(e)}return m}};function qR(e,t,n,a,r,s,o,i,c){const l=qi([a,s],n);for(let u=0;u<a;u++){const n=[];let a=0;for(let t=0;t<r;t++){const s=e[u*r+t];a+=s*o[t],n.push(s)}if(a<0||a>=c/s)throw new Error("Invalid indices: ".concat(n," does not index into ").concat(i));for(let e=0;e<s;e++)l.values[u*s+e]=t.get(...t.indexToLoc(a*s+e))}return l}const XR={kernelName:Ca,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=Ft(a.shape),o=r.shape,i=o[o.length-1],[c,l,u,h]=$f(a,r);if(0===l)return n.makeTensorInfo(c,a.dtype,[]);const d=qR(n.data.get(r.dataId).values,n.bufferSync(a),a.dtype,l,i,u,h,a.shape,s);return n.makeTensorInfo(c,a.dtype,d.values)}};function YR(e,t,n){const a=qi(n,e.dtype);for(let r=0;r<a.size;++r){const n=a.indexToLoc(r).slice(),s=n[0],o=n[2],i=t.locToIndex([s,o]);n[2]=t.values[i];const c=e.locToIndex(n);0<=c&&c<e.values.length&&(a.values[r]=e.values[c])}return a}const ZR={kernelName:Na,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:o,batchDims:i}=a;UC([r,s],"gatherV2");const c=Bt(o,r.shape)[0],l=n.data.get(s.dataId).values,u=r.shape[c];for(let v=0;v<l.length;++v){const e=l[v];Et(e<=u-1&&e>=0,(()=>"GatherV2: the index value ".concat(e," is not in [0, ").concat(u-1,"]")))}let h=i;null==i&&(h=0);const d=Ft(s.shape),p=Um(r,s,c,h),f=NT({inputs:{x:r},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=NT({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,d/p.batchSize]}}),g=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=YR(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,b.dtype,b.values)}},QR=JC(((e,t)=>e>t?1:0)),JR=vT(Ta,QR,null,"bool"),$R={kernelName:Ta,backendName:"cpu",kernelFunc:JR},eA=JC(((e,t)=>e>=t?1:0)),tA=vT(Ea,eA,null,"bool"),nA={kernelName:Ea,backendName:"cpu",kernelFunc:tA};const aA={kernelName:Aa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t,r=Ft(a.shape),s=a.shape[a.shape.length-1],o=NT({inputs:{x:a},backend:n,attrs:{shape:[r/s,s]}}),i=FR(o,!0,n),c=NT({inputs:{x:i},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),c}},rA=jC(Fa,(e=>Number.isFinite(e)?1:0),"bool"),sA={kernelName:Fa,backendName:"cpu",kernelFunc:rA},oA=jC(Oa,(e=>Math.abs(e)===1/0?1:0),"bool"),iA={kernelName:Oa,backendName:"cpu",kernelFunc:oA},cA=jC(Da,(e=>Number.isNaN(e)?1:0),"bool"),lA={kernelName:Da,backendName:"cpu",kernelFunc:cA},uA=JC(((e,t)=>e<t?1:0)),hA=vT(La,uA,null,"bool"),dA={kernelName:La,backendName:"cpu",kernelFunc:hA},pA=JC(((e,t)=>e<=t?1:0)),fA=vT(Pa,pA,null,"bool"),mA={kernelName:Pa,backendName:"cpu",kernelFunc:fA};function gA(e,t,n){const a=(t-e)/(n-1),r=tn(n,"float32");r[0]=e;for(let s=1;s<r.length;s++)r[s]=r[s-1]+a;return r}const yA={kernelName:za,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,o=gA(a,r,s);return t.makeTensorInfo([o.length],"float32",o)}},bA=oT((e=>Math.log(e))),vA=HC(Ba,bA),xA={kernelName:Ba,backendName:"cpu",kernelFunc:vA},wA=jC(Wa,(e=>Math.log1p(e))),kA={kernelName:Wa,backendName:"cpu",kernelFunc:wA},SA=JC(((e,t)=>e&&t)),IA=vT(Ua,SA,null,"bool"),NA={kernelName:Ua,backendName:"cpu",kernelFunc:IA},CA=jC(Va,(e=>e?0:1),"bool"),TA={kernelName:Va,backendName:"cpu",kernelFunc:CA},EA=JC(((e,t)=>e||t)),RA=vT(Ga,EA,null,"bool"),AA={kernelName:Ga,backendName:"cpu",kernelFunc:RA};const _A={kernelName:ja,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:o,alpha:i,beta:c}=a;UC(r,"LRN");const l=r.shape[3],u=l-1,h=n.data.get(r.dataId).values,d=Ft(r.shape),p=new Float32Array(d);function f(e){const t=e%l;let n=e-t+Math.max(0,t-s);const a=e-t+Math.min(t+s,u);let r=0;for(;n<=a;n++){const e=h[n];r+=e*e}return r}for(let m=0;m<d;m++){const e=f(m),t=h[m]*Math.pow(o+i*e,-c);p[m]=t}return n.makeTensorInfo(r.shape,r.dtype,p)}};const FA={kernelName:Ha,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:o}=t,{depthRadius:i,bias:c,alpha:l,beta:u}=a;UC(o,"LRNGrad");const h=Ft(o.shape),d=o.shape[3],p=n.data.get(o.dataId).values,f=n.data.get(r.dataId).values,m=n.data.get(s.dataId).values,g=new Float32Array(h),y=h;for(let b=0;b<y;b++){const e=b%d,t=b-e+Math.max(0,e-i),n=b-e+Math.min(d,e+i+1);let a=0;for(let r=t;r<n;r++)a+=Math.pow(f[r],2);a=l*a+c;for(let r=t;r<n;r++){let e=-2*l*u*f[r]*m[b]/a;b===r&&(e+=Math.pow(a,-u)),e*=p[b],g[r]+=e}}return n.makeTensorInfo(o.shape,r.dtype,g)}};function OA(e,t,n,a){const r=Ut(a,Ft(n));for(let s=0;s<r.length;++s){const n=s*t;let a=e[n];for(let r=0;r<t;++r){const t=e[n+r];(Number.isNaN(t)||t>a)&&(a=t)}r[s]=a}return r}function DA(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:o}=a,i=n;let c=r.shape;const l=c.length,u=Bt(s,c);let h=u;const d=Fu(h,l);let p=i.data.get(r.dataId).values;if(null!=d){const e=new Array(l);for(let t=0;t<e.length;t++)e[t]=c[d[t]];p=PT(p,c,r.dtype,d,e),h=Du(h.length,l),c=e}UC(r,"max"),_u("max",h,l);const[f,m]=Ru(c,h),g=OA(p,Ft(m),f,r.dtype),y=i.write(g,f,r.dtype);let b=f;if(o){b=Au(f,u)}return{dataId:y,shape:b,dtype:r.dtype}}const MA={kernelName:Ka,backendName:"cpu",kernelFunc:DA},LA=JC(((e,t)=>Math.max(e,t))),PA=vT(qa,LA),zA={kernelName:qa,backendName:"cpu",kernelFunc:PA};const BA={kernelName:Xa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;UC(r,"maxPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:c}=a;Et(Tl(o,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'")));const l=yl(r.shape,s,o,1,i,c);let u;if(1===l.filterWidth&&1===l.filterHeight&&Ot(l.inShape,l.outShape))u=XC({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=Qt(r.shape),a=tE(e,r.shape,r.dtype,t,l,"max");u=n.makeTensorInfo(l.outShape,r.dtype,a.values)}return u}};const WA={kernelName:Za,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:c,dataFormat:l}=a;UC(r,"maxPool3d");const u=bl(r.shape,s,o,1,i,c,l),h=aE(n.data.get(r.dataId).values,r.shape,r.dtype,Qt(r.shape),u,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}};const UA={kernelName:Qa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:o,strides:i,pad:c,dimRoundingMode:l}=a;UC([r,s],"maxPool3DGrad");const u=bl(s.shape,o,i,1,c,l),h=function(e,t){const n=qi(t.outShape,"int32"),a=t.strideDepth,r=t.strideHeight,s=t.strideWidth,o=t.dilationDepth,i=t.dilationHeight,c=t.dilationWidth,l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*a-d;let v=b;for(;v<0;)v+=o;const x=Math.min(t.inDepth,l+b);for(let a=0;a<t.outHeight;++a){const l=a*r-p;let d=l;for(;d<0;)d+=i;const w=Math.min(t.inHeight,u+l);for(let r=0;r<t.outWidth;++r){const p=r*s-f;let k=p;for(;k<0;)k+=c;const S=Math.min(t.inWidth,h+p);let I=Number.NEGATIVE_INFINITY,N=-1;for(let t=v;t<x;t+=o){const n=t-b;for(let a=d;a<w;a+=i){const r=a-l;for(let s=k;s<S;s+=c){const o=s-p,i=e.get(m,t,a,s,g);i>=I&&(I=i,N=n*u*h+r*u+o)}}}n.set(N,m,y,a,r,g)}}}return n}(n.bufferSync(s),u),d=u.strideDepth,p=u.strideHeight,f=u.strideWidth,m=u.dilationDepth,g=u.dilationHeight,y=u.dilationWidth,b=u.effectiveFilterDepth,v=u.effectiveFilterHeight,x=u.effectiveFilterWidth,w=b-1-u.padInfo.front,k=x-1-u.padInfo.left,S=v-1-u.padInfo.top,I=qi(s.shape,"float32"),N=n.bufferSync(r);for(let C=0;C<u.batchSize;++C)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inDepth;++t)for(let n=0;n<u.inHeight;++n)for(let a=0;a<u.inWidth;++a){const r=t-w,s=n-S,o=a-k;let i=0;for(let t=0;t<b;t+=m){const n=(r+t)/d;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let a=0;a<v;a+=g){const r=(s+a)/p;if(!(r<0||r>=u.outHeight||Math.floor(r)!==r))for(let s=0;s<x;s+=y){const c=(o+s)/f;if(c<0||c>=u.outWidth||Math.floor(c)!==c)continue;const l=b*v*x-1-h.get(C,n,r,c,e)===t*v*x+a*x+s?1:0;if(0===l)continue;i+=N.get(C,n,r,c,e)*l}}}I.set(i,C,t,n,a,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};const VA={kernelName:Ya,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s,output:o}=t,i=s;UC([s,o],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:h}=a,d=yl(i.shape,c,l,1,u,h),p=n.data.get(i.dataId).values,f=qi(d.outShape,i.dtype,nE(p,i.shape,i.dtype,d).values),m=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,b=d.dilationWidth,v=d.effectiveFilterHeight,x=d.effectiveFilterWidth,w=x-1-d.padInfo.left,k=v-1-d.padInfo.top,S=qi(i.shape,"float32"),I=n.data.get(r.dataId).values,N=qi(r.shape,"float32",I);for(let C=0;C<d.batchSize;++C)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inHeight;++t)for(let n=0;n<d.inWidth;++n){const a=t-k,r=n-w;let s=0;for(let t=0;t<v;t+=y){const n=(a+t)/m;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let a=0;a<x;a+=b){const o=(r+a)/g;if(o<0||o>=d.outWidth||Math.floor(o)!==o)continue;const i=v*x-1-f.get(C,n,o,e)===t*x+a?1:0;if(0===i)continue;s+=N.get(C,n,o,e)*i}}S.set(s,C,t,n,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const GA={kernelName:Ja,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{filterSize:s,strides:o,pad:i,includeBatchInIndex:c}=n,l=a;UC(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,h=yl(r.shape,s,o,[1,1],i),[d,p]=function(e,t,n,a,r){const s=tE(e,0,n,Qt(t),r,"max"),o=nE(e,t,n,r,!0,a);return[s.values,o.values]}(u,r.shape,r.dtype,c,h),f=l.write(d,h.outShape,r.dtype),m=l.write(p,h.outShape,r.dtype);return[{dataId:f,shape:h.outShape,dtype:r.dtype},{dataId:m,shape:h.outShape,dtype:"int32"}]}};const jA={kernelName:$a,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a,i=Bt(s,r.shape),c=Ft(Ru(r.shape,i)[1]),l=[],u=n.makeTensorInfo([],"float32",new Float32Array([c]));l.push(u);const h=yT({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});l.push(h);const d=CR({inputs:{a:h,b:u},backend:n});l.push(d);const p=nR({inputs:{x:d},backend:n,attrs:{axis:s,keepDims:o}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}};const HA={kernelName:er,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;UC(r,"min");const i=Bt(s,r.shape);let c=i;const l=Fu(c,r.shape.length);let u=r;null!=l&&(u=zT({inputs:{x:r},backend:n,attrs:{perm:l}}),c=Du(c.length,r.shape.length)),_u("min",c,u.shape.length);const[h,d]=Ru(u.shape,c),p=Ft(d),f=tn(Ft(h),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];(Number.isNaN(a)||a<t)&&(t=a)}f[y]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(h,u.dtype,f);if(o){const e=NT({inputs:{x:g},backend:n,attrs:{shape:Au(h,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}},KA=JC(((e,t)=>Math.min(e,t))),qA=vT(tr,KA),XA={kernelName:tr,backendName:"cpu",kernelFunc:qA};const YA={kernelName:nr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,mode:o}=a;UC(r,"mirrorPad");const i=s.map(((e,t)=>e[0]+r.shape[t]+e[1])),c=s.map((e=>e[0])),l=s.map(((e,t)=>e[0]+r.shape[t])),u="reflect"===o?0:1,h=n.data.get(r.dataId).values,d=r.shape.length,p=Qt(r.shape),f=Ft(i),m=i.length,g=Qt(i),y=Ut(r.dtype,f);for(let b=0;b<f;b++){let e=sn(b,m,g);for(let n=0;n<m;n++)e[n]<c[n]?e[n]=2*c[n]-e[n]-u:e[n]>=l[n]&&(e[n]=2*(l[n]-1)-e[n]+u);e=e.map(((e,t)=>e-c[t]));const t=rn(e,d,p);y[b]=h[t]}return{dataId:n.write(y,i,r.dtype),shape:i,dtype:r.dtype}}},ZA=JC(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),QA=vT(ar,ZA),JA={kernelName:ar,backendName:"cpu",kernelFunc:QA};function $A(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,o=r.shape.length;let i=s;if(-1===i&&(i=o-1),i!==o-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(o," and dim was ").concat(i));const c=Bt([i],r.shape),l=DA({inputs:{x:r},backend:n,attrs:{reductionIndices:c,keepDims:!1}}),u=Au(l.shape,c),h=NT({inputs:{x:l},backend:n,attrs:{shape:u}}),d=AR({inputs:{a:r,b:h},backend:n}),p=bR({inputs:{x:d},backend:n}),f=nR({inputs:{x:p},backend:n,attrs:{axis:c,keepDims:!1}}),m=NT({inputs:{x:f},backend:n,attrs:{shape:u}}),g=CR({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const e_={kernelName:qr,backendName:"cpu",kernelFunc:$A};const t_={kernelName:rr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:o,normalized:i}=a;UC(r,"multinomial");const c=i?r:$A({inputs:{logits:r},backend:n,attrs:{dim:-1}}),l=c.shape[0],u=c.shape[1],h=n.data.get(c.dataId).values,d=[l,s],p=tn(Ft(d),"int32");for(let f=0;f<l;++f){const e=f*u,t=new Float32Array(u-1);t[0]=h[e];for(let r=1;r<t.length;++r)t[r]=t[r-1]+h[e+r];const n=$h.alea(o.toString()),a=f*s;for(let r=0;r<s;++r){const e=n();p[a+r]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[a+r]=n;break}}}return i||n.disposeIntermediateTensorInfo(c),n.makeTensorInfo(d,"int32",p)}};function n_(e,t,n){const a=Ks(-1,n);return JE([],t,a,e,n)}const a_={kernelName:or,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;UC(a,"neg");const r=n.data.get(a.dataId).values,[s,o]=n_(r,a.shape,a.dtype);return n.makeTensorInfo(o,a.dtype,s)}},r_=Lp;const s_={kernelName:cr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:c}=a;UC(r,"NonMaxSuppression");const l=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,{selectedIndices:h}=r_(l,u,o,i,c);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},o_=Pp;const i_={kernelName:lr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:c,padToMaxOutputSize:l}=a;UC(r,"NonMaxSuppressionPadded");const u=n.data.get(r.dataId).values,h=n.data.get(s.dataId).values,{selectedIndices:d,validOutputs:p}=o_(u,h,o,i,c,l);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},c_=zp;const l_={kernelName:ur,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:c,softNmsSigma:l}=a;UC(r,"NonMaxSuppressionWithScore");const u=n.data.get(r.dataId).values,h=n.data.get(s.dataId).values,d=o,p=i,f=c,m=l,{selectedIndices:g,selectedScores:y}=c_(u,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},u_=JC(((e,t)=>e!==t?1:0)),h_=vT(ir,u_,null,"bool"),d_={kernelName:ir,backendName:"cpu",kernelFunc:h_};const p_={kernelName:dr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:o,onValue:i,offValue:c}=a;UC(r,"oneHot");const l=Ft(r.shape),u=new Float32Array(l*o);u.fill(c);const h=n.data.get(r.dataId).values;for(let d=0;d<l;++d)h[d]>=0&&h[d]<o&&(u[d*o+h[d]]=i);return n.makeTensorInfo([...r.shape,o],s,u)}};function f_(e){const{inputs:t,backend:n}=e,{x:a}=t;if("string"===a.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===a.dtype){const e=fT({inputs:{input:a},backend:n}),t=f_({inputs:{x:e},backend:n}),r=IE({inputs:{input:a},backend:n}),s=f_({inputs:{x:r},backend:n}),o=hT({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),o}return LR({backend:n,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}const m_={kernelName:ms,backendName:"cpu",kernelFunc:f_};const g_={kernelName:hr,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const t=fT({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a}),s=IE({inputs:{input:r},backend:a}),o=f_({inputs:{x:s},backend:a}),i=hT({inputs:{real:n,imag:o},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(o),i}return LR({backend:a,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function y_(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return xR({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const s=t[0].shape,o=t[0].dtype;t.forEach((e=>{Rt(s,e.shape,"All tensors passed to stack must have matching shapes"),Et(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],c=t.map((e=>{const t=xR({inputs:{input:e},backend:n,attrs:{dim:r}});return i.push(t),t})),l=CE({inputs:c,backend:n,attrs:{axis:r}});return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}const b_={kernelName:pr,backendName:"cpu",kernelFunc:y_};const v_={kernelName:fr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:o}=a;UC(r,"pad");const i=s.map(((e,t)=>e[0]+r.shape[t]+e[1])),c=s.map((e=>e[0])),l=n.data.get(r.dataId).values,u=Ft(r.shape),h=r.shape.length,d=Qt(r.shape),p=Ft(i),f=i.length,m=Qt(i),g=Ut(r.dtype,p);0!==o&&g.fill(o);for(let y=0;y<u;y++){g[rn(sn(y,h,d).map(((e,t)=>e+c[t])),f,m)]=l[y]}return{dataId:n.write(g,i,r.dtype),shape:i,dtype:r.dtype}}},x_=JC(((e,t)=>Math.pow(e,t))),w_=vT(mr,x_),k_={kernelName:mr,backendName:"cpu",kernelFunc:w_};function S_(e,t,n,a){const[r,s]=Ru(e,a),o=ko(t,"int32"),i=tn(Ft(r),o),c=Ft(s);for(let l=0;l<i.length;++l){const e=l*c;let t=1;for(let a=0;a<c;++a)t*=n[e+a];i[l]=t}return{outVals:i,outShape:r,outDtype:o}}const I_={kernelName:yr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;UC(r,"prod");const i=r.shape.length,c=Bt(s,r.shape),l=Fu(c,i);let u=c,h=r;const d=[];null!=l&&(h=zT({inputs:{x:r},backend:n,attrs:{perm:l}}),d.push(h),u=Du(u.length,i));const p=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=S_(h.shape,h.dtype,p,u);let y=m;return o&&(y=Au(m,c)),d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(y,g,f)}};function N_(e,t,n,a){const r=[];let s=0;const o=t.length-1+n.length,i=new Array(o).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const a=e[n],r=n===e.length-1?t:e[n+1].length;if(0===a.length)throw new Error("Ragged splits may not be empty");if(a[0]<0)throw new Error("Ragged splits must be non-negative");if(a[a.length-1]>r)throw new Error("Ragged splits must not point past values");for(let e=1;e<a.length;++e)if(a[e-1]>a[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,a);let c=1;for(let l=0;l<t.length-1;++l){c*=t[l];const e=t[l+1];for(let t=1;t<c+1;++t)i[l].push(t*e)}for(let l=0;l<e.length;++l){let a=e[l],o=e[l]+1;for(let e=0;e<n.length;++e){const r=n[e],s=e+t.length-1;if(s>=0){const e=i[s],t=e[e.length-1]-r[a];for(let n=a;n<o;++n)i[s].push(r[n+1]+t)}a=r[a],o=r[o]}o!==a&&(r.push([a,o]),s+=o-a)}return{outSplits:i,valueSlices:r,numValues:s}}function C_(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let a=t;a<e.length;a++)n[t-1]*=e[a];return n}function T_(e,t,n,a,r){const s=t.slice();s[0]=r;const o=Vt(n,Ft(s)),i=e.length;return function(e,t,n,a,r,s){const o=C_(t,2)[1],i=C_(s,2)[1];let c=0;for(const l of n)for(let t=l[0];t<l[1];++t){for(let n=0;n<a;++n)r[c*i+n]=e[t*o+n];++c}}(e,t,a,0===i?0:i/t[0],o,s),[o,s]}function E_(e,t,n,a,r,s,o,i){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,a)=>{if(e<0||e>=n){const r=sn(a,t.length,Qt(t)).join(",");throw new Error("indices[".concat(r,"] = ").concat(e," is not in [0, ").concat(n,")"))}}))}(s,o,t[0][0]-1),0===a.length)throw new Error("params.rank must be nonzero");const c=a[0],{outSplits:l,valueSlices:u,numValues:h}=N_(s,o,e,c),d=function(e){const t=[];for(let n=0;n<e.length;++n){const a=Vt("int32",e[n].length);t.push(a),e[n].forEach(((e,t)=>a[t]=e))}return t}(l),p=T_(n,a,r,u,h);return[d,p[0],p[1]]}const R_={kernelName:br,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:s,indices:o}=t,{outputRaggedRank:i}=a,c=r.map((e=>n.data.get(e.dataId).values)),l=r.map((e=>e.shape)),u=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,[d,p,f]=E_(c,l,u,s.shape,s.dtype,h,o.shape),m=d.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}};var A_=Wf;class __{constructor(e,t,n,a,r,s,o,i,c,l){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=a,this.valuesDType=r,this.defaultValue=s,this.defaultValueShape=o,this.rowPartitionValues=i,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=Vf(l),this.raggedRank=Gf(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===A_.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===A_.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case A_.VALUE_ROWIDS:return __.getMaxWidthValueRowID(t);case A_.ROW_SPLITS:return __.getMaxWidthRowSplit(t);default:throw new Error("Cannot handle partition type ".concat(A_[this.getRowPartitionTypeByDimension(e-1)]))}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let a=0;a<t-1;++a){const t=e[a+1]-e[a];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,a=e[0],r=0;for(let s=1;s<t;++s){const t=e[s];t!==a&&(a=t,r=Math.max(s-n,r),n=s)}return Math.max(t-n,r)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return O_(e,n)}calculateOutputSize(e){const t=this.valuesShape;jf(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=Uf(this.raggedRank,n,t);a[0]<0&&(a[0]=e);for(let r=1;r<=this.raggedRank;++r)a[r]<0&&(a[r]=this.getMaxWidth(r));return a}calculateFirstParentOutputIndex(e,t,n){const a=Math.min(e,n),r=[];let s=0;for(let o=0;o<a;++o,s+=t)r.push(s);for(let o=a;o<e;++o)r.push(-1);return Et(r.length===e,(()=>"Final length of result must be equal to firstDimension.")),r}calculateOutputIndexRowSplit(e,t,n,a){const r=e.length,s=[];for(let o=0;o<r-1;++o){const r=e[o+1]-e[o];let i=Math.min(a,r),c=t[o];-1===c&&(i=0);for(let e=0;e<i;++e)s.push(c),c+=n;for(let e=0;e<r-i;++e)s.push(-1)}if(r>0&&s.length!==e[r-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(e,t,n,a){const r=e.length,s=[];if(0===r)return[];let o=0,i=e[0];if(i>=t.length)throw new Error("Got currentValueRowId=".concat(i,", which is not less than ").concat(t.length));let c=t[i];s.push(c);for(let l=1;l<r;++l){const r=e[l];if(r===i)c>=0&&(++o,o<a?c+=n:c=-1);else{if(o=0,i=r,r>=t.length)throw new Error("Got nextValueRowId=".concat(r," which is not less than ").concat(t.length));c=t[r]}s.push(c)}if(s.length!==e.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(e,t,n,a){const r=this.getRowPartitionTensor(e),s=this.getRowPartitionTypeByDimension(e);switch(s){case A_.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(r,t,n,a);case A_.ROW_SPLITS:if(r.length-1>t.length)throw new Error("Row partition size is greater than output size: ".concat(r.length-1," > ").concat(t.length));return this.calculateOutputIndexRowSplit(r,t,n,a);default:throw new Error("Unsupported partition type: ".concat(A_[s]))}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case A_.FIRST_DIM_SIZE:return e[0];case A_.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case A_.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type ".concat(A_[t]))}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let s=n.length-2;s>=0;--s)n[s]=n[s+1]*t[s+1];const a=O_(t,!1),r=Vt(this.valuesDType,Ft(a));if(n[0]*t[0]>0){let s=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){s=this.calculateOutputIndex(e-1,s,n[e],t[e])}this.setOutput(this.raggedRank,s,r,a)}return[a,r]}setOutput(e,t,n,a){if(0===n.length)return;const r=this.values,s=n;let o=a.slice();o=o.slice(e+1);const i=Ft(o),c=t.length;let l=this.defaultValue;if(l.length!==i&&1!==l.length){const e=this.defaultValueShape;Xc((()=>{const t=Al(l,e),n=ql(t,o);l=n.dataSync()}))}let u=0,h=0,d=0;for(let p=0;p<=c;++p){let e=p<c?t[p]:-1;if(e!==d){if(h<d){const e=r.subarray(u*i);F_(s.subarray(h*i),e,(d-h)*i)}if(p>=c){const t=n.length;e=Math.floor(t/i)}if(e>d)if(1===this.defaultValue.length)s.subarray(d*i,e*i).fill(this.defaultValue[0]),d=e;else for(;e>d;){F_(s.slice(d*i),l,i),++d}e<0?(u=p+1,h=d):(u=p,h=d,d=h+1)}else++d}}}function F_(e,t,n){for(let a=0;a<n;a++)e[a]=t[a]}function O_(e,t){const n=[];for(let a of e){if(a<0){if(!t)throw new Error("Dimension ".concat(a," must be >= 0"));if(a<-1)throw new Error("Dimension ".concat(a," must be >= -1"));a=-1}n.push(a)}return n}function D_(e,t,n,a,r,s,o,i,c,l){return new __(e,t,n,a,r,s,o,i,c,l).compute()}const M_={kernelName:vr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{shape:r,values:s,defaultValue:o,rowPartitionTensors:i}=t,{rowPartitionTypes:c}=a,l=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,d=i.map((e=>n.data.get(e.dataId).values)),p=i.map((e=>e.shape)),[f,m]=D_(l,r.shape,u,s.shape,s.dtype,h,o.shape,d,p,c);return n.makeTensorInfo(f,s.dtype,m)}};function L_(e,t,n,a){if(e===t||e<t&&n<0||t<e&&n>1)return tn(0,a);const r=tn(Math.abs(Math.ceil((t-e)/n)),a);t<e&&1===n&&(n=-1),r[0]=e;for(let s=1;s<r.length;s++)r[s]=r[s-1]+n;return r}const P_={kernelName:xr,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,dtype:s,step:o}=n,i=L_(a,r,o,s);return t.makeTensorInfo([i.length],s,i)}},z_=jC(kr,(e=>1/e)),B_={kernelName:kr,backendName:"cpu",kernelFunc:z_};const W_={kernelName:Tr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:o,size:i}=a;UC(r,"resizeBilinear");const c=Qt(r.shape),[l,u]=i,[h,d,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(Ft([h,l,u,f])),y=[s&&l>1?d-1:d,s&&u>1?p-1:p],b=[s&&l>1?l-1:l,s&&u>1?u-1:u];let v=0;const x=y[0]/b[0],w=y[1]/b[1];for(let k=0;k<h;k++)for(let e=0;e<l;e++){let t;t=o?x*(e+.5)-.5:x*e;const n=Math.max(0,Math.floor(t)),a=t-n,r=Math.min(d-1,Math.ceil(t)),s=k*c[0]+n*c[1],i=k*c[0]+r*c[1];for(let e=0;e<u;e++){let t;t=o?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),r=t-n,l=Math.min(p-1,Math.ceil(t)),u=s+n*c[2],h=i+n*c[2],d=s+l*c[2],y=i+l*c[2];for(let e=0;e<f;e++){const t=m[u+e],n=m[h+e],s=t+(m[d+e]-t)*r,o=s+(n+(m[y+e]-n)*r-s)*a;g[v++]=o}}}return n.makeTensorInfo([h,l,u,f],"float32",g)}};const U_={kernelName:Er,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:o}=a;UC([s,r],"resizeBilinearGrad");const i=Qt(r.shape),[c,l,u,h]=r.shape,[,d,p]=s.shape,f=new Float32Array(c*l*u*h),m=[o&&d>1?l-1:l,o&&p>1?u-1:u],g=[o&&d>1?d-1:d,o&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],v=n.data.get(s.dataId).values;let x=0;for(let w=0;w<c;w++){const e=w*i[0];for(let t=0;t<d;t++){const n=t*y,a=Math.floor(n),r=Math.min(Math.ceil(n),l-1),s=e+a*i[1],o=e+r*i[1],c=n-a,d=1-c;for(let e=0;e<p;e++){const t=e*b,n=Math.floor(t),a=Math.min(Math.ceil(t),u-1),r=t-n,l=1-r,p=s+n*i[2],m=s+a*i[2],g=o+n*i[2],y=o+a*i[2],w=d*l,k=d*r,S=c*l,I=c*r;for(let e=0;e<h;e++){const t=v[x++];f[p+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*S,f[y+e]+=t*I}}}}return n.makeTensorInfo([c,u,l,h],"float32",f)}};const V_={kernelName:Nr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:o,size:i}=a;UC(r,"resizeNearestNeighbor");const c=Qt(r.shape),[l,u]=i,[h,d,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(h*l*u*f),y=[s&&l>1?d-1:d,s&&u>1?p-1:p],b=[s&&l>1?l-1:l,s&&u>1?u-1:u],v=y[0]/b[0],x=y[1]/b[1];let w=0;for(let k=0;k<h;k++){const e=k*c[0];for(let t=0;t<l;t++){const n=o?v*(t+.5):v*t;let a=Math.min(d-1,s?Math.round(n):Math.floor(n));o&&(a=Math.max(0,a));const r=e+a*c[1];for(let e=0;e<u;e++){const t=o?x*(e+.5):x*e;let n=Math.min(p-1,s?Math.round(t):Math.floor(t));o&&(n=Math.max(0,n));const a=r+n*c[2];for(let e=0;e<f;e++){const t=m[a+e];g[w++]=t}}}}return n.makeTensorInfo([h,l,u,f],r.dtype,g)}};const G_={kernelName:Cr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:o}=a;UC([s,r],"resizeNearestNeighborGrad");const i=Qt(r.shape),c=Qt(s.shape),[l,u,h,d]=r.shape,[,p,f]=s.shape,m=new Float32Array(l*u*h*d),g=n.data.get(s.dataId).values,y=[o&&p>1?u-1:u,o&&f>1?h-1:h],b=[o&&p>1?p-1:p,o&&f>1?f-1:f],v=y[0]/b[0],x=y[1]/b[1],w=1/v,k=1/x,S=2*Math.ceil(w)+2,I=2*Math.ceil(k)+2;for(let N=0;N<l;N++){const e=N*i[0];for(let t=0;t<u;t++){const n=e+t*i[1],a=Math.floor(t*w),r=Math.floor(a-S/2);for(let s=0;s<h;s++){const a=n+s*i[2],l=Math.floor(s*k),y=Math.floor(l-I/2);for(let n=0;n<d;n++){let i=0;for(let a=0;a<S;a++){const l=a+r;if(l<0||l>=p)continue;const d=e+l*c[1],m=l*v;if(t===Math.min(u-1,o?Math.round(m):Math.floor(m)))for(let e=0;e<I;e++){const t=e+y;if(t<0||t>=f)continue;const a=d+t*c[2],r=t*x;s===Math.min(h-1,o?Math.round(r):Math.floor(r))&&(i+=g[a+n])}}m[a+n]=i}}}}return n.makeTensorInfo(r.shape,r.dtype,m)}};const j_={kernelName:Ar,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a;UC(r,"reverse");const o=r.shape.length,i=Bt(s,r.shape);if(0===o)return XC({inputs:{x:r},backend:n});const c=new co(r.shape,r.dtype),l=n.bufferSync(r);for(let u=0;u<c.size;u++){const e=c.indexToLoc(u),t=e.slice();i.forEach((e=>t[e]=r.shape[e]-1-t[e])),c.set(l.get(...t),...e)}return n.makeTensorInfo(c.shape,c.dtype,c.values)}},H_={kernelName:bs,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,{radians:s,fillValue:o,center:i}=n,c=a,l=Ut(r.dtype,Ft(r.shape)),[u,h,d,p]=r.shape,[f,m]=qf(i,h,d),g=Math.sin(s),y=Math.cos(s),b=c.data.get(r.dataId).values;for(let v=0;v<u;v++){const e=v*d*h*p;for(let t=0;t<h;t++){const n=t*(d*p);for(let a=0;a<d;a++){const r=a*p;for(let s=0;s<p;s++){const i=[u,t,a,s],c=i[2],v=i[1];let x=(c-f)*y-(v-m)*g,w=(c-f)*g+(v-m)*y;x=Math.round(x+f),w=Math.round(w+m);let k=o;if("number"!==typeof o&&(k=3===s?255:o[s]),x>=0&&x<d&&w>=0&&w<h){k=b[e+w*(d*p)+x*p+s]}l[e+n+r+s]=k}}}}return{dataId:c.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},K_=jC(_r,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),q_={kernelName:_r,backendName:"cpu",kernelFunc:K_},X_=oT((e=>1/Math.sqrt(e))),Y_=HC(Fr,X_),Z_={kernelName:Fr,backendName:"cpu",kernelFunc:Y_};function Q_(e,t,n,a,r,s,o,i,c,l){const u=[a/r,r],h=e.values,d=t.values;if(0===a)return qi(n,t.dtype);const p=qi(u,t.dtype);"string"===typeof c||"number"===typeof c?p.values.fill(c):"boolean"===typeof c&&p.values.fill(+c);for(let f=0;f<s;f++){const e=[];let s=0;for(let t=0;t<o;t++){const n=h[f*o+t];e.push(n),s+=n*i[t]}if(s<0||s>=a/r)throw new Error("Invalid indices: ".concat(e," does not index into ").concat(n));for(let n=0;n<r;n++)l?p.values[s*r+n]+=d[f*r+n]:p.values[s*r+n]=0===t.rank?d[0]:d[f*r+n]}return p}const J_={kernelName:Or,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:o}=a,{sliceRank:i,numUpdates:c,sliceSize:l,strides:u,outputSize:h}=op(0,r,o),d=Q_(n.bufferSync(r),n.bufferSync(s),o,h,l,c,i,u,0,!0);return n.makeTensorInfo(o,d.dtype,d.values)}};function $_(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<t?n=r+1:a=r;return a}function eF(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<=t?n=r+1:a=r;return a}const tF={kernelName:Dr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:o}=a,i=function(e,t,n,a,r,s){const o=Vt("int32",n*r);for(let i=0;i<n;++i){const n=e.slice(i*a,(i+1)*a),c=i*r;for(let e=0;e<r;++e)o[c+e]="left"===s?$_(n,t[e+c]):eF(n,t[e+c])}return o}(n.data.get(r.dataId).values,n.data.get(s.dataId).values,r.shape[0],r.shape[1],s.shape[1],o);return n.makeTensorInfo(s.shape,"int32",i)}};const nF={kernelName:Mr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t;UC([a,r,s],"select");const o=a.shape.length,i=n.data.get(a.dataId).values,c=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=ko(r.dtype,s.dtype),h=tn(Ft(r.shape),u);let d=0;const p=0===o||o>1||1===r.shape.length?1:Ft(r.shape.slice(1));for(let f=0;f<i.length;f++)for(let e=0;e<p;e++)1===i[f]?h[d++]=c[f]:h[d++]=l[f];return n.makeTensorInfo(r.shape,u,h)}},aF=em,rF=tm,sF=jC(Lr,(e=>e>=0?rF*e:aF*(Math.exp(e)-1))),oF={kernelName:Lr,backendName:"cpu",kernelFunc:sF},iF=jC(Wr,(e=>e<0?-1:e>0?1:0)),cF={kernelName:Wr,backendName:"cpu",kernelFunc:iF},lF=jC(zr,(e=>Math.sin(e))),uF={kernelName:zr,backendName:"cpu",kernelFunc:lF},hF=jC(Br,(e=>Math.sinh(e))),dF={kernelName:Br,backendName:"cpu",kernelFunc:hF},pF=Math.log(1.1920928955078125e-7)+2,fF=jC(Vr,(e=>{const t=e>-pF,n=e<pF,a=Math.exp(e);let r;return r=n?a:t?e:Math.log(1+a),r})),mF={kernelName:Vr,backendName:"cpu",kernelFunc:fF};const gF={kernelName:Hr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:o}=a;UC([r],"spaceToBatchND");const i=Ft(s),c=[[0,0]];c.push(...o);for(let g=1+s.length;g<r.shape.length;++g)c.push([0,0]);const l=v_.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:c,constantValue:0}}),u=Xf(l.shape,s,i,!1),h=Yf(u.length,s.length,!1),d=Zf(l.shape,s,i,!1),p=NT({inputs:{x:l},backend:n,attrs:{shape:u}}),f=zT({inputs:{x:p},backend:n,attrs:{perm:h}}),m=NT({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function yF(e,t,n,a,r,s,o){const i=t[0],c=s[0],l=new Array(c),u=new Array(i),h=t[1];if(0===c){if(0!==i)throw new Error(Tm(i));return[Vt(n,0),[0,h],Vt(r,0),l,u]}let d=!0,p=0;const f=new Array(c).fill(0);for(let g=0;g<i;++g){const t=e[g*h];if(t<0)throw new Error(Em(g,t));if(t>=c)throw new Error(Rm(g,t,c));++f[t],d=d&&t>=p,p=t}let m=!0;for(let g=0;g<c;++g){const e=0===f[g];l[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){const t=e,n=a;for(let e=0;e<i;++e)u[e]=e;return[t,[i,h],n,l,u]}{const t=f[c-1],s=Vt(n,t*h),d=Vt(r,t),p=new Array(c).fill(0);for(let n=0;n<i;++n){const t=e[n*h],r=p[t],o=(0===t?0:f[t-1])+r;p[t]++;for(let a=0;a<h;++a)s[o*h+a]=e[n*h+a];d[o]=a[n],u[n]=o}for(let e=0;e<c;++e){if(0===p[e]){const t=0===e?0:f[e-1];s[t*h+0]=e;for(let e=1;e<h;++e)s[t*h+e]=0;d[t]=o}}return[s,[t,h],d,l,u]}}const bF={kernelName:Xr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:o}=t;if(1!==s.shape.length)throw new Error("Dense shape must be a vector, saw:\n        ".concat(s.shape));if(2!==a.shape.length)throw new Error("Indices must be a matrix, saw:\n        ".concat(a.shape));if(1!==r.shape.length)throw new Error("Values must be a vector, saw:\n        ".concat(r.shape));if(0!==o.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(o.shape));const i=n.data.get(a.dataId).values,c=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(o.dataId).values[0],[h,d,p,f,m]=yF(i,a.shape,a.dtype,c,r.dtype,l,u);return[n.makeTensorInfo(d,a.dtype,h),n.makeTensorInfo([d[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}};function vF(e,t,n,a,r){const s=Ft(a),o=t[0],i=r.length,c=[];let l=1,u=-1;for(let m=0;m<i;++m){const e=r[m];if(-1===e){if(-1!==u)throw new Error(Am(u,m));u=m,c.push(1)}else{if(e<0)throw new Error(_m(m,e));l*=e,c.push(e)}}if(-1!==u){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(s/l);if(l*e!==s)throw new Error(Om(a,c));c[u]=e}if(Ft(c)!==s)throw new Error(Dm(a,c));const h=a.length,d=[];if(h>0){d[h-1]=1;for(let e=h-2;e>=0;--e)d[e]=d[e+1]*a[e+1]}const p=[];if(i>0){p[i-1]=1;for(let e=i-2;e>=0;--e)p[e]=p[e+1]*c[e+1]}const f=Vt(n,o*i);for(let m=0;m<o;++m){let t=0;for(let n=0;n<h;++n)t+=e[m*h+n]*d[n];for(let e=0;e<i;++e)f[m*i+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[o,i],c]}const xF={kernelName:Yr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape\n        ".concat(a.shape));if(1!==r.shape.length)throw new Error("Input shape should be a vector but received shape\n        ".concat(r.shape));if(1!==s.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(s.shape));const o=Array.from(n.data.get(r.dataId).values),i=n.data.get(a.dataId).values,c=Array.from(n.data.get(s.dataId).values),[l,u,h]=vF(i,a.shape,a.dtype,o,c);return[n.makeTensorInfo(u,a.dtype,l),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}};function wF(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const i=a.length,c=[t[0],e.length/t[0]],l=c[1],u=i>0?r[i-1]+1:0;if(u<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=u;const d=Vt(n,h.reduce(((e,t)=>e*t),1));if(0===i)return u>0&&d.fill(o),[d,h];if(u<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=r[p];for(;;){let t=0;if(f<i){if(t=r[f],g===t){++f;continue}if(g>=t)throw new Error("segment ids are not increasing")}if(g<0||g>=u)throw new Error(Pm(g,u));g>m&&d.fill(o,m*l,g*l);for(let n=p;n<f;++n){const t=a[n];if(t<0||t>=c[0])throw new Error(zm(n,a[n],c[0]));for(let n=0;n<l;n++)d[g*l+n]+=e[t*l+n]}if(s)for(let e=0;e<l;e++)d[g*l+e]/=f-p;if(p=f,++f,m=g+1,g=t,f>i)break}return m<u&&d.fill(o,m*l,u*l),[d,h]}const kF={kernelName:Zr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n          ".concat(r.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n          ".concat(s.shape));if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,[l,u]=wF(o,a.shape,a.dtype,i,c,!0);return n.makeTensorInfo(u,a.dtype,l)}};const SF={kernelName:Qr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n         ".concat(r.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n         ".concat(s.shape));if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,[l,u]=wF(o,a.shape,a.dtype,i,c);return n.makeTensorInfo(u,a.dtype,l)}};const IF={kernelName:Jr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:o}=t,{outputShape:i}=a,{sliceRank:c,numUpdates:l,sliceSize:u,strides:h,outputSize:d}=op(0,r,i),p=!1,f=n.bufferSync(r);let m;switch(s.dtype){case"bool":m=Q_(f,n.bufferSync(s),i,d,u,l,c,h,Boolean(n.data.get(o.dataId).values[0]),p);break;case"float32":m=Q_(f,n.bufferSync(s),i,d,u,l,c,h,n.data.get(o.dataId).values[0],p);break;case"int32":m=Q_(f,n.bufferSync(s),i,d,u,l,c,h,n.data.get(o.dataId).values[0],p);break;case"string":m=Q_(f,n.bufferSync(s),i,d,u,l,c,h,Zs(n.data.get(o.dataId).values[0]),p);break;default:throw new Error("Unsupported type ".concat(s.dtype))}return n.makeTensorInfo(i,m.dtype,m.values)}};const NF={kernelName:Kr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:o}=a,i=Bt(o,r.shape)[0],c=Cm(r,s,i),l=new Array(r.shape.length).fill(0),u=r.shape.slice();return c.map((e=>{const t=[...u];t[i]=e;const a=uE({inputs:{x:r},backend:n,attrs:{begin:l,size:t}});return l[i]+=e,a}))}},CF=oT((e=>Math.sqrt(e))),TF=jC(Gr,(e=>Math.sqrt(e))),EF={kernelName:Gr,backendName:"cpu",kernelFunc:TF},RF={kernelName:es,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:a}=t,r=n;UC(a,"square");const s=r.data.get(a.dataId).values,o=new Float32Array(s.length);for(let i=0;i<s.length;++i){const e=s[i];o[i]=e*e}return{dataId:r.write(o,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},AF=JC(((e,t)=>{const n=e-t;return n*n})),_F=vT($r,AF),FF={kernelName:$r,backendName:"cpu",kernelFunc:_F},OF=jC(gs,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),DF={kernelName:gs,backendName:"cpu",kernelFunc:OF};function MF(e,t,n,a){const r=qi(e,t.dtype);for(let s=0;s<r.size;s++){const e=r.indexToLoc(s),o=new Array(e.length);for(let t=0;t<o.length;t++)o[t]=e[t]*n[t]+a[t];r.set(t.get(...o),...e)}return r}const LF={kernelName:ts,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,end:o,strides:i,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=a;UC(r,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=Uc(r.shape,s,o,i,c,l,u,h,d);let w;if(m)w=NT({inputs:{x:r},backend:n,attrs:{shape:f}});else if(g||y){Et(r.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(r.shape.length)));const e=Ec(b,v,x),t=uE({inputs:{x:r},backend:n,attrs:{begin:b,size:e}});w=NT({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=MF(p,n.bufferSync(r),x,b);w=n.makeTensorInfo(f,e.dtype,e.values)}return w}};class PF{constructor(e,t,n,a,r,s){this.separator=Ys(e),this.nGramWidths=t,this.leftPad=Ys(n),this.rightPad=Ys(a),this.padWidth=r,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,a,r,s){for(let o=0;o<r;++o){const i=this.getPadWidth(s),c=Math.max(0,i-o),l=Math.max(0,i-(r-(o+1))),u=s-(c+l),h=t+(c>0?0:o-i);let d=0;d+=c*this.leftPad.length;for(let t=0;t<u;++t)d+=e[h+t].length;d+=l*this.rightPad.length;d+=(c+l+u-1)*this.separator.length,n[a+o]=new Uint8Array(d);const p=n[a+o];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<c;++e)m(this.leftPad),m(this.separator);for(let t=0;t<u-1;++t)m(e[h+t]),m(this.separator);if(u>0){m(e[h+u-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,a=t.length;if(a>0){let e=t[0];if(0!==e)throw new Error("First split value must be 0, got ".concat(e));for(let r=1;r<a;++r){let a=t[r]>=e;if(a=a&&t[r]<=n,!a)throw new Error("Invalid split value ".concat(t[r],", must be in [").concat(e,", ").concat(n,"]"));e=t[r]}if(e!==n)throw new Error("Last split value must be data size. Expected ".concat(n,", got ").concat(e))}const r=a-1,s=Vt("int32",a);if(0===n||0===a){const e=new Array(n);for(let t=0;t<=r;++t)s[t]=0;return[e,s]}s[0]=0;for(let i=1;i<=r;++i){const e=t[i]-t[i-1];let n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),s[i]=s[i-1]+n}const o=new Array(s[r]);for(let i=0;i<r;++i){const n=t[i];let a=s[i];if(this.nGramWidths.forEach((r=>{const s=t[i+1]-t[i],c=this.getNumNGrams(s,r);this.createNGrams(e,n,o,a,c,r),a+=c})),this.preserveShort&&a===s[i]){const r=t[i+1]-t[i];if(0===r)continue;const s=r+2*this.padWidth,c=1;this.createNGrams(e,n,o,a,c,s)}}return[o,s]}}function zF(e,t,n,a,r,s,o,i){return new PF(n,a,r,s,o,i).compute(e,t)}const BF={kernelName:ns,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:o,rightPad:i,padWidth:c,preserveShortSequences:l}=a,{data:u,dataSplits:h}=t,d=n.data.get(u.dataId).values,p=n.data.get(h.dataId).values,[f,m]=zF(d,p,r,s,o,i,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};function WF(e,t,n,a){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)a.push(e.subarray(t,t+1));return}if(1===t.length){const r=t[0];let s=e.indexOf(r);for(;-1!==s;){const t=e.subarray(0,s);n&&0===t.length||a.push(t),s=(e=e.subarray(s+1)).indexOf(r)}return void(n&&0===e.length||a.push(e))}let r=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){const t=e.subarray(r,s);n&&0===t.length||a.push(t),r=s+1}}function UF(e,t,n){const a=e.length,r=[];let s=0,o=0;const i=new Array(a);for(let d=0;d<a;++d){const a=r.length;WF(e[d],t,n,r);const c=r.length-a;i[d]=c,s+=c,o=Math.max(o,c)}const c=Vt("int32",2*s),l=new Array(s),u=[a,o];let h=0;for(let d=0;d<a;++d)for(let e=0;e<i[d];++e)c[2*h]=d,c[2*h+1]=e,l[h]=r[h],++h;return[c,l,u]}const VF={kernelName:as,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:s,delimiter:o}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error("Input must be a vector, got shape: ".concat(s.shape));if(0!==o.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(o.shape));const i=n.data.get(s.dataId).values,c=n.data.get(o.dataId).values[0],[l,u,h]=UF(i,c,r),d=u.length;return[n.makeTensorInfo([d,2],"int32",l),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};function GF(e,t){const n=Vt("int32",e.length);for(let a=0;a<e.length;++a)n[a]=Hs(e[a]).modulo(t).getLowBitsUnsigned();return n}const jF={kernelName:rs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=GF(n.data.get(s.dataId).values,r);return n.makeTensorInfo(s.shape,"int32",o)}},HF=jC(os,(e=>Math.tan(e))),KF={kernelName:os,backendName:"cpu",kernelFunc:HF},qF=jC(is,(e=>Math.tanh(e)));function XF(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const a=qi(n,e.dtype);for(let r=0;r<a.values.length;++r){const t=a.indexToLoc(r),n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=t[a]%e.shape[a];const s=e.locToIndex(n);a.values[r]=e.values[s]}return a}const YF={kernelName:cs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;UC(r,"tile");const o=XF(n.bufferSync(r),s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}},ZF=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function QF(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;a>n;){if(a-n>600){const r=a-n+1,s=t-n+1,o=Math.log(r),i=.5*Math.exp(2*o/3),c=.5*Math.sqrt(o*i*(r-i)/r)*Math.sign(s-r/2);QF(e,t,Math.max(n,Math.floor(t-s*i/r+c)),Math.min(a,Math.floor(t+(r-s)*i/r+c)))}const r=e[t];let s=n,o=a;for(Tt(e,n,t),ZF(e[a],r)>0&&Tt(e,n,a);s<o;){for(Tt(e,s,o),s++,o--;ZF(e[s],r)<0;)s+=1;for(;ZF(e[o],r)>0;)o-=1}0===ZF(e[n],r)?Tt(e,n,o):(o+=1,Tt(e,o,a)),o<=t&&(n=o+1),t<=o&&(a=o-1)}}function JF(e,t,n,a,r){const s=t[t.length-1],[o,i]=[e.length/s,s],c=Ut(n,o*a),l=Ut("int32",o*a);for(let h=0;h<o;h++){const t=h*i,n=e.subarray(t,t+i);let s=new Array(n.length);n.forEach(((e,t)=>s[t]={value:e,index:t})),a<s.length&&(QF(s,a),s=s.slice(0,a)),r&&s.sort(ZF);const o=h*a,u=c.subarray(o,o+a),d=l.subarray(o,o+a);for(let e=0;e<a;e++)u[e]=s[e].value,d[e]=s[e].index}const u=t.slice();return u[u.length-1]=a,[qi(u,n,c),qi(u,"int32",l)]}const $F={kernelName:ls,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:o}=a;UC(r,"topk");const i=n.data.get(r.dataId).values,[c,l]=JF(i,r.shape,r.dtype,s,o);return[n.makeTensorInfo(c.shape,c.dtype,c.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}};const eO={kernelName:us,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{image:r,transforms:s}=t,{interpolation:o,fillMode:i,fillValue:c,outputShape:l}=n,[u,h,d,p]=r.shape,[f,m]=null!=l?l:[h,d],g=[u,f,m,p],y=Qt(r.shape),b=y[0],v=y[1],x=y[2],w=Qt(g),k=w[0],S=w[1],I=w[2],N=Ut(r.dtype,Ft(g));N.fill(c);const C=a.data.get(r.dataId).values,T=a.data.get(s.dataId).values;for(let E=0;E<u;++E){const e=1===s.shape[0]?T:T.subarray(8*E,8*E+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let a=0;a<p;++a){let r;const s=e[6]*n+e[7]*t+1;if(0===s)continue;const l=(e[0]*n+e[1]*t+e[2])/s,u=(e[3]*n+e[4]*t+e[5])/s,p=tO(l,d,i),f=tO(u,h,i);switch(o){case"nearest":r=aO(C,h,d,b,v,x,E,f,p,a,c);break;case"bilinear":r=rO(C,h,d,b,v,x,E,f,p,a,c);break;default:throw new Error("Error in Transform: Expect 'nearest' or "+"'bilinear', but got ".concat(o))}N[E*k+t*S+n*I+a]=r}return a.makeTensorInfo(g,r.dtype,N)}return{dataId:a.write(N,g,r.dtype),shape:r.shape,dtype:r.dtype}}};function tO(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return Nt(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return Nt(0,n,t-1)}(e,t);case"nearest":return function(e,t){return Nt(0,e,t-1)}(e,t);default:return function(e,t){return e}(e)}}function nO(e,t,n,a,r,s,o,i,c,l,u){return 0<=i&&i<t&&0<=c&&c<n?e[o*a+i*r+c*s+l]:u}function aO(e,t,n,a,r,s,o,i,c,l,u){return nO(e,t,n,a,r,s,o,Math.round(i),Math.round(c),l,u)}function rO(e,t,n,a,r,s,o,i,c,l,u){const h=Math.floor(i),d=Math.floor(c),p=h+1,f=d+1;return(p-i)*((f-c)*nO(e,t,n,a,r,s,o,h,d,l,u)+(c-d)*nO(e,t,n,a,r,s,o,h,f,l,u))+(i-h)*((f-c)*nO(e,t,n,a,r,s,o,p,d,l,u)+(c-d)*nO(e,t,n,a,r,s,o,p,f,l,u))}function sO(e,t,n,a){const r=Bt(t,n)[0],s=[1,n[0],1];for(let f=0;f<r;f++)s[0]*=n[f];s[1]=n[r];for(let f=r+1;f<n.length;f++)s[2]*=n[f];const o={},i=new Int32Array(n[r]),c=new co(s,a,e),l=[],u=1===s[0]&&1===s[2];for(let f=0;f<n[r];f++){let t;if(u)t=e[f].toString();else{const e=[];for(let t=0;t<s[0];t++)for(let n=0;n<s[2];n++)e.push(c.get(t,f,n));t=e.join(",")}if(void 0!==o[t])i[f]=o[t];else{const e=Object.keys(o).length;o[t]=e,i[f]=e,l.push(f)}}const h=s.slice();h[1]=Object.keys(o).length;const d=new co(h,a);l.forEach(((e,t)=>{for(let n=0;n<s[0];n++)for(let a=0;a<s[2];a++)d.set(c.get(n,e,a),n,t,a)}));const p=n.slice();return p[r]=h[1],{outputValues:d.values,outputShape:p,indices:i}}const oO={kernelName:ds,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;UC(s,"unique");const o=a.data.get(s.dataId).values,{outputValues:i,outputShape:c,indices:l}=sO(o,r,s.shape,s.dtype);return[a.makeTensorInfo(c,s.dtype,i),a.makeTensorInfo([l.length],"int32",l)]}};const iO={kernelName:ps,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:s}=a;s<0&&(s+=r.shape.length);const o=r.shape.length,i=r.shape[s],c=new Array(o-1);let l=0;for(let p=0;p<o;p++)p!==s&&(c[l++]=r.shape[p]);const u=new Array(o).fill(0),h=r.shape.slice();h[s]=1;const d=new Array(i);for(let p=0;p<d.length;p++){u[s]=p;const e=uE({inputs:{x:r},backend:n,attrs:{begin:u,size:h}});d[p]=NT({inputs:{x:e},backend:n,attrs:{shape:c}}),n.disposeIntermediateTensorInfo(e)}return d}};const cO={kernelName:fs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:s}=t,{numSegments:o}=a;UC(r,"unsortedSegmentSum");const i=[],c=[],l=r.shape.length-s.shape.length;let u=s;for(let d=0;d<l;++d){const e=xR({inputs:{input:u},backend:n,attrs:{dim:d+1}});u=e,c.push(e)}for(let d=0;d<o;++d){const e=Ks(d,"int32"),t=n.makeTensorInfo([],"int32",e),a=iR({inputs:{a:t,b:u},backend:n}),s=yT({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),o=eR({inputs:{a:s,b:r},backend:n}),l=nR({inputs:{x:o},backend:n,attrs:{axis:0,keepDims:!1}});i.push(l),c.push(t),c.push(a),c.push(s),c.push(o),c.push(l)}const h=y_({inputs:i,backend:n,attrs:{axis:0}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}},lO=[RT,_T,OT,MT,IT,LT,WT,UT,VT,GT,HT,qT,YT,JT,eE,rE,sE,oE,iE,ET,cE,dE,mE,gE,bT,vE,wE,dT,kE,TE,RE,AE,_E,FE,OE,DE,LE,zE,BE,WE,UE,VE,GE,HE,KE,qE,XE,YE,ZE,QE,rR,qC,sR,cR,gR,vR,wR,IR,MR,PR,zR,UR,jR,HR,KR,XR,ZR,$R,nA,YC,aA,NE,sA,iA,lA,QC,dA,mA,yA,xA,kA,NA,TA,AA,_A,FA,MA,zA,BA,WA,UA,VA,GA,jA,HA,XA,YA,JA,t_,tR,a_,s_,i_,l_,d_,p_,g_,b_,v_,k_,tT,I_,R_,M_,P_,mT,TR,B_,aT,sT,CT,W_,U_,V_,G_,j_,H_,q_,Z_,J_,tF,nF,oF,lT,cF,uF,dF,hE,e_,mF,gF,bF,xF,kF,SF,IF,NF,EF,RF,FF,DF,LF,BF,VF,jF,_R,aR,KF,{kernelName:is,backendName:"cpu",kernelFunc:qF},YF,$F,eO,BT,oO,iO,cO,m_];for(const n of lO)Rs(n);const uO={},hO={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function dO(e,t){if(!(e in uO)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if("undefined"!==typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e):t;n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete uO[e]}),!1),hn().getBool("SOFTWARE_WEBGL_ENABLED")&&(hO.failIfMajorPerformanceCaveat=!1);if(1===e)return n.getContext("webgl",hO)||n.getContext("experimental-webgl",hO);return n.getContext("webgl2",hO)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;uO[e]=n}const n=uO[e];return null==n||n.isContextLost()?(delete uO[e],dO(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),uO[e])}var pO,fO,mO;function gO(e,t){return[t,e]}function yO(e){const t=Ft(e);return Mt(Math.ceil(t/4))}function bO(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function vO(e,t){const n=e;let a,r,s,o,i,c,l,u,h,d;return 2===hn().getNumber("WEBGL_VERSION")?(a=n.R32F,r=n.R16F,s=n.RGBA16F,o=n.RGBA32F,i=n.RED,l=4,u=1,h=n.HALF_FLOAT,d=n.FLOAT,c=n.RGBA8):(a=e.RGBA,r=e.RGBA,s=e.RGBA,o=n.RGBA,i=e.RGBA,l=4,u=4,h=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT,c=e.RGBA),{internalFormatFloat:a,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:i,downloadTextureFormat:c,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:d}}function xO(e,t){const n=t();return hn().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code ".concat(t)}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(pO||(pO={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(fO||(fO={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(mO||(mO={}));function wO(e){return!!(hn().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function kO(e,t){return _O(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}const SO=/ERROR: [0-9]+:([0-9]+):/g;function IO(e,t){const n=SO.exec(t);if(null==n)return console.log("Couldn't parse line number in error: ".concat(t)),void console.log(e);const a=+n[1],r=e.split("\n"),s=r.length.toString().length+2,o=r.map(((e,t)=>Lt((t+1).toString(),s)+e));let i=0;for(let h=0;h<o.length;h++)i=Math.max(o[h].length,i);const c=o.slice(0,a-1),l=o.slice(a-1,a),u=o.slice(a);console.log(c.join("\n")),console.log(t.split("\n")[0]),console.log("%c ".concat(Lt(l[0],i)),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join("\n"))}function NO(e,t){if(xO(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function CO(e,t,n,a,r,s,o){const i=e.getAttribLocation(t,n);return-1!==i&&(xO(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,a))),xO(e,(()=>e.vertexAttribPointer(i,r,e.FLOAT,!1,s,o))),xO(e,(()=>e.enableVertexAttribArray(i))),!0)}function TO(e,t,n,a){xO(e,(()=>function(e,t,n){FO(e,n),xO(e,(()=>e.activeTexture(e.TEXTURE0+n))),xO(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,a))),xO(e,(()=>e.uniform1i(n,a)))}function EO(e,t,n){xO(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),xO(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function RO(e,t){xO(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),xO(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function AO(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error ".concat(t)}}(e,t))}function _O(e,t,n){const a=xO(e,(()=>t()));if(null==a)throw new Error(n);return a}function FO(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=t+e.TEXTURE0;if(a<e.TEXTURE0||a>n){const e="[gl.TEXTURE0, gl.TEXTURE".concat(n,"]");throw new Error("textureUnit must be in ".concat(e,"."))}}function OO(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return Ft(e.slice(0,e.length-t))}function DO(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function MO(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[OO(e),...DO(e)]),t}function LO(e){return e%2===0}function PO(e,t){if(Ot(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],a=t.slice(-1)[0];if(n===a)return!0;if(LO(n)&&LO(a)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&LO(e[0])&&LO(t[0])}let zO,BO;function WO(e,t){return null!=e.getExtension(t)}function UO(e){try{if(null!=dO(e))return!0}catch(qV){return console.log("Error when getting WebGL context: ",qV),!1}return!1}function VO(e){if(0===e)return!1;const t=dO(e);if(1!==e){if(WO(t,"EXT_color_buffer_float"))return GO(t);const e="EXT_color_buffer_half_float";if(WO(t,e)){const n=t.getExtension(e);return function(e,t){const n=vO(e,t),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a);const r=1,s=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,r,s,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(o),i}(t,n)}return!1}if(!WO(t,"OES_texture_float"))return!1;if(!WO(t,"WEBGL_color_buffer_float"))return!1;return GO(t)}function GO(e){const t=vO(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),r}function jO(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Et("complex64"!==e.dtype,(()=>"".concat(t," does not support complex64 tensors ")+"in the WebGL backend."))}))}const HO=hn();function KO(){let e,t,n,a,r,s,o,i,c,l;return 2===hn().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",a="in",r="texture",s="outputColor",o="out vec4 outputColor;",i=hn().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",c="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",a="varying",r="texture2D",s="gl_FragColor",o="",i="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",c="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:a,texture2D:r,output:s,defineOutput:o,defineSpecialNaN:i,defineSpecialInf:c,defineRound:l}}function qO(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=Qt(t);return a.map(((t,r)=>{const s="int ".concat(e[r]," = ").concat(n," / ").concat(t),o=r===a.length-1?"int ".concat(e[r+1]," = ").concat(n," - ").concat(e[r]," * ").concat(t):"index -= ".concat(e[r]," * ").concat(t);return"".concat(s,"; ").concat(o,";")})).join("")}function XO(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=Qt(t);return a.map(((t,r)=>{const s="int ".concat(e[r]," = ").concat(n," / outShapeStrides[").concat(r,"]"),o=r===a.length-1?"int ".concat(e[r+1]," = ").concat(n," - ").concat(e[r]," * outShapeStrides[").concat(r,"]"):"index -= ".concat(e[r]," * outShapeStrides[").concat(r,"]");return"".concat(s,"; ").concat(o,";")})).join("")}function YO(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=function(e,t){const n=e.length,a=e.map((e=>"".concat(t,"[").concat(e,"]"))),r=new Array(n-1);r[n-2]=a[n-1];for(let s=n-3;s>=0;--s)r[s]="(".concat(r[s+1]," * ").concat(a[s+1],")");return r}(e.map(((e,t)=>t)),t);return a.map(((t,r)=>{const s="int ".concat(e[r]," = ").concat(n," / ").concat(a[r]),o=r===a.length-1?"int ".concat(e[r+1]," = ").concat(n," - ").concat(e[r]," * ").concat(a[r]):"index -= ".concat(e[r]," * ").concat(a[r]);return"".concat(s,"; ").concat(o,";")})).join("")}function ZO(e){const t=Qt(e).map((e=>e.toString()));return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(t[0]," + coords.y * ").concat(t[1]," + coords.z;\n  }\n")}HO.registerFlag("HAS_WEBGL",(()=>HO.getNumber("WEBGL_VERSION")>0)),HO.registerFlag("WEBGL_VERSION",(()=>UO(2)?2:UO(1)?1:0)),HO.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),HO.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===HO.get("WEBGL_VERSION"))),HO.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),HO.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),HO.registerFlag("WEBGL_PACK",(()=>HO.getBool("HAS_WEBGL"))),HO.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>HO.getBool("WEBGL_PACK"))),HO.registerFlag("WEBGL_PACK_CLIP",(()=>HO.getBool("WEBGL_PACK"))),HO.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>HO.getBool("WEBGL_PACK"))),HO.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>HO.getBool("WEBGL_PACK"))),HO.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>HO.getBool("WEBGL_PACK"))),HO.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>HO.getBool("WEBGL_PACK"))),HO.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>HO.getBool("WEBGL_PACK"))),HO.registerFlag("WEBGL_PACK_REDUCE",(()=>HO.getBool("WEBGL_PACK"))),HO.registerFlag("WEBGL_LAZILY_UNPACK",(()=>HO.getBool("WEBGL_PACK"))),HO.registerFlag("WEBGL_CONV_IM2COL",(()=>HO.getBool("WEBGL_PACK"))),HO.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==zO){const t=dO(e);zO=t.getParameter(t.MAX_TEXTURE_SIZE)}return zO}(HO.getNumber("WEBGL_VERSION")))),HO.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==BO){const t=dO(e);BO=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,BO)}(HO.getNumber("WEBGL_VERSION")))),HO.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=HO.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=dO(e);return t=WO(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:WO(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),HO.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>HO.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Mo())),HO.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=dO(e);if(1===e){if(!WO(t,"OES_texture_float"))return!1}else if(!WO(t,"EXT_color_buffer_float"))return!1;return GO(t)}(HO.getNumber("WEBGL_VERSION")))),HO.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!HO.getBool("WEBGL_FORCE_F16_TEXTURES")&&HO.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),HO.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>VO(HO.getNumber("WEBGL_VERSION")))),HO.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=HO.getNumber("WEBGL_VERSION"))&&null!=dO(e).fenceSync;var e})),HO.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>HO.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),HO.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if(e<0&&-1!==e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never "+"delete) or at least 0, but got ".concat(e,"."))})),HO.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>Mo()?1:-1),(e=>{if(e<0&&-1!==e)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never "+"manual flush) or at least 0, but got ".concat(e,"."))})),HO.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),HO.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),HO.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),HO.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),HO.registerFlag("WEBGL_EXP_CONV",(()=>!1)),HO.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>HO.getBool("IS_TEST"))),HO.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),HO.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),HO.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1));const QO="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:JO}=s;function $O(e,t,n){const a=[];if(e.forEach((e=>{const t=Ft(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?a.push("uniform float ".concat(e.name).concat(t>1?"[".concat(t,"]"):"",";")):(a.push("uniform sampler2D ".concat(e.name,";")),a.push("uniform int offset".concat(e.name,";"))),n.enableShapeUniforms){const{uniformShape:t}=lD(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:a.push("uniform int ".concat(e.name,"Shape;"));break;case 2:a.push("uniform ivec2 ".concat(e.name,"Shape;"));break;case 3:a.push("uniform ivec3 ".concat(e.name,"Shape;"));break;case 4:a.push("uniform ivec4 ".concat(e.name,"Shape;"))}a.push("uniform ivec2 ".concat(e.name,"TexShape;"))}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:a.push("uniform int outShape;");break;case 2:a.push("uniform ivec2 outShape;"),a.push("uniform int outShapeStrides;");break;case 3:a.push("uniform ivec3 outShape;"),a.push("uniform ivec2 outShapeStrides;");break;case 4:a.push("uniform ivec4 outShape;"),a.push("uniform ivec3 outShapeStrides;")}a.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{a.push("uniform ".concat(e.type," ").concat(e.name).concat(e.arrayIndex?"[".concat(e.arrayIndex,"]"):"",";"))}));const r=a.join("\n"),s=e.map((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3?arguments[3]:void 0,r="";r+=n?tD(e,a):eD(e,a);const s=e.shapeInfo.logicalShape,o=t.logicalShape;s.length<=o.length&&(r+=n?function(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",s=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,i=JO(e.shapeInfo.logicalShape,t.logicalShape),c=cD(o),l=o-s;let u;const h=["x","y","z","w","u","v"];u=0===s?"":o<2&&i.length>=1?"coords = 0;":i.map((e=>"coords.".concat(h[e+l]," = 0;"))).join("\n");let d="";d=o<2&&s>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>"coords.".concat(h[t+l]))).join(", ");let p="return outputValue;";const f=1===Ft(e.shapeInfo.logicalShape),m=Ft(t.logicalShape),g=1===m;if(1!==s||f||g){if(f&&!g)p=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(i.length){const e=s-2,t=s-1;i.indexOf(e)>-1&&i.indexOf(t)>-1?p="return vec4(outputValue.x);":i.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 ".concat(r,"() {\n      ").concat(c," coords = getOutputCoords();\n      ").concat(u,"\n      vec4 outputValue = get").concat(a,"(").concat(d,");\n      ").concat(p,"\n    }\n  ")}(e,t):function(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",s=t.texShape,o=e.shapeInfo.texShape,i=e.shapeInfo.logicalShape.length,c=t.logicalShape.length;if(!e.shapeInfo.isUniform&&i===c&&null==e.shapeInfo.flatOffset&&Ot(o,s))return"\n      float ".concat(r,"() {\n        return sampleTexture(").concat(n,", resultUV);\n      }\n    ");const l=cD(c),u=JO(e.shapeInfo.logicalShape,t.logicalShape),h=c-i;let d;const p=["x","y","z","w","u","v"];d=0===i?"":c<2&&u.length>=1?"coords = 0;":u.map((e=>"coords.".concat(p[e+h]," = 0;"))).join("\n");let f="";f=c<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>"coords.".concat(p[t+h]))).join(", ");return"\n    float ".concat(r,"() {\n      ").concat(l," coords = getOutputCoords();\n      ").concat(d,"\n      return get").concat(a,"(").concat(f,");\n    }\n  ")}(e,t));return r}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),o=t.texShape,i=KO(),c=function(e){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(e.texture2D,"(textureSampler, uv).r;\n    }\n  ")}(i);let l,u,h=function(e){const t="".concat(e.version,"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(e.varyingFs," vec2 resultUV;\n    ").concat(e.defineOutput,"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(e.defineSpecialNaN,"\n    ").concat(e.defineSpecialInf,"\n    ").concat(e.defineRound,"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(nD,"\n    ").concat(aD,"\n    ").concat(rD,"\n  ");return t}(i);t.isPacked?(l=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===a[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(a[1],".0);\n      }\n    ");if(1===a[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(a[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      return 2 * (resTexRC.x * ").concat(a[1]," + resTexRC.y);\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Ot(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(a[0],", ").concat(a[1],"));\n      }\n    ");const r=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),s=r*Math.ceil(e[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      int b = index / ").concat(s,";\n      index -= b * ").concat(s,";\n\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ")}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),s=r*Math.ceil(e[e.length-2]/2);let o=s,i="",c="b, r, c";for(let l=2;l<e.length-1;l++)o*=e[e.length-l-1],i="\n      int b".concat(l," = index / ").concat(o,";\n      index -= b").concat(l," * ").concat(o,";\n    ")+i,c="b".concat(l,", ")+c;return"\n    ivec".concat(e.length," getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      ").concat(i,"\n\n      int b = index / ").concat(s,";\n      index -= b * ").concat(s,";\n\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec").concat(e.length,"(").concat(c,");\n    }\n  ")}(e,t,n)}}(t.logicalShape,o,n.enableShapeUniforms),u=function(e){return"\n    void setOutput(vec4 val) {\n      ".concat(e.output," = val;\n    }\n  ")}(i)):(l=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(t[1],".0);\n      }\n    ");if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(t[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      return resTexRC.x * ").concat(t[1]," + resTexRC.y;\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){if(Ot(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(t[0],", ").concat(t[1],"));\n      }\n    ");if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ");if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ");if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      int r = index / ").concat(e[1],";\n      int c = index - r * ").concat(e[1],";\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n){const t=XO(["r","c","d"],e);return"\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(t,"\n    return ivec3(r, c, d);\n  }\n")}const a=qO(["r","c","d"],e);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(a,"\n      return ivec3(r, c, d);\n    }\n  ")}(e,t,n);case 4:return function(e,t,n){if(n){const t=XO(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(t,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}const a=qO(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(a,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}(e,t,n);case 5:return function(e,t){const n=qO(["r","c","d","d2","d3"],e);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(t[0],",\n                             ").concat(t[1],"));\n\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ")}(e,t);case 6:return function(e,t){const n=qO(["r","c","d","d2","d3","d4"],e);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ")}(e,t);default:throw new Error("".concat(e.length,"-D output sampling is not yet supported"))}}(t.logicalShape,o,n.enableShapeUniforms),u=function(e){return"\n    void setOutput(float val) {\n      ".concat(e.output," = vec4(val, 0, 0, 0);\n    }\n  ")}(i)),n.packedInputs&&(h+=sD);return[h,c,u,r,l,s,n.userCode].join("\n")}function eD(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"float ".concat(a,"() {return ").concat(n,";}");const[r,s]=e.shapeInfo.texShape;if(1===r&&1===s)return"\n      float ".concat(a,"() {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const o=oD(n);if(t)return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], ").concat(o,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");const[i,c]=e.shapeInfo.texShape;return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(i,", ").concat(c,", ").concat(o,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e,t);case 1:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int index) {\n        ").concat(iD(e),"\n      }\n    ");const r=e.shapeInfo.texShape,s=r[0],o=r[1];if(1===o&&1===s)return"\n      float ".concat(a,"(int index) {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const i=oD(n);if(1===o)return t?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / float(").concat(n,"TexShape[0]));\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / ").concat(s,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(1===s)return t?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / float(").concat(n,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / ").concat(o,".0, 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(t)return"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], index + ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");return"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(s,", ").concat(o,", index + ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape;if(null!=s&&Ot(n,s)){if(t)return"\n      float ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");const e=s[0],n=s[1];return"\n    float ".concat(r,"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(n,".0, ").concat(e,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}const{newShape:o,keptDims:i}=Wt(n),c=o;if(c.length<n.length){const n=uD(e,c),a=["row","col"];return"\n      ".concat(eD(n,t),"\n      float ").concat(r,"(int row, int col) {\n        return ").concat(r,"(").concat(hD(a,i),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(n[1],", 1)));\n        ").concat(iD(e),"\n      }\n    ");const l=s[0],u=s[1],h=oD(a);if(1===u)return t?"\n      float ".concat(r,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(a,"TexShape[0]));\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(l,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");if(1===l)return t?"\n      float ".concat(r,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(a,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(u,".0, 0.5);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");if(t)return"\n      float ".concat(r,"(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(a,"Shape[1] + col + ").concat(h,";\n        vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");return"\n  float ".concat(r,"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(n[1]," + col + ").concat(h,";\n    vec2 uv = uvFromFlat(").concat(l,", ").concat(u,", index);\n    return sampleTexture(").concat(a,", uv);\n  }\n")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=n[1]*n[2],o=n[2],{newShape:i,keptDims:c}=Wt(n),l=i;if(l.length<n.length){const n=uD(e,l),a=["row","col","depth"];return"\n        ".concat(eD(n,t),"\n        float ").concat(r,"(int row, int col, int depth) {\n          return ").concat(r,"(").concat(hD(a,c),");\n        }\n      ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(s,", ").concat(o,", 1)));\n        ").concat(iD(e),"\n      }\n    ");const u=e.shapeInfo.texShape,h=u[0],d=u[1],p=e.shapeInfo.flatOffset;if(d===s&&null==p)return t?"\n      float ".concat(r,"(int row, int col, int depth) {\n        int stride1 = ").concat(a,"Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n        float ".concat(r,"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(o,", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(d,".0, ").concat(h,".0);\n          return sampleTexture(").concat(a,", uv);\n        }\n      ");if(d===o&&null==p)return t?"\n      float ".concat(r,"(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(a,"Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(n[1],", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(d,".0, ").concat(h,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");const f=oD(a);if(t)return"\n    float ".concat(r,"(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(a,"Shape[1] * ").concat(a,"Shape[2];\n      int stride1 = ").concat(a,"Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n      return sampleTexture(").concat(a,", uv);\n    }\n    ");return"\n      float ".concat(r,"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(s," + col * ").concat(o," + depth + ").concat(f,";\n        vec2 uv = uvFromFlat(").concat(h,", ").concat(d,", index);\n        return sampleTexture(").concat(a,", uv);\n      }\n  ")}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=n[3],o=n[2]*s,i=n[1]*o,{newShape:c,keptDims:l}=Wt(n);if(c.length<n.length){const n=uD(e,c),a=["row","col","depth","depth2"];return"\n      ".concat(eD(n,t),"\n      float ").concat(r,"(int row, int col, int depth, int depth2) {\n        return ").concat(r,"(").concat(hD(a,l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(i,", ").concat(o,", ").concat(s,", 1)));\n        ").concat(iD(e),"\n      }\n    ");const u=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1],f="int stride2 = ".concat(a,"Shape[3];"),m="int stride1 = ".concat(a,"Shape[2] * stride2;"),g="int stride0 = ".concat(a,"Shape[1] * stride1;");if(p===i&&null==u)return t?"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        ").concat(f,"\n        ").concat(m,"\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(o,", ").concat(s,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");if(p===s&&null==u)return t?"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(a,"Shape[1] * ").concat(a,"Shape[2], ").concat(a,"Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(n[1]*n[2],", ").concat(n[2],", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");const y=oD(a);if(t)return"\n    float ".concat(r,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(f,"\n      ").concat(m,"\n      ").concat(g,"\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index + ").concat(y,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");return"\n    float ".concat(r,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(i," + col * ").concat(o," +\n          depth * ").concat(s," + depth2;\n      vec2 uv = uvFromFlat(").concat(d,", ").concat(p,", index + ").concat(y,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[4],s=t[3]*r,o=t[2]*s,i=t[1]*o,{newShape:c,keptDims:l}=Wt(t);if(c.length<t.length){const t=uD(e,c),n=["row","col","depth","depth2","depth3"];return"\n      ".concat(eD(t),"\n      float ").concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(a,"(").concat(hD(n,l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(i,", ").concat(o,", ").concat(s,", ").concat(r,")) +\n          depth3;\n        ").concat(iD(e),"\n      }\n    ");const u=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1];if(p===i&&null==u)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(o,", ").concat(s,", ").concat(r,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(p===r&&null==u)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3],",\n               ").concat(t[2]*t[3],", ").concat(t[3],", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const f=oD(n);return"\n    float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(i," + col * ").concat(o," + depth * ").concat(s," +\n          depth2 * ").concat(r," + depth3 + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(d,", ").concat(p,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:s}=Wt(t);if(r.length<t.length){const t=uD(e,r),n=["row","col","depth","depth2","depth3","depth4"];return"\n      ".concat(eD(t),"\n      float ").concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(a,"(").concat(hD(n,s),");\n      }\n    ")}const o=t[5],i=t[4]*o,c=t[3]*i,l=t[2]*c,u=t[1]*l;if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(u,", ").concat(l,", ").concat(c,", ").concat(i,")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(o,", 1)));\n        ").concat(iD(e),"\n      }\n    ");const h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];if(f===u&&null==h)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(l,", ").concat(c,", ").concat(i,", ").concat(o,")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(f===o&&null==h)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3]*t[4],",\n               ").concat(t[2]*t[3]*t[4],",\n               ").concat(t[3]*t[4],",\n               ").concat(t[4],")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const m=oD(n);return"\n    float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(u," + col * ").concat(l," + depth * ").concat(c," +\n          depth2 * ").concat(i," + depth3 * ").concat(o," + depth4 + ").concat(m,";\n      vec2 uv = uvFromFlat(").concat(p,", ").concat(f,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);default:throw new Error("".concat(n.length,"-D input sampling")+" is not yet supported")}}function tD(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),a=KO();return"\n    vec4 ".concat(n,"() {\n      return ").concat(a.texture2D,"(").concat(t,", halfCR);\n    }\n  ")}(e);case 1:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,s=KO();if(t)return"\n    vec4 ".concat(a,"(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(s.texture2D,"(").concat(n,", uv);\n    }\n  ");const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return"\n    vec4 ".concat(a,"(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(o[0],", ").concat(o[1],", index);\n      return ").concat(s.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape,o=s[0],i=s[1],c=KO();if(null!=s&&Ot(n,s))return t?"\n      vec4 ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n\n        return ").concat(c.texture2D,"(").concat(a,", uv);\n      }\n    "):"\n      vec4 ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(i,".0, ").concat(o,".0);\n\n        return ").concat(c.texture2D,"(").concat(a,", uv);\n      }\n    ");if(t)return"\n    vec4 ".concat(r,"(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(c.texture2D,"(").concat(a,", uv);\n    }\n  ");const l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],u=Math.ceil(n[1]/2);return"\n    vec4 ".concat(r,"(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(u,", ").concat(l[0],", ").concat(l[1],", row, col);\n      return ").concat(c.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){const a=[1,2],s=uD(e,n.slice(1)),o=["b","row","col"];return"\n        ".concat(tD(s,t),"\n        vec4 ").concat(r,"(int b, int row, int col) {\n          return ").concat(r,"(").concat(hD(o,a),");\n        }\n      ")}const i=KO();if(t)return"\n    vec4 ".concat(r,"(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(i.texture2D,"(").concat(a,", uv);\n    }\n  ");const c=o[0],l=o[1],u=Math.ceil(n[2]/2),h=u*Math.ceil(n[1]/2);return"\n    vec4 ".concat(r,"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(c,", ").concat(l,", ").concat(h,", ").concat(u,", b, row, col);\n      return ").concat(i.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);default:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=KO();if(t)return"\n    vec4 ".concat(a,"(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(n,"Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(n,"Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(n,"Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(r.texture2D,"(").concat(n,", uv);\n    }\n  ");const s=e.shapeInfo.logicalShape,o=s.length,i=e.shapeInfo.texShape,c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],l=c[0],u=c[1],h=Math.ceil(s[o-1]/2);let d=h*Math.ceil(s[o-2]/2),p="int b, int row, int col",f="b * ".concat(d," + (row / 2) * ").concat(h," + (col / 2)");for(let m=2;m<o-1;m++)p="int b".concat(m,", ")+p,d*=s[o-m-1],f="b".concat(m," * ").concat(d," + ")+f;return"\n    vec4 ".concat(a,"(").concat(p,") {\n      int index = ").concat(f,";\n      int texR = index / ").concat(u,";\n      int texC = index - texR * ").concat(u,";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(u,", ").concat(l,");\n      return ").concat(r.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t)}}const nD="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",aD="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",rD="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",sD="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function oD(e){return"offset".concat(e)}function iD(e){const t=e.name,n=Ft(e.shapeInfo.logicalShape);return n<2?"return ".concat(t,";"):"\n    for (int i = 0; i < ".concat(n,"; i++) {\n      if (i == index) {\n        return ").concat(t,"[i];\n      }\n    }\n  ")}function cD(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error("GPU for rank ".concat(e," is not yet supported"))}function lD(e,t,n){const{newShape:a,keptDims:r}=Wt(t),s=t.length,o=e&&3===s&&1===t[0],i=o?t.slice(1):a,c=!e&&s>1&&!Ot(t,n)&&a.length<s||o;return{useSqueezeShape:c,uniformShape:c?i:t,keptDims:r}}function uD(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function hD(e,t){return t.map((t=>e[t])).join(", ")}function dD(e,t,n,a){const r=n.map(((e,n)=>{const a={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(a.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:a}})),s=r.map((e=>e.shapeInfo)),o={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},i=$O(r,o,t),c=function(e,t){const n=_O(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(xO(e,(()=>e.shaderSource(n,t))),xO(e,(()=>e.compileShader(n))),hn().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw IO(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,i),l=e.createProgram(c);return hn().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:c,source:i,webGLProgram:l,inShapeInfos:s,outShapeInfo:o,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:c,source:i,webGLProgram:l,inShapeInfos:s,outShapeInfo:o},pD(e,t,l))}function pD(e,t,n){const a={},r={},s={},o=[];let i,c,l,u=null,h=null;h=e.getUniformLocation(n,"NAN",!1),1===hn().getNumber("WEBGL_VERSION")&&(u=e.getUniformLocation(n,"INFINITY",!1));const d=!1;for(let p=0;p<t.variableNames.length;p++){const o=t.variableNames[p];a[o]=e.getUniformLocation(n,o,d),a["offset".concat(o)]=e.getUniformLocation(n,"offset".concat(o),d),t.enableShapeUniforms&&(r["".concat(o,"Shape")]=e.getUniformLocation(n,"".concat(o,"Shape"),d),s["".concat(o,"TexShape")]=e.getUniformLocation(n,"".concat(o,"TexShape"),d))}return t.enableShapeUniforms&&(i=e.getUniformLocation(n,"outShape",d),l=e.getUniformLocation(n,"outShapeStrides",d),c=e.getUniformLocation(n,"outTexShape",d)),t.customUniforms&&t.customUniforms.forEach(((t,a)=>{o[a]=e.getUniformLocation(n,t.name,d)})),{uniformLocations:a,customUniformLocations:o,infLoc:u,nanLoc:h,inShapesLocations:r,inTexShapesLocations:s,outShapeLocation:i,outShapeStridesLocation:l,outTexShapeLocation:c}}function fD(e,t){if(e.length!==t.length)throw Error("Binary was compiled with ".concat(e.length," inputs, but ")+"was executed with ".concat(t.length," inputs"));e.forEach(((e,n)=>{const a=e.logicalShape,r=t[n],s=r.shape;if(!Ot(a,s))throw Error("Binary was compiled with different shapes than "+"the current args. Shapes ".concat(a," and ").concat(s," must match"));if(e.isUniform&&r.isUniform)return;const o=e.texShape,i=r.isUniform?null:r.texData.texShape;if(!Ot(o,i))throw Error("Binary was compiled with different texture shapes than the"+" current args. Shape ".concat(o," and ").concat(i," must match"))}))}function mD(e){return hn().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class gD{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=pO.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=KO();this.outputShape=e,this.enableShapeUniforms=mD(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?XO(["r","c","d"],e):qO(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class yD{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=pO.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=KO();this.outputShape=e,this.enableShapeUniforms=mD(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?XO(["r","c","d"],e):qO(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class bD{constructor(e){this.variableNames=["A"],this.outTexUsage=fO.DOWNLOAD;const t=KO();this.outputShape=e,this.userCode="\n      ".concat(QO,"\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}class vD{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=fO.DOWNLOAD;const t=KO();this.outputShape=e,this.userCode="\n      ".concat(QO,"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}class xD{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=KO();this.outputShape=e,this.enableShapeUniforms=mD(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)"),this.userCode="\n      ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":ZO(e),"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ").concat(n.texture2D,"(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ").concat(n.output," = vec4(").concat(a,", 0., 0., 0.);\n      }\n    ")}}class wD{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=KO();this.outputShape=e,this.enableShapeUniforms=mD(this.outputShape.length);let a="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let t=0;t<=1;t++){const r=2*s+t;a+="\n          localCoords = coords;\n          if(localCoords[2] + ".concat(t," < ").concat(this.enableShapeUniforms?"outShape[2]":"".concat(e[2]),") {\n          localCoords[2] += ").concat(t,";\n          if (localCoords[1] + ").concat(s," < ").concat(this.enableShapeUniforms?"outShape[1]":"".concat(e[1]),") {\n            localCoords[1] += ").concat(s,";\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ").concat(n.texture2D,"(A, uv);\n\n            if (offset == 0) {\n              result[").concat(r,"] = values[0];\n            } else if (offset == 1) {\n              result[").concat(r,"] = values[1];\n            } else if (offset == 2) {\n              result[").concat(r,"] = values[2];\n            } else {\n              result[").concat(r,"] = values[3];\n            }\n          }\n        }\n        ")}this.userCode="\n        ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":ZO(e),"\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ").concat(a,"\n\n          ").concat(n.output," = ").concat(r,";\n        }\n    ")}}function kD(e){const t=KO();return function(e,t){const n=_O(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(xO(e,(()=>e.shaderSource(n,t))),xO(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,"".concat(t.version,"\n    precision highp float;\n    ").concat(t.attribute," vec3 clipSpacePos;\n    ").concat(t.attribute," vec2 uv;\n    ").concat(t.varyingVs," vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"))}function SD(e){return function(e,t){const n=_O(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return xO(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),xO(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function ID(e){return function(e,t){const n=_O(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return xO(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),xO(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}function ND(e,t,n,a,r,s){!function(e,t){const n=hn().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const n="[".concat(e,"x").concat(t,"]");throw new Error("Requested texture size "+n+" is invalid.")}if(e>n||t>n){const a="[".concat(e,"x").concat(t,"]"),r="[".concat(n,"x").concat(n,"]");throw new Error("Requested texture size "+a+" greater than WebGL maximum on this browser / GPU "+r+".")}}(t,n);const o=function(e){return _O(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),i=e.TEXTURE_2D;return xO(e,(()=>e.bindTexture(i,o))),xO(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),xO(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),xO(e,(()=>e.texParameteri(i,e.TEXTURE_MIN_FILTER,e.NEAREST))),xO(e,(()=>e.texParameteri(i,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===hn().getNumber("WEBGL_VERSION")?xO(e,(()=>e.texImage2D(i,0,a,t,n,0,r,s,null))):xO(e,(()=>e.texStorage2D(i,1,a,t,n))),xO(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:o,texShape:[n,t]}}function CD(e){return e.internalFormatFloat}function TD(e){return e.internalFormatHalfFloat}function ED(e){return e.downloadTextureFormat}function RD(e){return e.internalFormatPackedFloat}function AD(e){return e.internalFormatPackedHalfFloat}function _D(e,t,n,a,r,s,o,i){const c=e,l=new Float32Array(function(e,t){const[n,a]=bO(e,t);return n*a*4}(s,o));return c.bindBuffer(c.PIXEL_PACK_BUFFER,t),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,l),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),l}class FD{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=hn().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,function(e,t){uO[e]=t}(t,e)):this.gl=dO(t);let n="WEBGL_color_buffer_float";const a="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===hn().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=kO(this.gl,e),WO(this.gl,t))this.textureHalfFloatExtension=kO(this.gl,t);else if(hn().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),WO(this.gl,a))this.colorBufferHalfFloatExtension=kO(this.gl,a);else if(hn().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",WO(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!WO(this.gl,a))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(a)}this.vertexBuffer=SD(this.gl),this.indexBuffer=ID(this.gl),this.framebuffer=function(e){return _O(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=vO(this.gl,this.textureHalfFloatExtension)}get debug(){return hn().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;xO(e,(()=>e.finish())),xO(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),xO(e,(()=>e.deleteFramebuffer(this.framebuffer))),xO(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),xO(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),xO(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,s]=gO(t,n);return ND(e,r,s,CD(a),a.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,s]=gO(t,n);return ND(e,r,s,TD(a),a.textureFormatFloat,a.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,s]=gO(t,n);return ND(e,r,s,ED(a),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){xO(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===hn().getNumber("WEBGL_VERSION")?xO(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):xO(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===hn().getNumber("WEBGL_VERSION")?xO(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):xO(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),xO(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,a){this.throwIfDisposed(),function(e,t,n,a,r,s){let o,i,c;xO(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),r instanceof Uint8Array?(o=new Uint8Array(n*a*4),i=e.UNSIGNED_BYTE,c=e.RGBA):(o=new Float32Array(n*a*4),i=e.FLOAT,c=s.internalFormatPackedFloat),o.set(r),2===hn().getNumber("WEBGL_VERSION")?xO(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,a,e.RGBA,i,o))):xO(e,(()=>e.texImage2D(e.TEXTURE_2D,0,c,n,a,0,e.RGBA,i,o))),xO(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,a,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,s]=bO(t,n);return ND(e,r,s,AD(a),e.RGBA,a.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,s]=bO(t,n);return ND(e,r,s,RD(a),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(RO(this.gl,this.framebuffer),this.outputTexture=null),xO(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,a){const[r,s]=gO(t,n),o=new Uint8Array(t*n*4);return xO(e,(()=>e.readPixels(0,0,r,s,a.downloadTextureFormat,e.UNSIGNED_BYTE,o))),new Float32Array(o.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,a,r,s){return _D(this.gl,e,0,0,0,r,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const a=e,r=new Float32Array(n);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,r),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),r}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const a=function(e,t,n,a){const r=e.createBuffer();xO(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r)));const s=16*t*n;return xO(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ))),xO(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),xO(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),r}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(hn().getBool("WEBGL_FENCE_API_ENABLED")){const a=e,r=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=a.clientWaitSync(r,0,0);return e===a.ALREADY_SIGNALED||e===a.CONDITION_SATISFIED},t=r}else hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const a=new Float32Array(t*n*4);return xO(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,a))),a}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=kD(t));const n=function(e){return _O(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);return xO(t,(()=>t.attachShader(n,this.vertexShader))),xO(t,(()=>t.attachShader(n,e))),function(e,t){if(xO(e,(()=>e.linkProgram(t))),!hn().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n),this.debug&&NO(t,n),this.vertexAttrsAreBound||(this.setProgram(n),this.vertexAttrsAreBound=function(e,t,n){return xO(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),CO(e,t,"clipSpacePos",n,3,20,0)&&CO(e,t,"uv",n,2,20,12)}(t,this.program,this.vertexBuffer)),n}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&xO(this.gl,(()=>this.gl.deleteProgram(e)))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&NO(this.gl,this.program),xO(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(e,t,n){return _O(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),xO(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),TO(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[a,r]=bO(t,n);this.setOutputMatrixTextureDriver(e,a,r)}setOutputMatrixWriteRegion(e,t,n,a){this.setOutputMatrixWriteRegionDriver(n,e,a,t)}setOutputPackedMatrixWriteRegion(e,t,n,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&NO(this.gl,this.program),AO(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),xO(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),xO(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=kO(this.gl,2===hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Pt((()=>this.disposed||this.isQueryAvailable(e,hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),a=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),a&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in hn().platform&&(n=hn().platform.setTimeoutCustom.bind(hn().platform)),Pt((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),EO(this.gl,e,this.framebuffer),this.debug&&AO(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(EO(this.gl,this.outputTexture,this.framebuffer),this.debug&&AO(this.gl)):RO(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const a=this.gl;EO(a,e,this.framebuffer),this.debug&&AO(a),this.outputTexture=e,xO(a,(()=>a.viewport(0,0,t,n))),xO(a,(()=>a.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,a){this.throwIfDisposed(),xO(this.gl,(()=>this.gl.scissor(e,t,n,a)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:OD,bincountImpl:DD,bincountReduceImpl:MD,castImpl:LD,ceilImpl:PD,concatImpl:zD,equalImpl:BD,expImpl:WD,expm1Impl:UD,floorImpl:VD,gatherNdImpl:GD,gatherV2Impl:jD,greaterImpl:HD,greaterEqualImpl:KD,lessImpl:qD,lessEqualImpl:XD,linSpaceImpl:YD,logImpl:ZD,maxImpl:QD,maximumImpl:JD,minimumImpl:$D,multiplyImpl:eM,negImpl:tM,notEqualImpl:nM,prodImpl:aM,raggedGatherImpl:rM,raggedTensorToTensorImpl:sM,rangeImpl:oM,rsqrtImpl:iM,scatterImpl:cM,sigmoidImpl:lM,simpleAbsImpl:uM,sliceImpl:hM,sparseFillEmptyRowsImpl:dM,sparseReshapeImpl:pM,sparseSegmentReductionImpl:fM,sqrtImpl:mM,stridedSliceImpl:gM,stringNGramsImpl:yM,stringSplitImpl:bM,stringToHashBucketFastImpl:vM,subImpl:xM,tileImpl:wM,topKImpl:kM,transposeImpl:SM,uniqueImpl:IM}=C;function NM(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>"".concat(e,".").concat(t)))}function CM(e,t){return 1===t?[e]:NM(e,t)}class TM{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=mD(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=CM("rc",this.rank),t=cD(this.rank),n=this.getOutOfBoundsCondition(e),a=this.getSetup(e),r=this.getOutput(e);this.userCode="\n        void main() {\n          ".concat(t," rc = getOutputCoords();\n\n          if(").concat(n,") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(a,"\n\n            setOutput(vec4(").concat(r,"));\n          }\n        }\n      ")}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let a=0;a<=1;a++){let r="".concat(0===n?"r":"rp1",", ").concat(0===a?"c":"cp1");for(let t=2;t<this.rank;t++)r="".concat(e[e.length-1-t],",")+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return"rc > ".concat(this.enableShapeUniforms?"outShape":this.outputShape[0]);let t="";for(let n=this.rank-2;n<this.rank;n++)t+="".concat(e[n]," >= ").concat(this.enableShapeUniforms?"outShape[".concat(n,"]"):this.outputShape[n]),n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?"outShape[".concat(this.rank," - 1]"):this.outputShape[this.rank-1],a=this.enableShapeUniforms?"outShape[".concat(this.rank," - 2]"):this.outputShape[this.rank-2];return"\n      int r = ".concat(t[0],";\n      int c = ").concat(t[1],";\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ").concat(n,";\n      bool rEdge = rp1 >= ").concat(a,";\n    ")}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){const e=this.enableShapeUniforms?"outShape":this.outputShape[0];return"getA(rc), (rc + 1 >= ".concat(e," ? 0. : getA(rc + 1)), 0, 0")}return"getA(".concat(t[0],"),\n            cEdge ? 0. : getA(").concat(t[1],"),\n            rEdge ? 0. : getA(").concat(t[2],"),\n            rEdge || cEdge ? 0. : getA(").concat(t[3],")")}}class EM{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=mD(this.outputShape.length);let n="";for(let a=0;a<4;a++){let e="thisRC = rc;";a%2===1&&(e+="thisRC.z += 1;"),a>1&&(e+="thisRC.y += 1;"),n+="\n        ".concat(e,"\n        ").concat(a>0?"if(thisRC.y < rows && thisRC.z < cols){":"","\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(a,"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(a>0?"}":"","\n      ")}this.userCode="\n      ".concat(function(e,t){const n=t?YO(["r","c","d"],"inputShape"):qO(["r","c","d"],e);return"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(n,"\n      return ivec3(r, c, d);\n    }\n  ")}(t,this.enableShapeUniforms),"\n      ").concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":ZO(e),"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(this.enableShapeUniforms?"outShape[1]":e[1],";\n        int cols = ").concat(this.enableShapeUniforms?"outShape[2]":e[2],";\n\n        ").concat(n,"\n\n        setOutput(result);\n      }\n    ")}}class RM{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const a=_M(t,n),r=FM(e,a,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const s=AM(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();const e=this.freeTextures[r].shift();return this.usedTextures[r].push(e),e}let o;return a===mO.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===mO.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===mO.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===mO.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===mO.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(o),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),o}releaseTexture(e,t,n,a){if(null==this.freeTextures)return;const r=_M(n,a),s=FM(t,r,a);s in this.freeTextures||(this.freeTextures[s]=[]);const o=AM(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,a),i=hn().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==i&&this._numBytesAllocated>i?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=o):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const c=this.usedTextures[s],l=c.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c.splice(l,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used","".concat(this.numFreeTextures," / ").concat(this.numUsedTextures),"(".concat(e,")"));const t=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: ".concat(this._numBytesAllocated)),console.log("Bytes unused: ".concat(this._numBytesFree," (").concat(Math.round(100*t),"%)"))}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function AM(e,t,n,a,r){const s=function(e,t){switch(e){case mO.PACKED_2X2_FLOAT32:return RD(t);case mO.PACKED_2X2_FLOAT16:return AD(t);case mO.UNPACKED_FLOAT32:return CD(t);case mO.UNPACKED_FLOAT16:return TD(t);case mO.PACKED_4X1_UNSIGNED_BYTE:return ED(t);default:throw new Error("Unknown physical texture type ".concat(e))}}(t,a);let o;if(r){const[t,n]=bO(e[0],e[1]);o=t*n}else{const[t,n]=gO(e[0],e[1]);o=t*n}const i=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error("Unknown internal format ".concat(t))}(n,s);return o*i}function _M(e,t){if(e===fO.UPLOAD)return mO.PACKED_2X2_FLOAT32;if(e===fO.RENDER||null==e)return function(e){return hn().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?mO.PACKED_2X2_FLOAT32:mO.UNPACKED_FLOAT32:e?mO.PACKED_2X2_FLOAT16:mO.UNPACKED_FLOAT16}(t);if(e===fO.DOWNLOAD||e===fO.PIXELS)return mO.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type ".concat(e))}function FM(e,t,n){return"".concat(e[0],"_").concat(e[1],"_").concat(t,"_").concat(n)}class OM{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=mD(this.outputShape.length),this.userCode="\n      float unaryOperation(float x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}const DM="if (isnan(x)) return x;",MM="return x;",LM="return abs(x);";const PM="return (x >= 0.0) ? x : (exp(x) - 1.0);",zM=DM+"\n  return (x < 0.0) ? 0.0 : x;\n",BM=DM+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",WM="return x;",UM="return 1.0 / (1.0 + exp(-1.0 * x));",VM="return x;",GM="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",jM="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",HM="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",KM="return 1.0 / (1.0 + exp(-1.0 * x));";class qM{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=mD(this.outputShape.length),this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}class XM{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=mD(this.outputShape.length);const t=e.length,n=CM("rc",t),a=cD(t),r=function(e,t){if(1===e)return"rc";let n="";for(let a=0;a<e;a++)n+=t[a],a<e-1&&(n+=",");return n}(t,n),s=n.slice(-2),o=t<=1?"rc":"vec2(".concat(s.join(","),")");this.userCode="\n      void main() {\n        ".concat(a," rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(r,");\n\n        setOutput(getChannel(packedInput, ").concat(o,"));\n      }\n    ")}}const YM=$d,ZM={};const QM=hn().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class JM extends kt{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!hn().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof FD)t=e;else{const n=dO(hn().getNumber("WEBGL_VERSION"),e);t=new FD(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=dO(hn().getNumber("WEBGL_VERSION"));t=new FD(e),this.binaryCache=((n=hn().getNumber("WEBGL_VERSION"))in ZM||(ZM[n]={}),ZM[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new RM(this.gpgpu),this.numMBBeforeWarning=null==hn().global.screen?1024:hn().global.screen.height*hn().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new wt(this,Kc())}nextDataId(){return JM.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if((hn().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||hn().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const a={id:this.nextDataId()};return this.texData.set(a,{shape:t,dtype:n,values:e,usage:fO.UPLOAD,refCount:1}),a}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,a,r){if(hn().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:a,values:t,usage:fO.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:a,complexTensorInfos:r,slice:s,shape:o,isPacked:i}=t;if(null!=s){let t;t=i?new qM(o,WM):new OM(o,WM);const n=this.runWebGLProgram(t,[{dataId:e,shape:o,dtype:a}],a),r=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===a)return n;const c=null!=this.activeTimers;let l,u;if(c&&(l=Xs()),"complex64"===a){u=cm(this.readSync(r.real.dataId),this.readSync(r.imag.dataId))}else u=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=Xs()-l),this.convertAndCacheOnCPU(e,u)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:a,slice:r,dtype:s,complexTensorInfos:o,isPacked:i}=t;if(null!=r){let t;t=i?new qM(a,WM):new OM(a,WM);const n=this.runWebGLProgram(t,[{dataId:e,shape:a,dtype:s}],s),r=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if(hn().getBool("DEBUG")&&!hn().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===hn().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c,l,u=null;if("complex64"!==s&&hn().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const t=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(t.texture.texture,...yO(a))}if(this.pendingRead.set(e,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){const e=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]);l=cm(e[0],e[1])}else if(null==u)l=this.getValuesFromTexture(e);else{const e=Ft(a);l=this.gpgpu.downloadFloat32MatrixFromBuffer(u,e)}if(null!=c&&this.disposeIntermediateTensorInfo(c),null!=u){const e=this.gpgpu.gl;xO(e,(()=>e.deleteBuffer(u)))}const h=this.convertAndCacheOnCPU(e,l),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach((e=>e(h))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Kc().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(e),{values:a,shape:r,slice:s,dtype:o,isPacked:i,texture:c}=n;if("complex64"===o)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=i?new qM(r,WM):new OM(r,WM);const a=this.runWebGLProgram(n,[{dataId:e,shape:r,dtype:o}],o),s=this.readToGPU(a,t);return this.disposeIntermediateTensorInfo(a),s}if(null==c)throw null!=a?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const l=this.decode(e,t.customTexShape),u=Kc().makeTensorFromTensorInfo(l),h=this.texData.get(l.dataId);return Object.assign({tensorRef:u},h.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>Zs(e)));return qi(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return qi(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!wO(n)){if(hn().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value ".concat(n," cannot be represented with your ")+"current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value ".concat(n," cannot be represented on this device."))}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:a}=this.texData.get(e),r=Ft(t);if(hn().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),a=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(a.texture.texture,...yO(t)).subarray(0,r);return this.disposeIntermediateTensorInfo(n),s}const s=hn().getBool("WEBGL_PACK")&&!0===a,o=s?MO(t):t,i=s?new vD(o):new bD(o),c=this.runWebGLProgram(i,[{shape:o,dtype:n,dataId:e}],"float32"),l=this.texData.get(c.dataId),u=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(c),u}timerAvailable(){return hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let a=!1;null==this.programTimersStack?(this.programTimersStack=n,a=!0):this.activeTimers.push(n),this.activeTimers=n,e();const r=_t(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=_t(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,a&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(r);o.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),o.getExtraProfileInfo=()=>e.map(((e,t)=>({name:s[t],ms:e}))).map((e=>"".concat(e.name,": ").concat(e.ms))).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Xs(),endMs:null}}endTimer(e){return hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Xs(),e)}async getQueryTime(e){if(hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:a,usage:r,isPacked:s,slice:o}=this.texData.get(e),i=o&&o.origDataId||e,c=this.dataRefCount.get(i);c>1?this.dataRefCount.set(i,c-1):(this.dataRefCount.delete(i),null!=t&&(this.numBytesInGPU-=this.computeBytes(a,n),this.textureManager.releaseTexture(t,a,r,s)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:QM;return hn().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&Ft(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){ks("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return YM(e.shape,t)}packedUnaryOp(e,t,n){const a=new qM(e.shape,t),r=this.compileAndRun(a,[e],n);return Kc().makeTensorFromTensorInfo(r)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=uM(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(hn().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,LM,e.dtype);const t=new OM(e.shape,LM),n=this.compileAndRun(t,[e]);return Kc().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&Kt(n[0])){const r=n.map((e=>Ys(e)));a=this.write(r,e,t)}else a=this.write(n,e,t);return this.texData.get(a).usage=null,{dataId:a,shape:e,dtype:t}}makeOutput(e,t,n){return Kc().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new XM(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new TM(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[OO(e.shape),...DO(e.shape)],a={dtype:e.dtype,shape:n,dataId:e.dataId},r=[OO(t),...DO(t)],s=new EM(r,n),o=[n],i=this.runWebGLProgram(s,[a],e.dtype,o,!0);return{dataId:i.dataId,shape:t,dtype:i.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:a,shape:r,dtype:s}=n;if(null!=t){Et(Ft(r)<=t[0]*t[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const o=MO(r);let i;i=a?new yD(o):new gD(o);const c=[null!=t?t:yO(o)];return{dtype:s,shape:r,dataId:this.runWebGLProgram(i,[{shape:o,dtype:s,dataId:e}],s,c,!0,t).dataId}}runWebGLProgram(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5?arguments[5]:void 0;const o=this.makeTensorInfo(e.outputShape,n),i=this.texData.get(o.dataId);if(e.packedOutput&&(i.isPacked=!0),e.outPackingScheme===pO.DENSE){const t=null!=s?s:yO(e.outputShape);i.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(i.usage=e.outTexUsage),0===Ft(o.shape))return i.values=Ut(o.dtype,0),o;const c=[],l=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Ft(t.shape)<=hn().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),c.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!PO(n.shape,t.shape)){const e=t,a=t.shape;t.shape=n.shape,t=this.packedReshape(t,a),c.push(t),n=this.texData.get(t.dataId),e.shape=a}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(o.dataId);const u={shape:o.shape,texData:i,isUniform:!1},h=function(e,t,n){let a="";t.concat(n).forEach((t=>{const r=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const s=t.texData.texShape,{useSqueezeShape:o,uniformShape:i,keptDims:c}=lD(e.packedInputs,t.shape,s);let l="",u="",h="";if(1===i.length&&e.packedInputs){const e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];l="".concat(e[0]>1,"_").concat(e[1]>1)}else if(2!==i.length||e.packedInputs){if(i.length>2&&!e.packedInputs){const e=Qt(i);h="".concat(e[0]===s[1],"_").concat(e[e.length-1]===s[1])}}else u="".concat(i[0]>1,"_").concat(i[1]>1);const d=t.shape.length,p=2===i.length&&Ot(t.shape,s),f=1===Ft(t.shape),m=yc(t.shape,n.shape),g=!e.packedInputs&&d===n.shape.length&&Ot(s,n.texData.texShape),y=e.packedInputs||i.length>2?"":"".concat(s[0]>1,"_").concat(s[1]>1);a+="".concat(d,"_").concat(g,"_").concat(o?c:"","_").concat(i.length,"_").concat(f,"_").concat(m,"_").concat(p,"_").concat(l,"_").concat(u,"_").concat(h,"_").concat(y,"_").concat(r)}else{const e=t.isUniform?"uniform":t.texData.texShape;a+="".concat(t.shape,"_").concat(e,"_").concat(r)}}));const r=e.userCode;let s=e.constructor.name;return s+="_"+a+"_"+r+"".concat(hn().getNumber("WEBGL_VERSION")),s}(e,l,u),d=this.getAndSaveBinary(h,(()=>dD(this.gpgpu,e,l,u))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),hn().get("ENGINE_COMPILE_ONLY")||function(e,t,n,a,r){t.program.enableShapeUniforms||(fD(t.inShapeInfos,n),fD([t.outShapeInfo],[a]));const s=a.texData.texture,o=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,o[0],o[1]):e.setOutputMatrixTexture(s.texture,o[0],o[1]),e.setProgram(t.webGLProgram),1===hn().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach(((n,a)=>{const r=t.program.variableNames[a],s=t.uniformLocations[r],o=t.uniformLocations["offset".concat(r)],i=t.inShapesLocations["".concat(r,"Shape")],c=t.inTexShapesLocations["".concat(r,"TexShape")];if(i){const{uniformShape:a}=lD(t.program.packedInputs,n.shape,n.texData.texShape);switch(a.length){case 1:e.gl.uniform1iv(i,new Int32Array(a));break;case 2:e.gl.uniform2iv(i,new Int32Array(a));break;case 3:e.gl.uniform3iv(i,new Int32Array(a));break;case 4:e.gl.uniform4iv(i,new Int32Array(a))}}if(c&&e.gl.uniform2i(c,n.texData.texShape[0],n.texData.texShape[1]),null!=s)if(n.isUniform)if(Ft(n.shape)<2)e.gl.uniform1f(s,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}else null!=n.texData.slice&&null!=o&&e.gl.uniform1i(o,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture.texture,s,a)}));const i=t.outShapeLocation;if(i)switch(a.shape.length){case 1:e.gl.uniform1iv(i,new Int32Array(a.shape));break;case 2:e.gl.uniform2iv(i,new Int32Array(a.shape));break;case 3:e.gl.uniform3iv(i,new Int32Array(a.shape));break;case 4:e.gl.uniform4iv(i,new Int32Array(a.shape))}if(t.outShapeStridesLocation){const n=Qt(a.shape);switch(a.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,a.texData.texShape[0],a.texData.texShape[1]),t.program.customUniforms&&r&&t.program.customUniforms.forEach(((n,a)=>{const s=t.customUniformLocations[a],o=r[a];if("float"===n.type)e.gl.uniform1fv(s,o);else if("vec2"===n.type)e.gl.uniform2fv(s,o);else if("vec3"===n.type)e.gl.uniform3fv(s,o);else if("vec4"===n.type)e.gl.uniform4fv(s,o);else if("int"===n.type)e.gl.uniform1iv(s,o);else if("ivec2"===n.type)e.gl.uniform2iv(s,o);else if("ivec3"===n.type)e.gl.uniform3iv(s,o);else{if("ivec4"!==n.type)throw Error("uniform type ".concat(n.type," is not supported yet."));e.gl.uniform4iv(s,o)}})),e.executeProgram()}(this.gpgpu,d,l,u,a),c.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=hn().get("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=Xs();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!hn().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&!1===r){const e=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),e}return o}compileAndRun(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,a,r)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!hn().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Xc((()=>{if(!hn().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=hn().getBool("DEBUG");hn().set("DEBUG",!1);const t=this.abs(el(1e-8)).dataSync()[0];if(hn().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:a,values:r,texture:s,usage:o,isPacked:i}=t;if(null!=s)return;const c=null!=this.activeTimers;let l;c&&(l=Xs());let u=t.texShape;if(null==u&&(u=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=hn().getNumber("WEBGL_MAX_TEXTURE_SIZE"),a=hn().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(a===1/0&&hn().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(a=n/2),t&&(n*=2,a*=2,1===(e=e.map(((t,n)=>n>=e.length-2?Ct(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=Wt(e);e=t.newShape}let r=Ft(e),s=null;e.length<=1&&r<=n?s=[1,r]:2===e.length&&e[0]<=n&&e[1]<=n?s=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);const o=null!=s&&Math.max(...s)>a&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(null==s||o)if(t){const t=OO(e);let n=2,a=2;e.length&&([n,a]=DO(e)),r=t*(n/2)*(a/2),s=Mt(r).map((e=>2*e))}else s=Mt(r);return s}(n,i),t.texShape=u),null!=r){const e=MO(n);let s,o=u[1],h=u[0];const d=r instanceof Uint8Array||r instanceof Uint8ClampedArray;!i&&d||([o,h]=bO(u[0],u[1])),s=i?new wD(e,d):new xD(e,d);const p=d?[h,o]:u,f=this.makeTensorInfo(p,a),m=this.texData.get(f.dataId);m.usage=d?fO.PIXELS:fO.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),o,h,r);const g=[[h,o]],y=!0,b=this.runWebGLProgram(s,[f],a,g,y),v=this.texData.get(b.dataId);t.texShape=v.texShape,t.isPacked=v.isPacked,t.usage=v.usage,hn().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(t.texture=v.texture,t.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(f),c&&(this.uploadWaitMs+=Xs()-l)}else{const e=this.acquireTexture(u,o,a,i);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:a}=n;return this.releaseGPUData(e),null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error("Unknown dtype ".concat(t))}(t,a)),n.values}acquireTexture(e,t,n,a){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: ".concat(e," MB, ")+"most likely due to a memory leak")}return this.textureManager.acquireTexture(e,t,a)}computeBytes(e,t){return e[0]*e[1]*Ht(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Pf(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw IO(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:t,customUniformLocations:n,infLoc:a,nanLoc:r,inShapesLocations:s,inTexShapesLocations:o,outShapeLocation:i,outShapeStridesLocation:c,outTexShapeLocation:l}=pD(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=n,e.infLoc=a,e.nanLoc=r,e.inShapesLocations=s,e.inTexShapesLocations=o,e.outShapeLocation=i,e.outShapeStridesLocation=c,e.outTexShapeLocation=l}}}JM.nextDataId=0;Lo()&&Jc("webgl",(()=>new JM),2);const $M="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class eL{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=vc(t,n),this.enableShapeUniforms=mD(this.outputShape.length),this.userCode="\n      float binaryOperation(float a, float b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ")}}const tL="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class nL{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=vc(t,n);const r=this.outputShape.length;this.enableShapeUniforms=mD(r);let s="";if(a)if(0===r||1===Ft(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{const e=cD(r);if(s="\n          ".concat(e," coords = getOutputCoords();\n        "),1===r)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+="\n            result.y = (coords + 1) >= ".concat(this.outputShape[0]," ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");else{const e=CM("coords",r);this.enableShapeUniforms?s+="\n            bool nextRowOutOfBounds =\n              (".concat(e[r-2]," + 1) >= outShape[").concat(r," - 2];\n            bool nextColOutOfBounds =\n              (").concat(e[r-1]," + 1) >= outShape[").concat(r," - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "):s+="\n            bool nextRowOutOfBounds =\n              (".concat(e[r-2]," + 1) >= ").concat(this.outputShape[r-2],";\n            bool nextColOutOfBounds =\n              (").concat(e[r-1]," + 1) >= ").concat(this.outputShape[r-1],";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ")}}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(s,"\n\n        setOutput(result);\n      }\n    ")}}function aL(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const rL={kernelName:Ra,backendName:"webgl",kernelFunc:aL};function sL(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.makeTensorInfo(a.shape,"complex64"),o=n.texData.get(s.dataId),i=aL({inputs:{x:a},backend:n}),c=aL({inputs:{x:r},backend:n});return o.complexTensorInfos={real:i,imag:c},s}const oL={kernelName:Un,backendName:"webgl",kernelFunc:sL},iL="return (a < 0.) ? b * a : a;",cL="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const lL={kernelName:Ma,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:s}=a,o=n.makeTensorInfo([],"float32",Ks(s,"float32")),i=hn().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new nL(cL,r.shape,o.shape):new eL(iL,r.shape,o.shape),c=n.runWebGLProgram(i,[r,o],"float32");return n.disposeIntermediateTensorInfo(o),c}},uL="return (a < 0.) ? b * a : a;",hL="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const dL={kernelName:gr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t,s=hn().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new nL(hL,a.shape,r.shape):new eL(uL,a.shape,r.shape);return n.runWebGLProgram(s,[a,r],"float32")}},pL="if (isnan(x)) return x;";function fL(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:a,dtype:r}=e;return e=>{let{inputs:s,backend:o}=e;const{x:i}=s,c=o,l=r||i.dtype;if(c.shouldExecuteOnCPU([i])&&null!=a){const e=c.texData.get(i.dataId),t=a(e.values,l);return c.makeTensorInfo(i.shape,l,t)}let u;return u=hn().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new qM(i.shape,n):new OM(i.shape,t),c.runWebGLProgram(u,[i],l)}}function mL(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:a=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}=e;return e=>{let{inputs:i,backend:c}=e;const{a:l,b:u}=i,h=c;if(r&&"complex64"===l.dtype){const e=h.texData.get(l.dataId),n=h.texData.get(u.dataId),[a,r]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,a]=e,r={dataId:n.dataId,dtype:n.dtype,shape:l.shape},s={dataId:a.dataId,dtype:a.dtype,shape:u.shape},o=new eL(t,l.shape,u.shape);return h.runWebGLProgram(o,[r,s],ko(n.dtype,a.dtype))})),s=sL({inputs:{real:a,imag:r},backend:h});return h.disposeIntermediateTensorInfo(a),h.disposeIntermediateTensorInfo(r),s}const d=o||ko(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||h.shouldExecuteOnCPU([l,u]))&&null!=s){const e=h.texData.get(l.dataId).values,t=h.texData.get(u.dataId).values,n="string"===l.dtype?Vm(e):e,a="string"===l.dtype?Vm(t):t,[r,o]=s(l.shape,u.shape,n,a,d),i=h.makeTensorInfo(o,d);return h.texData.get(i.dataId).values=r,i}let p;return p=hn().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new nL(n,l.shape,u.shape,a):new eL(t,l.shape,u.shape),h.runWebGLProgram(p,[l,u],d)}}function gL(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return t?VM:MM;if("relu"===e)return t?jM:zM;if("elu"===e)return t?GM:PM;if("relu6"===e)return t?HM:BM;if("prelu"===e)return t?hL:uL;if("leakyrelu"===e)return t?cL:iL;if("sigmoid"===e)return t?KM:UM;throw new Error("Activation ".concat(e," has not been implemented for the WebGL backend."))}class yL{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=mD(this.outputShape.length);const l=a?e[1]:e[2],u=Math.ceil(l/2),h=a?"i * 2, rc.y":"rc.y, i * 2",d=r?"rc.z, i * 2":"i * 2, rc.z",p=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";o&&(m=i?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(o,"\n        }"):c?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(o,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(o,"\n        }"),g="result = activation(result);");const y=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let b="rc.x",v="rc.x";e[0]<t[0]?b="int(min(float(rc.x), ".concat(e[0]-1,".))"):t[0]<e[0]&&(v="int(min(float(rc.x), ".concat(t[0]-1,".))")),this.userCode="\n      ".concat(m,"\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ").concat(u,".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ").concat(u,"; i++) {\n          int batchA = ").concat(b,";\n          int batchB = ").concat(v,";\n          vec4 a = getMatrixA(batchA, ").concat(h,");\n          vec4 b = getMatrixB(batchB, ").concat(d,");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(p[0]," * ").concat(f[0],");\n          result += (").concat(p[1]," * ").concat(f[1],");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(y,"\n\n        ").concat(g,"\n\n        setOutput(result);\n      }\n    ")}}const bL={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class vL{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=vc(t,n),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ")}}const xL="return a * b;";function wL(e){const{inputs:t,backend:n}=e,{a:a,b:r}=t,s=ko(a.dtype,r.dtype);if("complex64"===a.dtype){const e=n.texData.get(a.dataId),t=n.texData.get(r.dataId),s=new vL(bL.REAL,a.shape,r.shape),o=new vL(bL.IMAG,a.shape,r.shape),i=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:r.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:r.shape}],c=n.runWebGLProgram(s,i,"float32"),l=n.runWebGLProgram(o,i,"float32"),u=sL({inputs:{real:c,imag:l},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),u}if(n.shouldExecuteOnCPU([a,r])){const e=n.texData.get(a.dataId),t=n.texData.get(r.dataId),[o,i]=eM(a.shape,r.shape,e.values,t.values,s),c=n.makeTensorInfo(i,s);return n.texData.get(c.dataId).values=o,c}let o;return o=hn().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new nL(xL,a.shape,r.shape):new eL(xL,a.shape,r.shape),n.runWebGLProgram(o,[a,r],s)}const kL={kernelName:sr,backendName:"webgl",kernelFunc:wL};function SL(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:s}=a,o=n,i=Ft(r.shape),c=zt(s,i),l=Ft(c);Et(i===l,(()=>"The new shape (".concat(c,") has ").concat(l," elements and the old ")+"shape (".concat(r.shape,") has ").concat(i," elements. The new shape and old ")+"shape must have the same number of elements."));const u=o.texData.get(r.dataId);return!u.isPacked||PO(r.shape,c)||null!==u.texture&&PO(u.shape,c)?(o.incRef(r.dataId),{dataId:r.dataId,shape:c,dtype:r.dtype}):function(e,t,n){const a=[OO(e.shape),...DO(e.shape)],r={dtype:e.dtype,shape:a,dataId:e.dataId},s=[OO(t),...DO(t)],o=new EM(s,a),i=[a],c=n.runWebGLProgram(o,[r],e.dtype,i,!0);return{dataId:c.dataId,shape:t,dtype:c.dtype}}(r,c,o)}const IL={kernelName:Ir,backendName:"webgl",kernelFunc:SL};class NL{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:r,outSize:s}=e;this.outputShape=[a,s];const o=4*Math.floor(n/4),i=n%4;let c="sumValue += dot(values, ones);";if(null!=t){const e=1/t;c="sumValue += dot(values * ".concat(Dt(e)?e.toPrecision(2):e,", ones);")}let l="";r%n>0&&(l="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return 0.0;\n        }\n      ")),this.userCode="\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(l,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(o,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(c,"\n        }\n\n        int inIdx = inOffset + ").concat(o,";\n        if (").concat(1===i,") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(c,"\n        } else if (").concat(2===i,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(c,"\n        } else if (").concat(3===i,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(c,"\n        }\n        setOutput(sumValue);\n      }\n    ")}}class CL{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:r,outSize:s}=e;this.outputShape=[a,s];let o="0.0",i="";"prod"===t?o="1.0":"min"===t?(o="1.0 / 1e-20",i="min"):"max"===t&&(o="-1.0 / 1e-20",i="max");let c="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===t?c="sumValue":"prod"===t?c="prodValue":"all"===t?c="allValue":"any"===t&&(c="anyValue");const l=4*Math.floor(n/4),u=n%4;let h="\n      if (".concat("sum"===t,") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod"===t,") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(i,"(values, minMaxValue);\n        if (").concat("min"===t," || ").concat("max"===t,") {\n          minMaxValue = ").concat(i,"(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    "),d="vec4";"all"===t?(o="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(o="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";r%n>0&&(p="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return initializationValue;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat(o,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(p,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        vec4 minMaxValue = vec4(").concat(o,");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(l,"; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(h,"\n        }\n\n        int inIdx = inOffset + ").concat(l,";\n        if (").concat(1===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h,"\n        } else if (").concat(2===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h,"\n        } else if (").concat(3===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(h,"\n        }\n        setOutput(").concat(c,");\n      }\n    ")}}function TL(e,t,n,a){const r=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],a=Kf(n);t.push({inSize:n,windowSize:a,outSize:Math.ceil(n/a)})}return t}(e.shape);let s=e;for(let o=0;o<r.length;o++){const{inSize:i,windowSize:c,outSize:l}=r[o];let u,h;u="mean"===n?0===o?new NL({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:l},i):new NL({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:l}):new CL({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:l},n),h=s,s=a.runWebGLProgram(u,[s],t),h.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(h)}return s}class EL{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;const a=cD(this.rank),r=function(e){const t=e.length;if(t>6)throw Error("Transpose for rank ".concat(t," is not yet supported"));const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=new Array(t);for(let r=0;r<e.length;r++)a[e[r]]=n[r];return a.join()}(t);this.userCode="\n    void main() {\n      ".concat(a," resRC = getOutputCoords();\n      setOutput(getA(").concat(r,"));\n    }\n    ")}}class RL{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let l=0;l<n.length;l++)n[l]=e[t[l]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank ".concat(this.rank," is not yet supported."));const a=cD(this.rank),r=NM("rc",this.rank),s=new Array(this.rank);for(let l=0;l<t.length;l++)s[t[l]]=r[l];const o="vec2(".concat(s.slice(-2).join(),")"),i="++".concat(r[this.rank-1]," < ").concat(n[this.rank-1]),c="getChannel(getA(".concat(s.join(),"), ").concat(o,")");this.userCode="\n    void main() {\n      ".concat(a," rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(c,";\n      if(").concat(i,") {\n        result[1] = ").concat(c,";\n      }\n      --").concat(r[this.rank-1],";\n      if(++").concat(r[this.rank-2]," < ").concat(n[this.rank-2],") {\n        result[2] = ").concat(c,";\n        if(").concat(i,") {\n          result[3] = ").concat(c,";\n        }\n      }\n      setOutput(result);\n    }\n    ")}}function AL(e,t,n){const a=hn().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new RL(e.shape,t):new EL(e.shape,t);return n.runWebGLProgram(a,[e],e.dtype)}function _L(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;return function(e,t,n,a){const r=t,s=e.shape.length,o=Bt(r,e.shape);let i=o;const c=Fu(i,s),l=null!=c;let u=e;l&&(u=AL(e,c,a),i=Du(i.length,s)),_u("sum",i,s);const[h,d]=Ru(u.shape,i);let p=h;n&&(p=Au(h,o));const f=Ft(d),m=SL({inputs:{x:u},attrs:{shape:[Ft(e.shape)/f,f]},backend:a}),g=TL(m,So(e.dtype),"sum",a),y=SL({inputs:{x:g},attrs:{shape:p},backend:a});return a.disposeIntermediateTensorInfo(m),a.disposeIntermediateTensorInfo(g),l&&a.disposeIntermediateTensorInfo(u),y}(r,s,o,n)}const FL={kernelName:jr,backendName:"webgl",kernelFunc:_L};function OL(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{perm:s}=a,o=n,i=r.shape.length,c=new Array(i);for(let u=0;u<c.length;u++)c[u]=r.shape[s[u]];let l;if(o.shouldExecuteOnCPU([r])){const e=o.texData.get(r.dataId).values,t=SM(e,r.shape,r.dtype,s,c);l=o.makeTensorInfo(c,r.dtype);o.texData.get(l.dataId).values=t}else l=AL(r,s,o);return l}const DL={kernelName:hs,backendName:"webgl",kernelFunc:OL},ML=1e3;function LL(e){let{a:t,b:n,transposeA:a,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:c=0,activation:l=null}=e;const u=t.shape.length,h=n.shape.length,d=a?t.shape[u-2]:t.shape[u-1],p=r?n.shape[h-1]:n.shape[h-2],f=a?t.shape[u-1]:t.shape[u-2],m=r?n.shape[h-2]:n.shape[h-1],g=t.shape.slice(0,-2),y=n.shape.slice(0,-2),b=Ft(g),v=Ft(y),x=vc(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);Et(d===p,(()=>"Error in matMul: inner shapes (".concat(d,") and (")+"".concat(p,") of Tensors with shapes ").concat(t.shape," and ")+"".concat(n.shape," and transposeA=").concat(a)+" and transposeB=".concat(r," must match.")));const w=a?[b,d,f]:[b,f,d],k=r?[v,m,p]:[v,p,m],S=SL({inputs:{x:t},backend:s,attrs:{shape:w}}),I=SL({inputs:{x:n},backend:s,attrs:{shape:k}}),N=[S,I],C=Math.max(b,v),T=a?S.shape[1]:S.shape[2],E=null!=o,R=null!=i,A="leakyrelu"===l,_=null!=l?gL(l,!0):null;let F;if((1===f||1===m)&&T>ML&&!1===(E||R||A||null!=_)){let e=S,t=I;a&&(e=OL({inputs:{x:S},backend:s,attrs:{perm:[0,2,1]}}),N.push(e)),r&&(t=OL({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),N.push(t));const n=1===m;let o=e;1!==m&&(o=SL({inputs:{x:e},backend:s,attrs:{shape:[C,T,1]}}),N.push(o));const i=1===m?2:1;let c=t;n&&(c=SL({inputs:{x:t},backend:s,attrs:{shape:[C,1,T]}}),N.push(c));const l=wL({inputs:{a:o,b:c},backend:s});F=_L({inputs:{x:l},backend:s,attrs:{axis:i,keepDims:!0}}),N.push(l)}else{const e=ko(t.dtype,n.dtype),l=new yL(w,k,[C,f,m],a,r,E,_,R,A),u=[S,I];if(null!=o&&u.push(o),R&&u.push(i),A){const e=s.makeTensorInfo([],"float32",Ks(c,"float32"));u.push(e),N.push(e)}F=s.runWebGLProgram(l,u,e)}const O=SL({inputs:{x:F},backend:s,attrs:{shape:x}});N.push(F);for(const D of N)s.disposeIntermediateTensorInfo(D);return O}const PL={kernelName:vs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:o,preluActivationWeights:i}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:h}=a;return LL({a:r,b:s,transposeA:c,transposeB:l,backend:n,bias:o,preluActivationWeights:i,leakyreluAlpha:h,activation:u})}},zL="return abs(x);";const BL={kernelName:gn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){const e=n.texData.get(a.dataId),t=uM(e.values);return n.makeTensorInfo(a.shape,a.dtype,t)}let r;return r=hn().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new qM(a.shape,zL):new OM(a.shape,zL),n.runWebGLProgram(r,[a],a.dtype)}},WL=fL({opSnippet:DM+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),UL={kernelName:yn,backendName:"webgl",kernelFunc:WL},VL=fL({opSnippet:DM+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),GL={kernelName:bn,backendName:"webgl",kernelFunc:VL},jL="return a + b;",HL=mL({opSnippet:jL,packedOpSnippet:jL,supportsComplex:!0,cpuKernelImpl:OD}),KL={kernelName:vn,backendName:"webgl",kernelFunc:HL};class qL{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>"T".concat(t)));const n=[];this.variableNames.forEach((e=>{n.push("float v".concat(e," = get").concat(e,"AtOutCoords();"))}));const a=this.variableNames.map((e=>"v".concat(e))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        float result = ").concat(a,";\n        setOutput(result);\n      }\n    ")}}class XL{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>"T".concat(t)));const n=[];this.variableNames.forEach((e=>{n.push("vec4 v".concat(e," = get").concat(e,"AtOutCoords();"))}));const a=this.variableNames.map((e=>"v".concat(e))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        vec4 result = ").concat(a,";\n        setOutput(result);\n      }\n    ")}}const YL={kernelName:xn,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,r=n;if(1===r.length)return aL({inputs:{x:r[0]},backend:a});if(r.length>hn().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(r.length/2),n=e({inputs:r.slice(0,t),backend:a}),s=e({inputs:r.slice(t),backend:a});return e({inputs:[n,s],backend:a})}const s=r.map((e=>e.dtype)).reduce(((e,t)=>ko(e,t))),o=r.map((e=>e.shape)),i=hn().getBool("WEBGL_PACK")?new XL(r[0].shape,o):new qL(r[0].shape,o);return a.runWebGLProgram(i,r,s)}};const ZL={kernelName:wn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a,i=r.shape.length,c=Bt(s,r.shape);let l=c;const u=Fu(l,i);let h=r;null!=u&&(h=OL({inputs:{x:r},backend:n,attrs:{perm:u}}),l=Du(l.length,i)),_u("all",l,i);const[d,p]=Ru(h.shape,l),f=SL({inputs:{x:h},backend:n,attrs:{shape:[-1,Ft(p)]}}),m=TL(f,f.dtype,"all",n);let g;if(o){g=SL({inputs:{x:m},backend:n,attrs:{shape:Au(d,c)}})}else g=SL({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(h),g}};const QL={kernelName:kn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a,i=r.shape.length,c=Bt(s,r.shape);let l=c;const u=Fu(l,i);let h=r;null!=u&&(h=OL({inputs:{x:r},backend:n,attrs:{perm:u}}),l=Du(l.length,i)),_u("any",l,i);const[d,p]=Ru(h.shape,l),f=SL({inputs:{x:h},backend:n,attrs:{shape:[-1,Ft(p)]}}),m=TL(f,f.dtype,"any",n);let g;if(o){g=SL({inputs:{x:m},backend:n,attrs:{shape:Au(d,c)}})}else g=SL({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(h),g}};class JL{constructor(e,t,n){this.variableNames=["A"];const{windowSize:a,batchSize:r,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,s];const o="max"===t?">":"<",i=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(a,";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          int inIdx = ").concat(i,";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat(o," bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ")}}class $L{constructor(e,t,n,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Et(e.length>2,(()=>"Packed arg".concat(n.charAt(0).toUpperCase()+n.slice(1)," supports only inputs with rank above 2.")));const r=e[e.length-1],s=Math.ceil(r/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),a||this.variableNames.push("bestIndicesA");const o=this.outputShape,i=o.length,c=cD(i),l=CM("coords",i);let u,h;if(1===s){h=i+1;const e=cD(h);u="\n        ".concat(e," sourceLocR = ").concat(e,"(").concat(l.join(),", 0);\n        ++").concat(l[i-1],";\n        ").concat(e," sourceLocG = ").concat(e,"(").concat(l.join(),", 0);\n        ++").concat(l[i-2],";\n        ").concat(e," sourceLocA = ").concat(e,"(").concat(l.join(),", 0);\n        --").concat(l[i-1],";\n        ").concat(e," sourceLocB = ").concat(e,"(").concat(l.join(),", 0);\n        --").concat(l[i-2],";")}else h=i,u="\n        ".concat(c," sourceLocR = coords;\n        ++").concat(l[i-1],";\n        ").concat(c," sourceLocG = coords;\n        ++").concat(l[i-2],";\n        ").concat(c," sourceLocA = coords;\n        --").concat(l[i-1],";\n        ").concat(c," sourceLocB = coords;\n        --").concat(l[i-2],";");const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map((e=>"int "+e)),m=CM("sourceLocR",h-1).concat("inIdx.r"),g=CM("sourceLocG",h-1).concat("inIdx.g"),y=CM("sourceLocB",h-1).concat("inIdx.b"),b=CM("sourceLocA",h-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",x=a?"":"\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(m.join(),"),\n                             getBestIndicesAChannel(").concat(g.join(),"),\n                             getBestIndicesAChannel(").concat(y.join(),"),\n                             getBestIndicesAChannel(").concat(b.join(),")));"),w="vec4(\n            getAChannel(".concat(m.join(),"),\n            hasNextCol ? getAChannel(").concat(g.join(),") : 0.,\n            hasNextRow ? getAChannel(").concat(y.join(),") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(b.join(),") : 0.)"),k=a?"":"\n      float getBestIndicesAChannel(".concat(f.join(),") {\n        return getChannel(getBestIndicesA(").concat(d.join(),"),\n                                          vec2(").concat(d.slice(-2).join(),"));\n      }");this.userCode="\n      float getAChannel(".concat(f.join(),") {\n        return getChannel(getA(").concat(d.join(),"),\n                               vec2(").concat(d.slice(-2).join(),"));\n      }\n      ").concat(k,"\n      void main() {\n        ").concat(c," coords = getOutputCoords();\n        bool hasNextCol = ").concat(l[i-1]," < ").concat(o[i-1]-1,";\n        bool hasNextRow = ").concat(l[i-2]," < ").concat(o[i-2]-1,";\n        ").concat(u,"\n        ivec4 srcIdx = ivec4(sourceLocR").concat(p,", sourceLocG").concat(p,",\n          sourceLocB").concat(p,", sourceLocA").concat(p,") * ").concat(t,";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(w,";\n\n        for (int i = 0; i < ").concat(t,"; i++) {\n          inIdx = srcIdx;\n          ").concat(x,"\n          vec4 candidate = ").concat(w,";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat(v,"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ")}}function eP(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=t.shape[0],s=t.shape[1];null!=a&&(r=a.shape[0],s=a.shape[1]);const o=Kf(s),i={windowSize:o,inSize:s,batchSize:r,outSize:Math.ceil(s/o)},c=new JL(i,n,null==a),l=[t];null!=a&&l.push(a);const u=e.runWebGLProgram(c,l,"int32");if(1===u.shape[1])return u;const h=eP(e,t,n,u);return e.disposeIntermediateTensorInfo(u),h}function tP(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const r=null!=a?a.shape:t.shape,s=Kf(r[r.length-1]),o=new $L(r,s,n,null==a),i=null==a?[t]:[t,a],c=e.runWebGLProgram(o,i,"int32");if(c.shape.length===t.shape.length){const a=tP(e,t,n,c);return e.disposeIntermediateTensorInfo(c),a}return c}function nP(e,t,n,a){const r=[n];if(_u("arg"+a.charAt(0).toUpperCase()+a.slice(1),r,t.shape.length),!hn().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],s=e.texData.get(t.dataId);let o=t;null!==s&&s.isPacked&&(o=e.unpackTensor(t),n.push(o));const[i,c]=Ru(o.shape,r),l=Ft(c),u=SL({inputs:{x:o},backend:e,attrs:{shape:[-1,l]}});n.push(u);const h=eP(e,u,a);n.push(h);const d=SL({inputs:{x:h},backend:e,attrs:{shape:i}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),d}return tP(e,t,a)}const aP={kernelName:Sn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;let o=Bt(s,r.shape);const i=Fu(o,r.shape.length);let c=r;const l=[];null!=i&&(c=OL({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),o=Du(o.length,c.shape.length)),_u("argMax",[o[0]],c.shape.length);const u=nP(n,c,o[0],"max");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}};const rP={kernelName:In,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;let o=Bt(s,r.shape);const i=Fu(o,r.shape.length);let c=r;const l=[];null!=i&&(c=OL({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),o=Du(o.length,c.shape.length)),_u("argMin",[o[0]],c.shape.length);const u=nP(n,c,o[0],"min");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}},sP=fL({opSnippet:DM+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),oP={kernelName:Nn,backendName:"webgl",kernelFunc:sP},iP=fL({opSnippet:DM+"return log(x + sqrt(x * x + 1.0));"}),cP={kernelName:Cn,backendName:"webgl",kernelFunc:iP},lP=fL({opSnippet:DM+"\n  return atan(x);\n"}),uP={kernelName:Tn,backendName:"webgl",kernelFunc:lP},hP=mL({opSnippet:$M+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+tL+"\n  return result;\n"}),dP={kernelName:Rn,backendName:"webgl",kernelFunc:hP},pP=fL({opSnippet:DM+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),fP={kernelName:En,backendName:"webgl",kernelFunc:pP};class mP{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,o=e.strideHeight,i=e.strideWidth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m="((batch  * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + d"),g="(xR * ".concat(e.inWidth," + xC) * ").concat(e.inChannels," + d");let y="0.0";if(f||(y="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec2 strides = ivec2(".concat(o,", ").concat(i,");\n        const ivec2 pads = ivec2(").concat(d,", ").concat(p,");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(u,";\n              wR += ").concat(c,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(h,";\n                wC += ").concat(l,") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ").concat(t," currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(a?r?m:g:"wR * ".concat(h," + wC"),";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let b="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(b="avgValue / count");const v=4*Math.floor(s/4),x=s%4,w="\n      if (".concat(f,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec2 strides = ivec2(".concat(o,", ").concat(i,");\n      const ivec2 pads = ivec2(").concat(d,", ").concat(p,");\n      const float initializationValue = ").concat(y,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(y,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(u,";\n            wR += ").concat(c,") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(v,"; wC += 4) {\n            int xC = xCCorner + wC * ").concat(l,";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              getValue(batch, xR, xC + 3 * ").concat(l,", d)\n            );\n\n            ").concat(w,"\n          }\n\n          int xC = xCCorner + ").concat(v,";\n          if (").concat(1===x,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(2===x,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(3===x,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              initializationValue\n            );\n\n            ").concat(w,"\n          }\n        }\n        setOutput(").concat(b,");\n      }\n    ")}}class gP{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,o=e.strideDepth,i=e.strideHeight,c=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let v="0.0";if(b||(v="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec3 strides =\n            ivec3(".concat(o,", ").concat(i,", ").concat(c,");\n        const ivec3 pads = ivec3(").concat(m,", ").concat(g,", ").concat(y,");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(d,";\n              wD += ").concat(l,") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(p,";\n                wR += ").concat(u,") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(f,";\n                  wC += ").concat(h,") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ").concat(t," currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(a?r?"(((batch * ".concat(e.inDepth," + xD) * ").concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"((xD * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"wD * ".concat(p," * ").concat(f," +\n                      wR * ").concat(f," + wC"),";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let x="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(x="avgValue / count");const w=4*Math.floor(s/4),k=s%4,S="\n      if (".concat(b,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec3 strides =\n        ivec3(".concat(o,", ").concat(i,", ").concat(c,");\n      const ivec3 pads = ivec3(").concat(m,", ").concat(g,", ").concat(y,");\n      const float initializationValue = ").concat(v,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(v,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(d,";\n            wD += ").concat(l,") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(p,";\n            wR += ").concat(u,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(w,"; wC += 4) {\n              int xC = xCCorner + wC * ").concat(h,";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(h,", ch)\n              );\n\n              ").concat(S,"\n            }\n\n            int xC = xCCorner + ").concat(w,";\n            if (").concat(1===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(S,"\n            } else if (").concat(2===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(S,"\n            } else if (").concat(3===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h,", ch),\n                initializationValue\n              );\n\n              ").concat(S,"\n            }\n          }\n          setOutput(").concat(x,");\n        }\n      }\n    ")}}const yP={kernelName:An,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;jO(r,"avgPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:c}=a;Et(Tl(o,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'")));const l=yl(r.shape,s,o,1,i,c);if(1===l.filterWidth&&1===l.filterHeight&&Ot(l.inShape,l.outShape))return aL({inputs:{x:r},backend:n});const u=new mP(l,"avg",!1);return n.runWebGLProgram(u,[r],"float32")}};const bP={kernelName:Fn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:c,dataFormat:l}=a,u=bl(r.shape,s,o,[1,1,1],i,c,l),h=new gP(u,"avg",!1);return n.runWebGLProgram(h,[r],"float32")}};class vP{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,o=e.dilationWidth,i=e.effectiveFilterHeight,c=e.effectiveFilterWidth,l=i-1-e.padInfo.top,u=c-1-e.padInfo.left,h=1/(t*n);this.userCode="\n      const ivec2 pads = ivec2(".concat(l,", ").concat(u,");\n      const float avgMultiplier = float(").concat(h,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(i,";\n            wR += ").concat(s,") {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(c,";\n            wC+= ").concat(o,") {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class xP{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,s=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=u-1-e.padInfo.front,f=h-1-e.padInfo.top,m=d-1-e.padInfo.left,g=1/(t*n*a);this.userCode="\n      const ivec3 pads = ivec3(".concat(p,", ").concat(f,", ").concat(m,");\n      const float avgMultiplier = float(").concat(g,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(u,";\n            wD += ").concat(i,") {\n          float dyD = float(dyDCorner + wD) / ").concat(r,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(h,";\n              wR += ").concat(c,") {\n            float dyR = float(dyRCorner + wR) / ").concat(s,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(d,";\n                wC += ").concat(l,") {\n              float dyC = float(dyCCorner + wC) / ").concat(o,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const wP={kernelName:On,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,o=s,{filterSize:i,strides:c,pad:l,dimRoundingMode:u}=a,h=bl(o.shape,i,c,[1,1,1],l,u),d=new xP(h);return n.runWebGLProgram(d,[r],o.dtype)}};const kP={kernelName:_n,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,o=s;jO([r,s],"avgPoolGrad");const{filterSize:i,strides:c,pad:l}=a,u=yl(o.shape,i,c,1,l),h=new vP(u);return n.runWebGLProgram(h,[r],o.dtype)}};const SP={kernelName:Dn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:o,transposeB:i}=a;return LL({a:r,b:s,transposeA:o,transposeB:i,backend:n})}};class IP{constructor(e,t,n,a,r,s){this.outputShape=[],this.variableNames=["x","mean","variance"],vc(e,t),vc(e,n);let o="0.0";null!=a&&(vc(e,a),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="1.0";null!=r&&(vc(e,r),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(o,";\n        float scale = ").concat(i,";\n        float inv = scale * inversesqrt(variance + float(").concat(s,"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ")}}class NP{constructor(e,t,n,a,r,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],vc(e,t),vc(e,n);let o="vec4(0.0)";null!=a&&(vc(e,a),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="vec4(1.0)";null!=r&&(vc(e,r),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        vec4 offset = ".concat(o,";\n        vec4 scale = ").concat(i,";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(s,"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ")}}const CP={kernelName:Ia,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,mean:s,variance:o,offset:i,scale:c}=t;Et(s.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Et(null==i||s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Et(null==c||s.shape.length===c.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=a;null==l&&(l=.001);const u=[r,s,o];let h=null;null!=i&&(h=i.shape,u.push(i));let d=null;null!=c&&(d=c.shape,u.push(c));const p=hn().getBool("WEBGL_PACK_NORMALIZATION")?new NP(r.shape,s.shape,o.shape,h,d,l):new IP(r.shape,s.shape,o.shape,h,d,l);return n.runWebGLProgram(p,u,u[0].dtype)}};class TP{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=cD(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return EP.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error("Slicing for rank ".concat(e," is not yet supported"))}(this.rank);let a;const r=e.map(((e,t)=>"sourceLoc.".concat(EP[t]," = start[").concat(t,"] + coords.").concat(EP[t],";")));a="\n        ".concat(t," sourceLoc;\n        ").concat(t," coords = getOutputCoords();\n        ").concat(r.join("\n"),"\n      "),this.userCode="\n      void main() {\n        ".concat(a,"\n        setOutput(getSource(").concat(n,"));\n      }\n    ")}}const EP=["x","y","z","w","u","v"];class RP{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=cD(this.rank),n=CM("coords",this.rank),a=CM("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":"vec2(".concat(a.slice(-2).join(),")"),s="getChannel(getSource(".concat(a.join(),"), ").concat(r,")"),o="\n      result.x = ".concat(s,";\n      if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n        ++").concat(a[this.rank-1],";\n        result.y = ").concat(s,";\n        --").concat(a[this.rank-1],";\n      }\n    "),i=1===this.rank?"":"\n      --".concat(n[this.rank-1],";\n      if (++").concat(n[this.rank-2]," < ").concat(e[this.rank-2],") {\n        ++").concat(a[this.rank-2],";\n        result.z = ").concat(s,";\n        if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n          ++").concat(a[this.rank-1],";\n          result.w = ").concat(s,";\n        }\n      }\n    "),c=this.rank<=4?"sourceLoc = coords +\n            ".concat(t,"(").concat(e.map(((e,t)=>"start[".concat(t,"]"))).join(),");"):e.map(((e,t)=>"".concat(a[t]," = ").concat(n[t]," + start[").concat(t,"];"))).join("\n");this.userCode="\n      void main() {\n        ".concat(t," coords = getOutputCoords();\n        ").concat(t," sourceLoc;\n        ").concat(c,"\n        vec4 result = vec4(0.);\n        ").concat(o,"\n        ").concat(i,"\n        setOutput(result);\n      }\n    ")}}function AP(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:o}=a,[i,c]=Wc(r,s,o);if(Cc(r,i,c),0===Ft(c))return n.makeTensorInfo(c,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||"string"===r.dtype){const e=n.texData.get(r.dataId),t=hM(e.values,i,c,r.shape,r.dtype);return n.makeTensorInfo(c,r.dtype,t)}const{isPacked:l}=n.texData.get(r.dataId),u=zc(r.shape,i,c);if(l||!u){const e=hn().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new RP(c):new TP(c),t=[i];return n.runWebGLProgram(e,[r],r.dtype,t)}return n.uploadToGPU(r.dataId),function(e,t,n,a){const r=a.texData.get(e.dataId),s=a.makeTensorInfo(n,e.dtype),o=a.texData.get(s.dataId);Object.assign(o,r),o.refCount=1,o.shape=n,o.dtype=e.dtype;let i=Bc(t,Qt(e.shape));r.slice&&(i+=r.slice.flatOffset),o.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||e.dataId};const c=a.dataRefCount.get(o.slice.origDataId)||1;return a.dataRefCount.set(o.slice.origDataId,c+1),s}(r,i,c,n)}const _P={kernelName:Pr,backendName:"webgl",kernelFunc:AP},FP={kernelName:Mn,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:o}=a;Et(r.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const i=s.reduce(((e,t)=>e*t)),c=Xf(r.shape,s,i),l=Yf(c.length,s.length),u=Zf(r.shape,s,i),h=Qf(o,s.length),d=Jf(u,o,s.length),p=[],f=SL({inputs:{x:r},backend:n,attrs:{shape:c}}),m=OL({inputs:{x:f},backend:n,attrs:{perm:l}}),g=SL({inputs:{x:m},backend:n,attrs:{shape:u}}),y=AP({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}};const OP={kernelName:Ln,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:o}=a,i=n.readSync(r.dataId),c=n.readSync(s.dataId),l=DD(i,c,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,l)}};const DP={kernelName:Pn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.readSync(a.dataId),o=n.readSync(r.dataId),i=vc(Array.from(s),Array.from(o));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},MP=mL({opSnippet:"return float(a != b);",cpuKernelImpl:nM,dtype:"bool"}),LP={kernelName:ir,backendName:"webgl",kernelFunc:MP};function PP(e){const{inputs:t,backend:n}=e,{input:a}=t;return aL({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.real},backend:n})}const zP={kernelName:wr,backendName:"webgl",kernelFunc:PP},BP="return float(int(x));";const WP={kernelName:zn,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a,attrs:r}=t,{x:s}=n,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return aL({inputs:{x:s},backend:a});const t=Eh(s.shape),n=e({inputs:{x:s},backend:a,attrs:{dtype:"float32"}}),r=sL({inputs:{real:n,imag:t},backend:a});return t.dispose(),a.disposeIntermediateTensorInfo(n),r}if("complex64"===s.dtype){const t=PP({inputs:{input:s},backend:a}),n=e({inputs:{x:t},backend:a,attrs:{dtype:o}});return a.disposeIntermediateTensorInfo(t),n}if(!Gt(s.dtype,o)){const e=aL({inputs:{x:s},backend:a});return{dataId:e.dataId,shape:e.shape,dtype:o}}if(a.shouldExecuteOnCPU([s])){const e=a.texData.get(s.dataId).values,[t,n,r]=LD(e,s.shape,s.dtype,o);return a.makeTensorInfo(t,n,r)}if("int32"===o)return function(e,t){const n=new OM(e.shape,BP),a=t.runWebGLProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}(s,a);if("bool"===o){const e=a.makeTensorInfo([],"bool",Ut("bool",1)),t=MP({inputs:{a:s,b:e},backend:a});return a.disposeIntermediateTensorInfo(e),t}throw new Error("Error in Cast: failed to cast ".concat(s.dtype," to ").concat(o))}},UP="return ceil(x);",VP=fL({opSnippet:UP,packedOpSnippet:UP,cpuKernelImpl:PD}),GP={kernelName:Bn,backendName:"webgl",kernelFunc:VP};class jP{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class HP{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const KP={kernelName:Wn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:s,clipValueMax:o}=a;let i;i=hn().getBool("WEBGL_PACK_CLIP")?new HP(r.shape):new jP(r.shape);const c=[[s],[o]];return n.runWebGLProgram(i,[r],r.dtype,c)}};class qP{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function XP(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const YP={kernelName:Vn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=n.texData.get(a.dataId),s=new qP(a.shape),o=[XP(a,r.complexTensorInfos.real),XP(a,r.complexTensorInfos.imag)];return n.runWebGLProgram(s,o,o[0].dtype)}};class ZP{constructor(e){this.outputShape=[],this.outputShape=Bf(e,1),this.variableNames=e.map(((e,t)=>"T".concat(t)));const t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];const n=["if (yC < ".concat(t[0],") setOutput(getT0(yR, yC));")];for(let s=1;s<t.length;s++){const e=t[s-1];n.push("else if (yC < ".concat(t[s],") ")+"setOutput(getT".concat(s,"(yR, yC-").concat(e,"));"))}const a=t.length,r=t[t.length-1];n.push("else setOutput(getT".concat(a,"(yR, yC-").concat(r,"));")),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(n.join("\n        "),"\n      }\n    ")}}class QP{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Bf(e,t);const n=this.outputShape,a=n.length,r=cD(a),s=CM("coords",a),o=["x","y","z","w","u","v"].slice(0,a);this.variableNames=e.map(((e,t)=>"T".concat(t)));const i=new Array(e.length-1);i[0]=e[0][t];for(let f=1;f<i.length;f++)i[f]=i[f-1]+e[f][t];const c=o[t],l=o.slice(-2),u=o.join();let h="if (".concat(c," < ").concat(i[0],") {\n        return getChannel(\n            getT0(").concat(u,"), vec2(").concat(l.join(),"));\n        }");for(let f=1;f<i.length;f++){const e=i[f-1];h+="\n        if (".concat(c," < ").concat(i[f],"  && ").concat(c," >= ").concat(i[f-1],") {\n          return getChannel(\n            getT").concat(f,"(").concat(JP(o,c,e),"),\n            vec2(").concat(JP(l,c,e),"));\n        }")}const d=i.length,p=i[i.length-1];h+="\n        return getChannel(\n          getT".concat(d,"(").concat(JP(o,c,p),"),\n          vec2(").concat(JP(l,c,p),"));"),this.userCode="\n      float getValue(".concat(o.map((e=>"int "+e)),") {\n        ").concat(h,"\n      }\n\n      void main() {\n        ").concat(r," coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(s,"), 0., 0., 0.);\n\n        ").concat(s[a-1]," = ").concat(s[a-1]," + 1;\n        if (").concat(s[a-1]," < ").concat(n[a-1],") {\n          result.g = getValue(").concat(s,");\n        }\n\n        ").concat(s[a-2]," = ").concat(s[a-2]," + 1;\n        if (").concat(s[a-2]," < ").concat(n[a-2],") {\n          result.a = getValue(").concat(s,");\n        }\n\n        ").concat(s[a-1]," = ").concat(s[a-1]," - 1;\n        if (").concat(s[a-2]," < ").concat(n[a-2]," &&\n            ").concat(s[a-1]," < ").concat(n[a-1],") {\n          result.b = getValue(").concat(s,");\n        }\n        setOutput(result);\n      }\n    ")}}function JP(e,t,n){const a=e.indexOf(t);return e.map(((e,t)=>t===a?"".concat(e," - ").concat(n):e)).join()}function $P(e){const{inputs:t,backend:n}=e,{input:a}=t;return aL({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.imag},backend:n})}const ez={kernelName:_a,backendName:"webgl",kernelFunc:$P};function tz(e,t,n){const a=e[0].dtype;if("complex64"===a){const a=e.map((e=>PP({inputs:{input:e},backend:n}))),r=e.map((e=>$P({inputs:{input:e},backend:n}))),s=tz(a,t,n),o=tz(r,t,n),i=sL({inputs:{real:s,imag:o},backend:n});return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),r.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),i}let r=n.shouldExecuteOnCPU(e);if("string"===a&&(r=!0),r){const r=e.map((e=>{const a=Ft(e.shape.slice(t));return SL({inputs:{x:e},backend:n,attrs:{shape:[-1,a]}})})),s=r.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),o=Bf(r.map((e=>e.shape)),1),i=1===r[0].shape[0],c=zD(s,o,a,i),l=Bf(e.map((e=>e.shape)),t),u=n.makeTensorInfo(l,a,c);return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}const s=hn().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(e.length>s){const a=[];for(let o=0;o<e.length;o+=s){const r=e.slice(o,o+s);a.push(tz(r,t,n))}const r=tz(a,t,n);for(const e of a)n.disposeIntermediateTensorInfo(e);return r}if(hn().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const r=new QP(e.map((e=>e.shape)),t);return n.runWebGLProgram(r,e,a)}const{tensors2D:o,outShape:i}=function(e,t,n){const a=Bf(e.map((e=>e.shape)),t),r=e.map((e=>SL({inputs:{x:e},attrs:{shape:[-1,Ft(e.shape.slice(t))]},backend:n})));return{tensors2D:r,outShape:a}}(e,t,n),c=new ZP(o.map((e=>e.shape))),l=n.runWebGLProgram(c,o,a);o.forEach((e=>n.disposeIntermediateTensorInfo(e)));const u=SL({inputs:{x:l},attrs:{shape:i},backend:n});return n.disposeIntermediateTensorInfo(l),u}function nz(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=Bt(r,t[0].shape)[0],o=t.map((e=>e.shape));zf(o,s);const i=Bf(t.map((e=>e.shape)),s);if(0===Ft(i))return n.makeTensorInfo(i,t[0].dtype,[]);const c=t.filter((e=>Ft(e.shape)>0));return 1===c.length?aL({inputs:{x:c[0]},backend:n}):tz(c,s,n)}const az={kernelName:Gn,backendName:"webgl",kernelFunc:nz};class rz{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;const s=e.padInfo.top,o=e.padInfo.left,i=e.strideHeight,c=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1;let v="",x="";n&&(v=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),x="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(v,"\n\n      const ivec2 strides = ivec2(").concat(i,", ").concat(c,");\n      const ivec2 pads = ivec2(").concat(s,", ").concat(o,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(b,"];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(g,"], coords[").concat(y,"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(h,"; wR++) {\n          int xR = xRCorner + wR * ").concat(l,";\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(d,"; wC++) {\n            int xC = xCCorner + wC * ").concat(u,";\n\n            if (xC < 0 || xC >= ").concat(e.inWidth,") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(m,") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1===f,") {\n\n              if (").concat(m,") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(p,") *\n                    getW(wR, wC, ").concat(p,", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(p,", xR, xC) *\n                    getW(wR, wC, ").concat(p,", d2);\n              }\n\n            } else if (").concat(2===f,") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2)\n              );\n\n              if (").concat(m,") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3===f,") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2),\n                getW(wR, wC, ").concat(p," + 2, d2)\n              );\n\n              if (").concat(m,") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1),\n                  getX(batch, xR, xC, ").concat(p," + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC),\n                  getX(batch, ").concat(p," + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(w,"\n        ").concat(x,"\n        setOutput(result);\n      }\n    ")}}class sz{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,a=e.padInfo.left,r=e.strideDepth,s=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.filterDepth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3(".concat(r,", ").concat(s,", ").concat(o,");\n      const ivec3 pads = ivec3(").concat(t,", ").concat(n,", ").concat(a,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(u,"; wF++) {\n          int xF = xFCorner + wF * ").concat(i,";\n\n          if (xF < 0 || xF >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(h,"; wR++) {\n            int xR = xRCorner + wR * ").concat(c,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(d,"; wC++) {\n              int xC = xCCorner + wC * ").concat(l,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1===f,") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(p,") *\n                  getW(wF, wR, wC, ").concat(p,", d2);\n              } else if (").concat(2===f,") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3===f,") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1),\n                  getX(batch, xF, xR, xC, ").concat(p," + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2),\n                  getW(wF, wR, wC, ").concat(p," + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class oz{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=mD(this.outputShape.length);const s=e.padInfo.left,o=e.strideWidth,i=e.dilationWidth,c=e.filterHeight,l=e.filterWidth,u=l;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<l;m++)h+="\n           vec4 xTexelC".concat(2*m,";\n           int xTexelC").concat(2*m,"Ready;\n           vec4 xTexelC").concat(2*m+1,";\n           int xTexelC").concat(2*m+1,"Ready;\n           vec4 xC").concat(m,";");h+="\n     for (int r = 0; r < ".concat(c,"; r++) {\n      for (int d1 = 0; d1 < ").concat(e.inChannels,"; d1 += 2) {\n       ");for(let m=0;m<l;m++)h+="\n           xTexelC".concat(2*m," = vec4(0.0);\n           xTexelC").concat(2*m,"Ready = 0;\n           xTexelC").concat(2*m+1," = vec4(0.0);\n           xTexelC").concat(2*m+1,"Ready = 0;\n           xC").concat(m," = vec4(0.0);");h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(u+1)/2;m++){const t=2*m;if(h+="\n           xC = xCCorner + ".concat(t*i,";\n           "),1===o){if(t<l&&(s%2===1?(h+="\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n               "),h+=1===i&&t>0?"\n                 xC".concat(t," = vec4(xTexelC").concat(t-2,".zw, xTexelC").concat(t,".xy);\n                 "):"\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC".concat(t," = vec4(previous.zw, xTexelC").concat(t,".xy);\n                   } else {\n                     xC").concat(t," = vec4(0.0, 0.0, xTexelC").concat(t,".xy);\n                   }\n                   ")):h+="\n                 if (xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xC").concat(t," = xTexelC").concat(t,";\n                 "),t+1<l)){const e=s%2===0?Ct(i):i;i%2===0&&s%2===1||i%2!==0&&s%2!==1?(h+="\n                   xCOffset = xC + imod(pads[1], 2) + ".concat(e,";\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                     xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC").concat(t+1,".zw = vec2(0.0);\n                     }\n                     xTexelC").concat(t+1,"Ready = 1;\n                   }\n                   "),h+=i>1?"\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC".concat(t+1," = vec4(previous.zw, xTexelC").concat(t+1,".xy);\n                     } else {\n                      xC").concat(t+1," = vec4(0.0, 0.0, xTexelC").concat(t+1,".xy);\n                     }\n                     "):"\n                     xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".xy);\n                     ")):h+=1===e?"\n                     xC".concat(t+1," = xTexelC").concat(t,";\n                     "):"\n                     xCOffset = xC + ".concat(e,";\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                       xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC").concat(t+1,".zw = vec2(0.0);\n                       }\n                       xTexelC").concat(t+1,"Ready = 1;\n                     }\n\n                     xC").concat(t+1," = xTexelC").concat(t+1,";\n                     ")}}else t<l&&(s%2===1?(h+="\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n               "),t+1<l&&(h+="\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC".concat(t+1," = vec4(xTexelC").concat(t+1,".xy, final.xy);\n                 "))):(h+="\n                 if(xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(\n                   xTexelC").concat(t,".xy, xTexelC").concat(t+1,".xy);\n               "),t+1<l&&(h+="\n                   xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n                 "))));t<l&&(h+="\n             wTexel = getW(r, ".concat(t,", d1, d2);\n             dotProd += xC").concat(t,".xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ").concat(e.inChannels,") {\n               dotProd += xC").concat(t,".yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           "),t+1<l&&(h+="\n               wTexel = getW(r, ".concat(t+1,", d1, d2);\n               dotProd += xC").concat(t+1,".xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ").concat(e.inChannels,") {\n                 dotProd += xC").concat(t+1,".yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             ")))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let d="",p="";n&&(d=a?"vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ".concat(n,"\n         }"):r?"vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ".concat(n,"\n         }"):"vec4 activation(vec4 x) {\n           ".concat(n,"\n         }"),p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n       ".concat(d,"\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ").concat(h,"\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ").concat(f,"\n         ").concat(p,"\n         setOutput(result);\n       }\n     ")}}class iz{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=mD(this.outputShape.length);const{dataFormat:n}=t,a=KO(),r="channelsLast"===n,s=r?1:2,o=r?2:3,i=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < ".concat(e[2]," && pos < ").concat(e[1],") {");let c="";for(let l=0;l<=1;l++)for(let e=0;e<=1;e++)c+="\n          blockIndex = rc.z + ".concat(e,";\n          pos = rc.y + ").concat(l,";\n\n          ").concat(i,"\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[").concat(s,"] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[").concat(o,"] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (").concat(r,") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2*l+e,"] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2*l+e,"] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");this.userCode="\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(c,"\n\n        ").concat(a.output," = result;\n      }\n    ")}}function cz(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function lz(e){let{x:t,filter:n,convInfo:a,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:c=null}=e;const l=t.shape,u=r.texData.get(t.dataId),h=a.inChannels,d=l[0]*l[1]*l[2],p=a.outChannels,f="channelsLast"===a.dataFormat;let m;const g=[];if(null!=o){const e=cz(o.shape,f);null!=e&&(o=SL({inputs:{x:o},backend:r,attrs:{shape:e}}),g.push(o))}if(null!=s){const e=cz(s.shape,f);null!=e&&(s=SL({inputs:{x:s},backend:r,attrs:{shape:e}}),g.push(s))}if(!((1===d||1===p)&&h>ML)&&u.isPacked&&f&&null!=u.texture&&l[2]%2!==0&&Ot(u.shape.slice(-3),l.slice(-3))){const e=l[0]*l[1]*(l[2]+1),h={dataId:t.dataId,shape:[1,e,a.inChannels],dtype:t.dtype},d=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,Et(PO(u.shape,h.shape),(()=>"packed reshape ".concat(u.shape," to ").concat(h.shape," isn't free")));const p=SL({inputs:{x:n},backend:r,attrs:{shape:[1,a.inChannels,a.outChannels]}});g.push(p);const f=LL({a:h,b:p,backend:r,transposeA:false,transposeB:false,bias:s,activation:c,preluActivationWeights:o,leakyreluAlpha:i}),y=r.texData.get(f.dataId);Et(y.isPacked,(()=>"batchMatMul result is expected to be packed")),u.shape=d,y.shape=a.outShape,m=aL({inputs:{x:f},backend:r}),m.shape=a.outShape,g.push(f)}else{const e=a.outHeight*a.outWidth,l=SL({inputs:{x:t},backend:r,attrs:{shape:f?[a.batchSize,e,a.inChannels]:[a.batchSize,a.inChannels,e]}}),u=SL({inputs:{x:n},backend:r,attrs:{shape:[1,a.inChannels,a.outChannels]}}),h=LL({a:f?l:u,b:f?u:l,transposeA:!f,transposeB:false,backend:r,bias:s,activation:c,preluActivationWeights:o,leakyreluAlpha:i});m=SL({inputs:{x:h},backend:r,attrs:{shape:a.outShape}}),g.push(l),g.push(u),g.push(h)}for(const y of g)r.disposeIntermediateTensorInfo(y);return m}function uz(e){let{x:t,filter:n,convInfo:a,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:c=null}=e;const{filterWidth:l,filterHeight:u,inChannels:h,outWidth:d,outHeight:p,dataFormat:f}=a,m="channelsLast"===f,g=l*u*h,y=p*d,b=[a.batchSize,g,y],v=[];if(null!=o){const e=cz(o.shape,m);null!=e&&(o=SL({inputs:{x:o},backend:r,attrs:{shape:e}}),v.push(o))}if(null!=s){const e=cz(s.shape,m);null!=e&&(s=SL({inputs:{x:s},backend:r,attrs:{shape:e}}),v.push(s))}const x=SL({inputs:{x:n},backend:r,attrs:{shape:[1,g,Ft(n.shape)/g]}});v.push(x);const w=new iz(b,a),k=[t.shape,[a.padInfo.top,a.padInfo.left],[a.strideHeight,a.strideWidth],[a.dilationHeight,a.dilationWidth],[a.inChannels],[a.filterWidth*a.inChannels],[a.outWidth]],S=r.runWebGLProgram(w,[t],"float32",k),I=SL({inputs:{x:S},backend:r,attrs:{shape:b}});v.push(S),v.push(I);const N=null!=s,C=null!=o,T="leakyrelu"===c,E=c?gL(c,!0):null,R=new yL(m?I.shape:x.shape,m?x.shape:I.shape,m?[a.batchSize,y,a.outChannels]:[a.batchSize,a.outChannels,y],!0,!1,N,E,C,T),A=m?[I,x]:[x,I];if(s&&A.push(s),C&&A.push(o),T){const e=r.makeTensorInfo([],"float32",Ks(i,"float32"));A.push(e),v.push(e)}const _=r.runWebGLProgram(R,A,"float32"),F=SL({inputs:{x:_},backend:r,attrs:{shape:a.outShape}});v.push(_);for(const O of v)r.disposeIntermediateTensorInfo(O);return F}const hz={kernelName:jn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dataFormat:c,dilations:l,dimRoundingMode:u}=a,h=El(c),d=vl(r.shape,s.shape,o,l,i,u,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(d.strideWidth<=2&&"channelsLast"===h&&hn().getBool("WEBGL_EXP_CONV")){const e=new oz(d),t=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=n.runWebGLProgram(e,[r,s],"float32",t)}else if(hn().getBool("WEBGL_CONV_IM2COL"))p=uz({x:r,filter:s,convInfo:d,backend:n});else{const e=new rz(d);p=n.runWebGLProgram(e,[r,s],"float32")}else p=lz({x:r,filter:s,convInfo:d,backend:n});const f=SL({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class dz{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(r,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              if (").concat(s,") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class pz{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s="channelsLast"===e.dataFormat,o=t-1-e.padInfo.top,i=n-1-e.padInfo.left,c=s?1:2,l=s?2:3,u=s?3:1;this.userCode="\n      const ivec2 pads = ivec2(".concat(o,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(u,"];\n\n        ivec2 dyCorner = ivec2(coords[").concat(c,"], coords[").concat(l,"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n\n              if (").concat(s,") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class fz{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.padInfo.front,s=e.padInfo.top,o=e.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yF = 0; yF < ").concat(e.outDepth,"; yF++) {\n            int xF = wF + yF * ").concat(t," - ").concat(r,";\n\n            if (xF < 0 || xF >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n              int xR = wR + yR * ").concat(n," - ").concat(s,";\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n                int xC = wC + yC * ").concat(a," - ").concat(o,";\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class mz{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,s=e.strideHeight,o=e.strideWidth,i=t-1-e.padInfo.front,c=n-1-e.padInfo.top,l=a-1-e.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3(".concat(i,", ").concat(c,", ").concat(l,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(t,"; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(r,".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(e.outDepth,".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(t," - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(n,"; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(s,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(n," - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(a,"; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(o,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(a," - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const gz={kernelName:Hn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,pad:i,dataFormat:c,dimRoundingMode:l,filterShape:u}=a,h=El(c),d=vl(r.shape,u,o,1,i,l,!1,h),p=new dz(d);return n.runWebGLProgram(p,[r,s],"float32")}};const yz={kernelName:Kn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:o,strides:i,pad:c,dataFormat:l,dimRoundingMode:u}=a,h=El(l),d=vl(o,s.shape,i,1,c,u,!1,h),p=new pz(d);return n.runWebGLProgram(p,[r,s],"float32")}};const bz={kernelName:qn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dilations:c}=a,l=xl(r.shape,s.shape,o,c,i),u=new sz(l);return n.runWebGLProgram(u,[r,s],"float32")}};const vz={kernelName:Xn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,pad:i,filterShape:c}=a,l=xl(r.shape,c,o,1,i),u=new fz(l);return n.runWebGLProgram(u,[r,s],"float32")}};const xz={kernelName:Yn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:o,strides:i,inputShape:c}=a,l=xl(c,s.shape,i,1,o),u=new mz(l);return n.runWebGLProgram(u,[r,s],"float32")}},wz=fL({opSnippet:pL+"\n  return cos(x);\n"}),kz={kernelName:Zn,backendName:"webgl",kernelFunc:wz},Sz=fL({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),Iz={kernelName:Qn,backendName:"webgl",kernelFunc:Sz};class Nz{constructor(e,t,n,a,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,o,i,c]=e,[l]=t,[u,h]=n;this.outputShape=[l,u,h,c];const d="bilinear"===a?1:0,[p,f]=["".concat(o-1,".0"),"".concat(i-1,".0")],[m,g,y]=u>1?["".concat((o-1)/(u-1)),"(y2-y1) * height_ratio","y1*".concat(p," + float(y)*(height_scale)")]:["0.0","0.0","0.5 * (y1+y2) * ".concat(p)],[b,v,x]=h>1?["".concat((i-1)/(h-1)),"(x2-x1) * width_ratio","x1*".concat(f," + float(x)*(width_scale)")]:["0.0","0.0","0.5 * (x1+x2) * ".concat(f)];this.userCode="\n      const float height_ratio = float(".concat(m,");\n      const float width_ratio = float(").concat(b,");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(s,") {\n          return;\n        }\n\n        float height_scale = ").concat(g,";\n        float width_scale = ").concat(v,";\n\n        float in_y = ").concat(y,";\n        if( in_y < 0.0 || in_y > ").concat(p," ) {\n          setOutput(float(").concat(r,"));\n          return;\n        }\n        float in_x = ").concat(x,";\n        if( in_x < 0.0 || in_x > ").concat(f," ) {\n          setOutput(float(").concat(r,"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat(d," == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ")}}const Cz={kernelName:ea,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:o}=t,{cropSize:i,method:c,extrapolationValue:l}=a,u=new Nz(r.shape,s.shape,i,c,l);return n.runWebGLProgram(u,[r,s,o],"float32")}};var Tz;!function(e){e.Prod="*",e.Sum="+"}(Tz||(Tz={}));class Ez{constructor(e,t,n,a){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const r=this.outputShape.length,s=this.op===Tz.Prod?"1.0":"0.0",o=n?s:"getX(".concat(Rz(r,"coords",this.op),")"),i=this.outputShape[this.outputShape.length-1];let c="",l="";n?(c=a?"end != ".concat(i-1):"end != 0",l=a?"end + 1":"end - 1"):(c=a?"end + pow2 < ".concat(i):"end >= pow2",l=a?"end + pow2":"end - pow2"),this.userCode="\n      void main() {\n        ".concat(cD(r)," coords = getOutputCoords();\n        int end = ").concat(Az(r,"coords",this.op),";\n        float val = ").concat(o,";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(c,") {\n          int idx = ").concat(l,";\n          ").concat(Az(r,"coords",this.op)," = idx;\n          val ").concat(this.op,"= getX(").concat(Rz(r,"coords",this.op),");\n        }\n        setOutput(val);\n      }\n    ")}}function Rz(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".x, ").concat(t,".y");if(3===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z");if(4===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z, ").concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function Az(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".y");if(3===e)return"".concat(t,".z");if(4===e)return"".concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function _z(e,t,n,a,r,s){const o=t.shape.length,i=Fu([a],o);let c=t;null!=i&&(c=OL({inputs:{x:t},backend:n,attrs:{perm:i}}));const l=Du(1,o)[0];if(l!==o-1)throw new Error("WebGL cumprod shader expects an inner-most axis=".concat(t.shape.length-1," ")+"but got axis=".concat(a));const u=c.shape[l];let h=aL({inputs:{x:c},backend:n});for(let d=0;d<=Math.ceil(Math.log2(u))-1;d++){const t=new Ez(e,c.shape,!1,s),a=[[d]],r=h;h=n.runWebGLProgram(t,[h],h.dtype,a),n.disposeIntermediateTensorInfo(r)}if(r){const t=new Ez(e,c.shape,r,s),a=h;h=n.runWebGLProgram(t,[h],h.dtype),n.disposeIntermediateTensorInfo(a)}if(null!=i){const e=OL({inputs:{x:h},backend:n,attrs:{perm:Ou(i)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(c),e}return h}const Fz={kernelName:Jn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:o,reverse:i}=a;return _z(Tz.Prod,r,n,s,o,i)}};const Oz={kernelName:$n,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:o,reverse:i}=a;return _z(Tz.Sum,r,n,s,o,i)}};const Dz={kernelName:ta,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:o,binaryOutput:i}=a;if(1===r.shape.length){const e=n.readSync(r.dataId),t=n.readSync(s.dataId),a=DD(e,t,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,a)}if(2===r.shape.length){const e=n.bufferSync(r),t=n.bufferSync(s),a=MD(e,t,o,i);return n.makeTensorInfo(a.shape,s.dtype,a.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(r.shape.length,"."))}};class Mz{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(),";\n      int w = ").concat(this.getWidthCoordString(),";\n      int d = ").concat(this.getDepthCoordString(),";\n\n      int in_h = h / ").concat(t,";\n      int offset_h = imod(h, ").concat(t,");\n      int in_w = w / ").concat(t,";\n      int offset_w = imod(w, ").concat(t,");\n      int offset_d = (offset_h * ").concat(t," + offset_w) *\n        ").concat(this.getOutputDepthSize(),";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(),";\n      setOutput(result);\n    }\n  ")}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const Lz={kernelName:na,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:o}=a,i=r.shape[0],c=("NHWC"===o?r.shape[1]:r.shape[2])*s,l=("NHWC"===o?r.shape[2]:r.shape[3])*s,u=("NHWC"===o?r.shape[3]:r.shape[1])/(s*s),h=new Mz("NHWC"===o?[i,c,l,u]:[i,u,c,l],s,o);return n.runWebGLProgram(h,[r],r.dtype)}};class Pz{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=mD(this.outputShape.length);const s=e.filterHeight,o=e.filterWidth,i=e.outChannels/e.inChannels;let c="",l="";n&&(c=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),l="result = activation(result);");const u=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(c,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(i,";\n        int q = d2 - d1 * ").concat(i,";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(s,"; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(o,"; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(u,"\n        ").concat(l,"\n        setOutput(result);\n      }\n    ")}}class zz{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=mD(this.outputShape.length);const s=e.outChannels/e.inChannels,o=e.padInfo.left,i=e.strideWidth,c=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,h=u;let d="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<u;g++)d+="\n          vec4 xTexelC".concat(2*g,";\n          int xTexelC").concat(2*g,"Ready;\n          vec4 xTexelC").concat(2*g+1,";\n          int xTexelC").concat(2*g+1,"Ready;\n          vec4 xC").concat(g,";");d+="\n    for (int r = 0; r < ".concat(l,"; r++) {\n      ");for(let g=0;g<u;g++)d+="\n          xTexelC".concat(2*g," = vec4(0.0);\n          xTexelC").concat(2*g,"Ready = 0;\n          xTexelC").concat(2*g+1," = vec4(0.0);\n          xTexelC").concat(2*g+1,"Ready = 0;\n          xC").concat(g," = vec4(0.0);");d+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(h+1)/2;g++){const e=2*g;if(d+="\n          xC = xCCorner + ".concat(e*c,";\n          "),1===i){if(e<u&&(o%2===1?(d+="\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n              "),d+=1===c&&e>0?"\n                xC".concat(e," = vec4(xTexelC").concat(e-2,".zw, xTexelC").concat(e,".xy);\n                "):"\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC".concat(e," = vec4(previous.zw, xTexelC").concat(e,".xy);\n                  } else {\n                    xC").concat(e," = vec4(0.0, 0.0, xTexelC").concat(e,".xy);\n                  }\n                  ")):d+="\n                if (xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xC").concat(e," = xTexelC").concat(e,";\n                "),e+1<u)){const t=o%2===0?Ct(c):c;c%2===0&&o%2===1||c%2!==0&&o%2!==1?(d+="\n                  xCOffset = xC + imod(pads[1], 2) + ".concat(t,";\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                    xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC").concat(e+1,".zw = vec2(0.0);\n                    }\n                    xTexelC").concat(e+1,"Ready = 1;\n                  }\n                  "),d+=c>1?"\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC".concat(e+1," = vec4(previous.zw, xTexelC").concat(e+1,".xy);\n                    } else {\n                     xC").concat(e+1," = vec4(0.0, 0.0, xTexelC").concat(e+1,".xy);\n                    }\n                    "):"\n                    xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".xy);\n                    ")):d+=1===t?"\n                    xC".concat(e+1," = xTexelC").concat(e,";\n                    "):"\n                    xCOffset = xC + ".concat(t,";\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                      xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC").concat(e+1,".zw = vec2(0.0);\n                      }\n                      xTexelC").concat(e+1,"Ready = 1;\n                    }\n\n                    xC").concat(e+1," = xTexelC").concat(e+1,";\n                    ")}}else e<u&&(o%2===1?(d+="\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n              "),e+1<u&&(d+="\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC".concat(e+1," = vec4(xTexelC").concat(e+1,".xy, final.xy);\n                "))):(d+="\n                if(xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(\n                  xTexelC").concat(e,".xy, xTexelC").concat(e+1,".xy);\n              "),e+1<u&&(d+="\n                  xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n                "))));e<u&&(d+="\n            wTexel = getW(r, ".concat(e,", d1, q);\n            dotProd += xC").concat(e," * vec4(wTexel.xz, wTexel.xz);\n          "),e+1<u&&(d+="\n              wTexel = getW(r, ".concat(e+1,", d1, q);\n              dotProd += xC").concat(e+1," * vec4(wTexel.xz, wTexel.xz);\n            ")))}d+="\n    }\n  ",d+="\n      }\n    ";let p="",f="";n&&(p=a?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(n,"\n        }"),f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(p,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(s,";\n        int q = d2 - d1 * ").concat(s,";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ").concat(d,"\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ").concat(m,"\n        ").concat(f,"\n        setOutput(result);\n      }\n    ")}}const Bz={kernelName:aa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dilations:c,dimRoundingMode:l}=a;let u=c;null==u&&(u=[1,1]),Et(Tl(o,u),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(o," and dilations '").concat(u,"'")));const h=vl(r.shape,s.shape,o,u,i,l,!0);let d;d=hn().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?new zz(h):new Pz(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[r,s],"float32",p)}};class Wz{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(s," + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(r,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class Uz{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=t-1-e.padInfo.top,o=n-1-e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode="\n      const ivec2 pads = ivec2(".concat(s,", ").concat(o,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(i,"; dm++) {\n              int d2 = d1 * ").concat(i," + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const Vz={kernelName:ra,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,dilations:i,pad:c,dimRoundingMode:l,filterShape:u}=a,h=vl(r.shape,u,o,i,c,l,!0),d=new Wz(h);return n.runWebGLProgram(d,[r,s],"float32")}};const Gz={kernelName:sa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{strides:o,dilations:i,pad:c,dimRoundingMode:l,inputShape:u}=a,h=vl(u,s.shape,o,i,c,l,!0),d=new Uz(h);return n.runWebGLProgram(d,[r,s],"float32")}};class jz{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const Hz={kernelName:oa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=[...a.shape,...a.shape],s=Ft(a.shape),o=SL({inputs:{x:a},backend:n,attrs:{shape:[s]}}),i=new jz(s),c=n.runWebGLProgram(i,[o],o.dtype),l=SL({inputs:{x:c},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(c),l}};class Kz{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:a,strideHeight:r,strideWidth:s,filterHeight:o,filterWidth:i,dilationHeight:c,dilationWidth:l}=e,{top:u,left:h}=a;this.userCode="\n      const ivec2 strides = ivec2(".concat(r,", ").concat(s,");\n      const ivec2 pads = ivec2(").concat(u,", ").concat(h,");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(o,"; h++) {\n          int hIn = hBeg + h * ").concat(c,";\n\n          if (hIn >= 0 && hIn < ").concat(t,") {\n            for (int w = 0; w < ").concat(i,"; w++) {\n              int wIn = wBeg + w * ").concat(l,";\n\n              if (wIn >= 0 && wIn < ").concat(n,") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ")}}const qz={kernelName:ia,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dilations:c}=a,l=gl(r.shape,s.shape,o,i,"NHWC",c);let u;const h=new Kz(l);u=n.runWebGLProgram(h,[r,s],"float32");const d=SL({inputs:{x:u},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(u),d}};const Xz={kernelName:ha,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,s=t,{allDims:o,summedDims:i,idDims:c}=xm(r,s.length);km(o.length,c,s);const{path:l,steps:u}=Sm(i,c),h=u.length;let d=null,p=o.length;const f=[];for(let m=0;m<h;++m){for(const e of u[m]){const{permutationIndices:t,expandDims:a}=wm(p,c[e]);let r;Im(t)?r=s[e]:(r=OL({inputs:{x:s[e]},backend:n,attrs:{perm:t}}),f.push(r));const o=r.shape.slice();for(let e=0;e<a.length;++e)o.splice(a[e],0,1);Ot(r.shape,o)||(r=SL({inputs:{x:r},backend:n,attrs:{shape:o}}),f.push(r)),null===d?d=r:(d=wL({inputs:{a:r,b:d},backend:n}),f.push(d))}m<h-1&&(l[m]>=0&&(d=_L({inputs:{x:d},backend:n,attrs:{axis:l[m]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}},Yz=fL({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),Zz={kernelName:da,backendName:"webgl",kernelFunc:Yz},Qz={kernelName:pa,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:a,y:r}=t,s=hn().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new nL("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",a.shape,r.shape):new eL("return (b >= 1.0) ? a : a * (b + 1.0);",a.shape,r.shape);return n.runWebGLProgram(s,[a,r],a.dtype)}},Jz=mL({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:BD}),$z={kernelName:ma,backendName:"webgl",kernelFunc:Jz},eB=fL({opSnippet:'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '.concat(nm,";\n  float a1 = ").concat(am,";\n  float a2 = ").concat(rm,";\n  float a3 = ").concat(sm,";\n  float a4 = ").concat(om,";\n  float a5 = ").concat(im,";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n")}),tB={kernelName:fa,backendName:"webgl",kernelFunc:eB},nB=fL({opSnippet:pL+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:WD,dtype:"float32"}),aB={kernelName:ga,backendName:"webgl",kernelFunc:nB};function rB(e){const{inputs:t,attrs:n,backend:a}=e,{dim:r}=n,{input:s}=t,o=s.shape.length,i=s.shape.slice();let c=r;return r<0&&(Et(-(o+1)<=r,(()=>"Axis must be in the interval [".concat(-(o+1),", ").concat(o,"]"))),c=o+r+1),i.splice(c,0,1),SL({inputs:{x:s},backend:a,attrs:{shape:i}})}const sB={kernelName:ya,backendName:"webgl",kernelFunc:rB},oB="return exp(x) - 1.0;",iB=fL({opSnippet:oB,packedOpSnippet:oB,cpuKernelImpl:UD}),cB={kernelName:ba,backendName:"webgl",kernelFunc:iB};class lB{constructor(e,t,n){this.variableNames=["real","imag"];const a=t[1];this.outputShape=t;const r=n?"2.0 * ".concat(Math.PI):"-2.0 * ".concat(Math.PI),s=n?"".concat(a,".0"):"1.0";let o;if("real"===e)o="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error('FFT component must be either "real" or "imag", got '.concat(e,"."));o="return real * expI + imag * expR;"}this.userCode="\n      const float exponentMultiplier = ".concat(r,";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(o,"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(a,");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(s,";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ")}}function uB(e,t,n){const a=n.texData.get(e.dataId),r=Ft(e.shape),s=e.shape[e.shape.length-1],o=SL({inputs:{x:e},backend:n,attrs:{shape:[r/s,s]}}),i=o.shape,c=new lB("real",i,t),l=new lB("imag",i,t),u=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:i},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:i}],h=n.runWebGLProgram(c,u,"float32"),d=n.runWebGLProgram(l,u,"float32"),p=sL({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=SL({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(p),f}const hB={kernelName:va,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return uB(a,!1,n)}};class dB{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function pB(e){const{backend:t,attrs:n}=e,{shape:a,value:r}=n;let{dtype:s}=n;if(s=s||Xt(r),"string"===s){const e=Vt(s,Ft(a));return e.fill(r),t.makeTensorInfo(a,s,e)}{const e=new dB(a,r),n=[[r]];return t.runWebGLProgram(e,[],s,n)}}const fB={kernelName:xa,backendName:"webgl",kernelFunc:pB};class mB{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(t," - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(t,") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const gB={kernelName:wa,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:a}=t,r=n,s=new mB(a.shape);return r.runWebGLProgram(s,[a],a.dtype)}},yB="return floor(x);",bB=fL({opSnippet:yB,packedOpSnippet:yB,cpuKernelImpl:VD}),vB={kernelName:ka,backendName:"webgl",kernelFunc:bB},xB=mL({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),wB={kernelName:Sa,backendName:"webgl",kernelFunc:xB};class kB{constructor(e){this.variableNames=["A"];const t=KO(),[n,a]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(a,".0, ").concat(n,".0);\n\n        vec4 values = ").concat(t.texture2D,"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ")}}class SB{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=KO(),[n,a]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(a,".0, ").concat(n,".0);\n            vec4 values = ").concat(t.texture2D,"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}const IB={kernelName:ys,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e;let{pixels:r}=t;const{numChannels:s}=a,o="undefined"!==typeof HTMLVideoElement&&r instanceof HTMLVideoElement,i="undefined"!==typeof HTMLImageElement&&r instanceof HTMLImageElement,[c,l]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],u=[l,c],h=[l,c,s];if(i||o){const e=hn().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=NB&&e===CB||(CB=e,NB=document.createElement("canvas").getContext("2d",{willReadFrequently:CB})),NB.canvas.width=c,NB.canvas.height=l,NB.drawImage(r,0,0,c,l),r=NB.canvas}const d=n.makeTensorInfo(u,"int32");n.texData.get(d.dataId).usage=fO.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),r);const p=hn().getBool("WEBGL_PACK")?new SB(h):new kB(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let NB,CB=hn().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const TB={kernelName:xs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:o,preluActivationWeights:i}=t,{strides:c,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=a,m=El(u),g=vl(r.shape,s.shape,c,h,l,d,!1,m);let y;const b=[],v=null!=o,x=null!=i,w="leakyrelu"===p,k=()=>{const e=[r,s],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=SL({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(v&&e.push(t(o,u)),x&&e.push(t(i,u)),w){const t=n.makeTensorInfo([],"float32",Ks(f,"float32"));e.push(t),b.push(t)}return e};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&hn().getBool("WEBGL_EXP_CONV")){const e=p?gL(p,!0):null,t=new oz(g,v,e,x,w),a=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],r=k();y=n.runWebGLProgram(t,r,"float32",a)}else if(hn().getBool("WEBGL_CONV_IM2COL"))y=uz({x:r,filter:s,convInfo:g,backend:n,bias:o,activation:p,preluActivationWeights:i,leakyreluAlpha:f});else{const e=p?gL(p,!1):null,t=new rz(g,v,e,x,w),a=k();y=n.runWebGLProgram(t,a,"float32")}else y=lz({x:r,filter:s,convInfo:g,backend:n,bias:o,activation:p,preluActivationWeights:i,leakyreluAlpha:f});const S=SL({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach((e=>n.disposeIntermediateTensorInfo(e))),S}};const EB={kernelName:ws,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:o,preluActivationWeights:i}=t,{strides:c,pad:l,dilations:u,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=a,f=[];let m=u;null==m&&(m=[1,1]),Et(Tl(c,m),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(c," and dilations '").concat(m,"'")));const g=vl(r.shape,s.shape,c,m,l,h,!0),y=hn().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=d?gL(d,y):null,v=[r,s],x=null!=o,w=null!=i,k="leakyrelu"===d;if(x&&v.push(o),w&&v.push(i),k){const e=n.makeTensorInfo([],"float32",Ks(p,"float32"));v.push(e),f.push(e)}let S;S=y?new zz(g,x,b,w,k):new Pz(g,x,b,w,k);const I=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],N=n.runWebGLProgram(S,v,"float32",I);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),N}};class RB{constructor(e,t,n,a){this.sliceDim=e,this.strides=t,this.paramsShape=a,this.variableNames=["x","indices"],this.outputShape=n;const r=cD(n.length);let s="\n    int index;";for(let o=0;o<this.sliceDim;o++)s+="\n          index = round(getIndices(coords[0], ".concat(o,"));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ").concat(this.paramsShape[o],";\n          flattenIndex += index * ").concat(this.strides[o],";");this.userCode="\n         void main() {\n          ".concat(r," coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ").concat(s,"\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      ")}}const AB={kernelName:Ca,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=r.shape,o=s[s.length-1],i=Ft(a.shape),[c,l,u,h]=$f(a,r),d=SL({inputs:{x:r},backend:n,attrs:{shape:[l,o]}}),p=SL({inputs:{x:a},backend:n,attrs:{shape:[Ft(a.shape)/u,u]}});if(n.shouldExecuteOnCPU([a,r])||"string"===a.dtype){const e=n.readSync(r.dataId),t=n.bufferSync(a),s=GD(e,t,a.dtype,l,o,u,h,a.shape,i);return n.makeTensorInfo(c,a.dtype,s.values)}const f=new RB(o,h,[l,u],a.shape),m=n.runWebGLProgram(f,[p,d],p.dtype),g=SL({inputs:{x:m},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class _B{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=cD(this.rank),a=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let r=0;r<e.length;r++)2===r?a.push("index"):a.push("".concat(n[r]));return a.join()}(e);this.userCode="\n      void main() {\n        ".concat(n," resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ").concat(e[2],") ? 1.0 : 0.0;\n        setOutput(inBounds * getA(").concat(a,"));\n      }\n    ")}}function FB(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:o,batchDims:i}=a,c=Bt(o,r.shape)[0];if(hn().get("DEBUG")){const e=n.readSync(s.dataId),t=r.shape[c];for(let n=0;n<e.length;++n){const a=e[n];Et(a<=t-1&&a>=0,(()=>"GatherV2: the index value ".concat(a," is not in [0, ").concat(t-1,"]")))}}const l=Um(r,s,c,i),u=Ft(s.shape),h=[],d=SL({inputs:{x:r},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),p=SL({inputs:{x:s},backend:n,attrs:{shape:[l.batchSize,u/l.batchSize]}});h.push(d),h.push(p);const f=[l.batchSize,l.outerSize,u/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const e=n.bufferSync(p),t=n.bufferSync(d),a=jD(t,e,f);return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(l.outputShape,a.dtype,a.values)}const m=new _B(d.shape,f),g=n.runWebGLProgram(m,[d,p],d.dtype);h.push(g);const y=SL({inputs:{x:g},backend:n,attrs:{shape:l.outputShape}});return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}const OB={kernelName:Na,backendName:"webgl",kernelFunc:FB},DB=mL({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:HD,dtype:"bool"}),MB={kernelName:Ta,backendName:"webgl",kernelFunc:DB},LB=mL({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:KD}),PB={kernelName:Ea,backendName:"webgl",kernelFunc:LB};const zB={kernelName:Aa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return uB(a,!0,n)}},BB=fL({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),WB={kernelName:Fa,backendName:"webgl",kernelFunc:BB},UB=fL({opSnippet:"return float(isinf(x));",dtype:"bool"}),VB={kernelName:Oa,backendName:"webgl",kernelFunc:UB},GB=fL({opSnippet:"return float(isnan(x));",dtype:"bool"}),jB={kernelName:Da,backendName:"webgl",kernelFunc:GB},HB=mL({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:qD,dtype:"bool"}),KB={kernelName:La,backendName:"webgl",kernelFunc:HB},qB=mL({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:XD,dtype:"bool"}),XB={kernelName:Pa,backendName:"webgl",kernelFunc:qB};const YB={kernelName:za,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,o=YD(a,r,s);return t.makeTensorInfo([o.length],"float32",o)}},ZB=fL({opSnippet:pL+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:ZD}),QB={kernelName:Ba,backendName:"webgl",kernelFunc:ZB},JB=fL({opSnippet:pL+"\n  return log(1.0 + x);\n"}),$B={kernelName:Wa,backendName:"webgl",kernelFunc:JB},eW=mL({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),tW={kernelName:Ua,backendName:"webgl",kernelFunc:eW},nW=fL({opSnippet:"return float(!(x >= 1.0));"}),aW={kernelName:Va,backendName:"webgl",kernelFunc:nW},rW=mL({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),sW={kernelName:Ga,backendName:"webgl",kernelFunc:rW};class oW{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[];const s=t,o=e[3]-1;let i;this.outputShape=e;const c="float(".concat(n,") + float(").concat(a,") * sum");i=.5===r?"inversesqrt(".concat(c,")"):1===r?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(r,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(s,"; j <= ").concat(s,"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(o,") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(i,";\n        setOutput(val);\n      }\n    ")}}class iW{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const s=t,o=e[3]-1;let i;this.outputShape=e;const c="float(".concat(n,") + float(").concat(a,") * sum");i=.5===r?"inversesqrt(".concat(c,")"):1===r?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(r,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3],";\n        bool hasNextRow = c < ").concat(this.outputShape[2],";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(s,";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(s,"; j <= ").concat(s,"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(o,"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(i,";\n        setOutput(result);\n      }\n    ")}}const cW={kernelName:ja,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:o,alpha:i,beta:c}=a,l=hn().getBool("WEBGL_PACK_NORMALIZATION")?new iW(r.shape,s,o,i,c):new oW(r.shape,s,o,i,c);return n.runWebGLProgram(l,[r],r.dtype)}};class lW{constructor(e,t,n,a,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=a,this.beta=r,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth,"; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(t,")));\n          int depthEnd = int(min(float(").concat(this.depth,"),\n              float(d + ").concat(t," + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth,";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(a,") * norm + float(").concat(n,");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(a,")\n                * float(").concat(r,")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(r,");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ")}}const uW={kernelName:Ha,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:o}=t,{depthRadius:i,bias:c,alpha:l,beta:u}=a,h=new lW(r.shape,i,c,l,u);return n.runWebGLProgram(h,[r,s,o],r.dtype)}};function hW(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:o}=a,i=r.shape.length,c=Bt(s,r.shape);let l=c;const u=Fu(l,i),h=null!=u,d=n.shouldExecuteOnCPU([r]);let p=r;if(h){if(d){const e=n.texData.get(p.dataId).values,t=new Array(i);for(let n=0;n<t.length;n++)t[n]=r.shape[u[n]];const a=SM(e,r.shape,r.dtype,u,t);p=n.makeTensorInfo(t,r.dtype);n.texData.get(p.dataId).values=a}else p=AL(r,u,n);l=Du(l.length,i)}_u("max",l,i);const[f,m]=Ru(p.shape,l);let g,y=f;if(o&&(y=Au(f,c)),d){const e=n.texData.get(p.dataId).values,t=QD(e,Ft(m),y,r.dtype);g=n.makeTensorInfo(y,r.dtype);n.texData.get(g.dataId).values=t}else g=function(e,t,n,a){const r=Ft(t),s=SL({inputs:{x:e},attrs:{shape:[Ft(e.shape)/r,r]},backend:a}),o=TL(s,e.dtype,"max",a),i=SL({inputs:{x:o},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(o),i}(p,m,y,n);return h&&n.disposeIntermediateTensorInfo(p),g}const dW={kernelName:Ka,backendName:"webgl",kernelFunc:hW},pW=mL({opSnippet:$M+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+tL+"\n  return result;\n",cpuKernelImpl:JD}),fW={kernelName:qa,backendName:"webgl",kernelFunc:pW};const mW={kernelName:Xa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;jO(r,"maxPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:c}=a;Et(Tl(o,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'")));const l=yl(r.shape,s,o,1,i,c);if(1===l.filterWidth&&1===l.filterHeight&&Ot(l.inShape,l.outShape))return aL({inputs:{x:r},backend:n});const u=new mP(l,"max",!1);return n.runWebGLProgram(u,[r],r.dtype)}};const gW={kernelName:Za,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:o,pad:i,dataFormat:c,dimRoundingMode:l}=a,u=bl(r.shape,s,o,[1,1,1],i,l,c),h=new gP(u,"max",!1);return n.runWebGLProgram(h,[r],r.dtype)}};class yW{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,a=e.dilationHeight,r=e.effectiveFilterHeight,s=e.effectiveFilterWidth,o=r-1-e.padInfo.top,i=s-1-e.padInfo.left,c=r*s-1;this.userCode="\n      const ivec2 pads = ivec2(".concat(o,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(r,";\n          wR += ").concat(a,") {\n          float dyR = float(dyRCorner + wR) / ").concat(t,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(s,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(n,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(c," - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(s," + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class bW{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.dilationDepth,s=e.dilationHeight,o=e.dilationWidth,i=e.effectiveFilterDepth,c=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=i-1-e.padInfo.front,h=c-1-e.padInfo.top,d=l-1-e.padInfo.left,p=i*c*l-1;this.userCode="\n      const ivec3 pads = ivec3(".concat(u,", ").concat(h,", ").concat(d,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(i,";\n           wD += ").concat(r,") {\n          float dyD = float(dyDCorner + wD) / ").concat(t,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(c,";\n              wR += ").concat(s,") {\n            float dyR = float(dyRCorner + wR) / ").concat(n,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(l,";\n                wC += ").concat(o,") {\n              float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(p," -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(c," * ").concat(l," +\n                  wR * ").concat(l," + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const vW={kernelName:Qa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,o=s,{filterSize:i,strides:c,pad:l,dimRoundingMode:u}=a,h=bl(o.shape,i,c,[1,1,1],l,u),d=new gP(h,"max",!0),p=n.runWebGLProgram(d,[o],o.dtype),f=new bW(h),m=n.runWebGLProgram(f,[r,p],o.dtype);return n.disposeIntermediateTensorInfo(p),m}};const xW={kernelName:Ya,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s,output:o}=t,i=s;jO([s,o],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:h}=a,d=yl(i.shape,c,l,1,u,h),p=new mP(d,"max",!0),f=n.runWebGLProgram(p,[i],i.dtype),m=new yW(d),g=n.runWebGLProgram(m,[r,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}};const wW={kernelName:Ja,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{filterSize:s,strides:o,pad:i,includeBatchInIndex:c}=n,l=a;Et(4===r.shape.length,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(r.shape.length,".")));const u=[1,1];Et(Tl(o,u),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(u,"'")));const h=yl(r.shape,s,o,u,i),[d,p]=function(e,t,n,a){let r=new mP(n,"max",!1);const s=a.runWebGLProgram(r,[e],"float32");return r=new mP(n,"max",!0,!0,t),[s,a.runWebGLProgram(r,[e],"float32")]}(r,c,h,l);return[d,p]}};const kW={kernelName:$a,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{keepDims:s,axis:o}=n,i=a,c=r.shape.length,l=Bt(o,r.shape);let u=l;const h=Fu(u,c),d=null!=h,p=i.shouldExecuteOnCPU([r]),f=[];let m=r;if(d){if(p){const e=i.texData.get(m.dataId).values,t=new Array(c);for(let a=0;a<t.length;a++)t[a]=r.shape[h[a]];const n=SM(e,r.shape,r.dtype,h,t);m=i.makeTensorInfo(t,r.dtype);i.texData.get(m.dataId).values=n}else m=AL(r,h,i);f.push(m),u=Du(u.length,c)}_u("sum",u,c);const[g,y]=Ru(m.shape,u);let b=g;s&&(b=Au(g,l));const v=function(e,t,n,a){const r=Ft(t),s=SL({inputs:{x:e},attrs:{shape:[Ft(e.shape)/r,r]},backend:a}),o=TL(s,"float32","mean",a),i=SL({inputs:{x:o},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(o),i}(m,y,b,i);for(const x of f)i.disposeIntermediateTensorInfo(x);return v}};const SW={kernelName:er,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a,i=r.shape.length,c=Bt(s,r.shape);let l=c;const u=Fu(l,i);let h=r;null!=u&&(h=OL({inputs:{x:r},backend:n,attrs:{perm:u}}),l=Du(l.length,r.shape.length)),_u("min",l,i);const[d,p]=Ru(h.shape,l),f=SL({inputs:{x:h},backend:n,attrs:{shape:[-1,Ft(p)]}}),m=TL(f,f.dtype,"min",n);let g;if(o){g=SL({inputs:{x:m},backend:n,attrs:{shape:Au(d,c)}})}else g=SL({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(h),g}},IW=mL({opSnippet:$M+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+tL+"\n  return result;\n",cpuKernelImpl:$D}),NW={kernelName:tr,backendName:"webgl",kernelFunc:IW};class CW{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=cD(a),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),c="reflect"===n?0:1;this.userCode=1!==a?"\n      ".concat(r," start = ").concat(r,"(").concat(s,");\n      ").concat(r," end = ").concat(r,"(").concat(o,");\n\n      void main() {\n        ").concat(r," outC = getOutputCoords();\n        for (int i = 0; i < ").concat(a,"; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(c,";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(c,";\n          }\n        }\n        ").concat(r," coords = outC - start;\n        setOutput(getX(").concat(i,"));\n      }\n    "):"\n        int start = ".concat(s,";\n        int end = ").concat(o,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(c,";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(c,";\n          }\n          setOutput(getX(outC - start));\n        }\n      ")}}class TW{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=cD(a),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=CM("rc",a),c=CM("source",a),l="".concat(i[a-1]," < ").concat(this.outputShape[a-1]),u=1===a?"source":"vec2(".concat(c.slice(-2).join(),")"),h="reflect"===n?0:1;let d="";if(1===a){const e="\n        ".concat(r," source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(h,";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(h,";\n        }\n        source -= start;\n      ");d="\n        ".concat(r," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        ").concat(i[a-1]," += 1;\n        if(").concat(l,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n      ")}else{const e="\n        ".concat(r," source = rc;\n        ").concat(r," lt = ").concat(r,"(lessThan(source, start));\n        ").concat(r," gte = ").concat(r,"(greaterThanEqual(source, end));\n        ").concat(r," orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(h,") +\n                gte * ((end - 1) * 2 - source + ").concat(h,");\n        source -= start;\n      ");d="\n        ".concat(r," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        ").concat(i[a-1]," += 1;\n        if(").concat(l,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n        rc = outputLoc;\n        ").concat(i[a-2]," += 1;\n        if(").concat(i[a-2]," < ").concat(this.outputShape[a-2],") {\n          ").concat(e,"\n          result[2] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n          ").concat(i[a-1]," += 1;\n          if(").concat(l,") {\n            ").concat(e,"\n            result[3] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n          }\n        }\n      ")}this.userCode="\n      const ".concat(r," start = ").concat(r,"(").concat(s,");\n      const ").concat(r," end = ").concat(r,"(").concat(o,");\n\n      void main() {\n        ").concat(r," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(d,"\n        setOutput(result);\n      }\n    ")}}const EW={kernelName:nr,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r}=t,{paddings:s,mode:o}=a,i=hn().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new TW(r.shape,s,o):new CW(r.shape,s,o);return n.runWebGLProgram(i,[r],r.dtype)}},RW=mL({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+tL+"\n  return result;\n"}),AW={kernelName:ar,backendName:"webgl",kernelFunc:RW};class _W{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(t-1,"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(t-1,"));\n      }\n    ")}}const FW=mL({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),OW={kernelName:ua,backendName:"webgl",kernelFunc:FW},DW="return a - b;",MW=mL({opSnippet:DW,packedOpSnippet:DW,supportsComplex:!0,cpuKernelImpl:xM}),LW={kernelName:ss,backendName:"webgl",kernelFunc:MW};function PW(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,o=Bt([s],r.shape),i=hW({inputs:{x:r},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),c=Au(i.shape,o),l=SL({inputs:{x:i},backend:n,attrs:{shape:c}}),u=MW({inputs:{a:r,b:l},backend:n}),h=nB({inputs:{x:u},backend:n}),d=_L({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:!1}}),p=SL({inputs:{x:d},backend:n,attrs:{shape:c}}),f=FW({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const zW={kernelName:qr,backendName:"webgl",kernelFunc:PW};const BW={kernelName:rr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:o,normalized:i}=a,c=i?r:PW({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),l=c.shape[0],u=c.shape[1],h=new _W(l,u,s),d=[[o]],p=n.runWebGLProgram(h,[c],"int32",d);return i||n.disposeIntermediateTensorInfo(c),p}},WW=DM+"\n  return -x;\n";const UW={kernelName:or,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){const e=n.texData.get(a.dataId),[t,r]=tM(e.values,a.shape,a.dtype);return n.makeTensorInfo(r,a.dtype,t)}let r;return r=hn().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new qM(a.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new OM(a.shape,WW),n.runWebGLProgram(r,[a],a.dtype)}},VW=Lp;const GW={kernelName:cr,backendName:"webgl",kernelFunc:function(e){ks("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:c}=a,l=n.readSync(r.dataId),u=n.readSync(s.dataId),{selectedIndices:h}=VW(l,u,o,i,c);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},jW=Pp;const HW={kernelName:lr,backendName:"webgl",kernelFunc:function(e){ks("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:c,padToMaxOutputSize:l}=a,u=n.readSync(r.dataId),h=n.readSync(s.dataId),{selectedIndices:d,validOutputs:p}=jW(u,h,o,i,c,l);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},KW=zp;const qW={kernelName:ur,backendName:"webgl",kernelFunc:function(e){ks("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:c,softNmsSigma:l}=a,u=n.readSync(r.dataId),h=n.readSync(s.dataId),d=o,p=i,f=c,m=l,{selectedIndices:g,selectedScores:y}=KW(u,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class XW{constructor(e,t,n,a){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(a,"), float(").concat(n,"),\n                      float(index == coords.y)));\n      }\n    ")}}const YW={kernelName:dr,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:o,onValue:i,offValue:c}=a,l=Ft(r.shape),u=new XW(l,o,i,c),h=SL({inputs:{x:r},backend:n,attrs:{shape:[l]}}),d=n.runWebGLProgram(u,[h],s);n.disposeIntermediateTensorInfo(h);const p=SL({inputs:{x:d},backend:n,attrs:{shape:[...r.shape,o]}});return n.disposeIntermediateTensorInfo(d),p}};function ZW(e){const{inputs:t,backend:n}=e,{x:a}=t;if("complex64"===a.dtype){const e=PP({inputs:{input:a},backend:n}),t=ZW({inputs:{x:e},backend:n}),r=$P({inputs:{input:a},backend:n}),s=ZW({inputs:{x:r},backend:n}),o=sL({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),o}return pB({attrs:{shape:a.shape,dtype:a.dtype,value:"string"===a.dtype?"":0},backend:n})}const QW={kernelName:ms,backendName:"webgl",kernelFunc:ZW};const JW={kernelName:hr,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const t=PP({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a}),s=$P({inputs:{input:r},backend:a}),o=ZW({inputs:{x:s},backend:a}),i=sL({inputs:{real:n,imag:o},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(o),i}return pB({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:a})}};const $W={kernelName:pr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return rB({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const s=t[0].shape,o=t[0].dtype;t.forEach((e=>{Rt(s,e.shape,"All tensors passed to stack must have matching shapes"),Et(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],c=t.map((e=>{const t=rB({inputs:{input:e},backend:n,attrs:{dim:r}});return i.push(t),t})),l=nz({inputs:c,backend:n,attrs:{axis:r}});return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}};class eU{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=cD(a),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);this.userCode=1!==a?"\n      ".concat(r," start = ").concat(r,"(").concat(s,");\n      ").concat(r," end = ").concat(r,"(").concat(o,");\n\n      void main() {\n        ").concat(r," outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ").concat(r," coords = outC - start;\n          setOutput(getX(").concat(i,"));\n        }\n      }\n    "):"\n        int start = ".concat(s,";\n        int end = ").concat(o,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ")}}class tU{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=cD(a),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=CM("rc",a),c=CM("source",a),l="".concat(i[a-1]," < ").concat(this.outputShape[a-1]),u=1===a?"source":"vec2(".concat(c.slice(-2).join(),")"),h=["".concat(r," rc = outputLoc;"),"".concat(i[a-1]," += 1;\n       if(").concat(l,") {\n      "),1===a?"":"}\n       rc = outputLoc;\n       ".concat(i[a-2]," += 1;\n       if(").concat(i[a-2]," < ").concat(this.outputShape[a-2],") {"),1===a?"":"  ".concat(i[a-1]," += 1;\n         if(").concat(l,") {")],d=1===a?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===a?2:4;f<m;f++)p+="\n        ".concat(h[f],"\n        if (").concat(d,") {\n          result[").concat(f,"] = float(value);\n        } else {\n          ").concat(r," source = rc - start;\n          result[").concat(f,"] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n      ");p+=1===a?"} ":"}}",this.userCode="\n      const ".concat(r," start = ").concat(r,"(").concat(s,");\n      const ").concat(r," end = ").concat(r,"(").concat(o,");\n\n      void main() {\n        ").concat(r," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(p,"\n        setOutput(result);\n      }\n    ")}}const nU=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:o}=a;if(0===Ft(r.shape)){const e=s.map(((e,t)=>e[0]+r.shape[t]+e[1]));return pB({backend:n,attrs:{shape:e,value:o,dtype:r.dtype}})}const i=hn().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new tU(r.shape,s,o):new eU(r.shape,s,o),c=[[o]];return n.runWebGLProgram(i,[r],r.dtype,c)},aU={kernelName:fr,backendName:"webgl",kernelFunc:nU},rU=mL({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+tL+"\n  return result;\n"}),sU={kernelName:mr,backendName:"webgl",kernelFunc:rU};const oU={kernelName:yr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a,i=r.shape.length,c=[],l=Bt(s,r.shape);let u=l;const h=Fu(u,i);let d,p=r;if(null!=h&&(p=OL({inputs:{x:r},backend:n,attrs:{perm:h}}),u=Du(u.length,i),c.push(p)),_u("prod",u,i),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:a,outDtype:r}=aM(p.shape,p.dtype,e,u);d=n.makeTensorInfo(a,r,t)}else{const[e,t]=Ru(p.shape,u),a=Ft(t),s=SL({inputs:{x:p},backend:n,attrs:{shape:[-1,a]}}),o=TL(s,So(r.dtype),"prod",n);d=SL({inputs:{x:o},backend:n,attrs:{shape:e}}),c.push(s),c.push(o)}if(o){c.push(d);const e=Au(d.shape,l);d=SL({inputs:{x:d},backend:n,attrs:{shape:e}})}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}};const iU={kernelName:br,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:s,indices:o}=t,{outputRaggedRank:i}=a,c=r.map((e=>n.readSync(e.dataId))),l=r.map((e=>e.shape)),u=n.readSync(s.dataId),h=n.readSync(o.dataId),[d,p,f]=rM(c,l,u,s.shape,s.dtype,h,o.shape,i),m=d.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}};const cU={kernelName:vr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{shape:r,values:s,defaultValue:o,rowPartitionTensors:i}=t,{rowPartitionTypes:c}=a,l=n.readSync(r.dataId),u=n.readSync(s.dataId),h=n.readSync(o.dataId),d=i.map((e=>n.readSync(e.dataId))),p=i.map((e=>e.shape)),[f,m]=sM(l,r.shape,u,s.shape,s.dtype,h,o.shape,d,p,c);return n.makeTensorInfo(f,s.dtype,m)}},lU=e=>{const{backend:t,attrs:n}=e,{start:a,stop:r,step:s,dtype:o}=n,i=oM(a,r,s,o);return t.makeTensorInfo([i.length],o,i)},uU={kernelName:xr,backendName:"webgl",kernelFunc:lU},hU=fL({opSnippet:"return 1.0 / x;"}),dU={kernelName:kr,backendName:"webgl",kernelFunc:hU},pU=fL({opSnippet:DM+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),fU={kernelName:Sr,backendName:"webgl",kernelFunc:pU},mU=fL({opSnippet:DM+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),gU={kernelName:Rr,backendName:"webgl",kernelFunc:mU};class yU{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];const[s,o,i,c]=e;this.outputShape=[s,t,n,c];const l=[a&&t>1?o-1:o,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n];let h;h=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(o,".0, ").concat(i,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ")}}class bU{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,i,c]=e;this.outputShape=[s,t,n,c];const l=[a&&t>1?o-1:o,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n];let h;h=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],",\n          ").concat(l[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(o,".0, ").concat(i,".0,\n                                     ").concat(i,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(c-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ")}}const vU={kernelName:Tr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:o,size:i}=a,[c,l]=i,u=hn().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new bU(r.shape,c,l,s,o):new yU(r.shape,c,l,s,o);return n.runWebGLProgram(u,[r],"float32")}};class xU{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,r]=t,[,s,o]=e,i=[n&&s>1?a-1:a,n&&o>1?r-1:r],c=[n&&s>1?s-1:s,n&&o>1?o-1:o],l=i[0]/c[0],u=i[1]/c[1],h=1/l,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(l,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(h,");\n        const float invWidthScale = float(").concat(d,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(s,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(o,") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(a-1,".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(r-1,".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const wU={kernelName:Er,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:o}=a,i=new xU(s.shape,r.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}};class kU{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];const[s,o,i,c]=e;this.outputShape=[s,t,n,c];const l=[a&&t>1?o-1:o,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],h=a?"0.5":"0.0";let d;d=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(o,".0, ").concat(i,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(h,")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ")}}class SU{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,i,c]=e;this.outputShape=[s,t,n,c];const l=[a&&t>1?o-1:o,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],h=a?"0.5":"0.0";let d;d=r?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],",\n          ").concat(l[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(o,".0, ").concat(i,".0,\n                                     ").concat(i,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(h,")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(c-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ")}}const IU={kernelName:Nr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:o,size:i}=a,[c,l]=i,u=hn().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new SU(r.shape,c,l,s,o):new kU(r.shape,c,l,s,o);return n.runWebGLProgram(u,[r],r.dtype)}};class NU{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,r]=t,[,s,o]=e,i=[n&&s>1?a-1:a,n&&o>1?r-1:r],c=[n&&s>1?s-1:s,n&&o>1?o-1:o],l=i[0]/c[0],u=i[1]/c[1],h=1/l,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(l,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(h,");\n        const float invWidthScale = float(").concat(d,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(s,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(o,") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(i[0],") *\n                (float(dyR) / float(").concat(c[0],"));\n\n            float sourceFracCol =\n                float(").concat(i[1],") *\n                  (float(dyC) / float(").concat(c[1],"));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(a,") - 1),\n                ").concat(n," ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(r,") - 1),\n                ").concat(n," ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const CU={kernelName:Cr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:o}=a,i=new NU(s.shape,r.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}};class TU{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));if(this.outputShape=e,1===n)return void(this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(e[0]," - coord - 1));\n        }\n      "));const a=e.map(((n,a)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - coords[").concat(n,"] - 1"):"coords[".concat(n,"]"))(a))).join(","),r=cD(n);this.userCode="\n      void main() {\n        ".concat(r," coords = getOutputCoords();\n        setOutput(getX(").concat(a,"));\n      }\n    ")}}class EU{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));this.outputShape=e;const a=CM("rc",n),r="".concat(a[n-1]," + 1 < ").concat(this.outputShape[n-1]),s="".concat(a[n-2]," + 1 < ").concat(this.outputShape[n-2]),o=cD(n);function i(n){const a=e.map(((a,r)=>function(n,a){return-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - ").concat(a[n]," - 1"):"".concat(a[n])}(r,n))),r=a.join(","),s=a.slice(-2).join(",");return"getChannel(getX(".concat(r,"), vec2(").concat(s,"))")}this.userCode=1===n?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(e[0]," - rc - 1),\n            ").concat(e[0]," - rc - 1);\n          if(").concat(r,"){\n              result.g = getChannel(getX(").concat(e[0]," - (rc  + 1) - 1),\n                ").concat(e[0]," - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      "):"\n        void main() {\n          ".concat(o," rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat(function(e){return i(e)}(a.slice()),";\n          if(").concat(r,"){\n            result.g = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",i(e)}(a.slice()),";\n          }\n          if(").concat(s,") {\n            result.b = ").concat(function(e){return e[n-2]="("+e[n-2]+" + 1)",i(e)}(a.slice()),";\n            if(").concat(r,") {\n              result.a = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",i(e)}(a.slice()),";\n            }\n          }\n          setOutput(result);\n        }\n    ")}}const RU={kernelName:Ar,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a,o=r.shape.length,i=Bt(s,r.shape);if(0===o)return aL({inputs:{x:r},backend:n});const c=hn().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new EU(r.shape,i):new TU(r.shape,i);return n.runWebGLProgram(c,[r],r.dtype)}};class AU{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],a=e[2];this.outputShape=e;let r="";r="number"===typeof t?"float outputValue = ".concat(t.toFixed(2),";"):"\n        vec3 fill = vec3(".concat(t.join(","),");\n        float outputValue = fill[coords[3]];"),this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ".concat(r,"\n          if(coordX >= 0 && coordX < ").concat(a," && coordY >= 0 && coordY < ").concat(n,") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const _U={kernelName:bs,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,{radians:s,fillValue:o,center:i}=n,c=a,l=new AU(r.shape,o),[u,h]=qf(i,r.shape[1],r.shape[2]),d=[[u,h,Math.sin(s),Math.cos(s)]];return c.runWebGLProgram(l,[r],r.dtype,d)}},FU=fL({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),OU={kernelName:_r,backendName:"webgl",kernelFunc:FU},DU=fL({opSnippet:"return inversesqrt(x);",cpuKernelImpl:iM}),MU={kernelName:Fr,backendName:"webgl",kernelFunc:DU};class LU{constructor(e,t,n,a,r,s){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const o=cD(r.length),i=cD(s.length);let c="";1===n?c="i":2===n&&(c="i, j");const l="getIndices(".concat(c,")");let u="";1===a?u="i":2===a&&(u="i, coords[1]");const h="getUpdates(".concat(u,")"),d=t>1?"strides[j]":"strides";this.userCode="\n        ".concat(o," strides = ").concat(o,"(").concat(r,");\n\n        void main() {\n          ").concat(i," coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(e,"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(t,"; j++) {\n              int index = round(").concat(l,");\n              flattenedIndex += index * ").concat(d,";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ").concat(h,";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      ")}}const PU={kernelName:Or,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:o}=a,{sliceRank:i,numUpdates:c,sliceSize:l,strides:u,outputSize:h}=op(0,r,o),d=[h/l,l];if(0===h)return n.makeTensorInfo(o,r.dtype);const p=SL({inputs:{x:r},backend:n,attrs:{shape:[c,i]}}),f=SL({inputs:{x:s},backend:n,attrs:{shape:[c,l]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new LU(c,i,p.shape.length,f.shape.length,u,d),y=n.runWebGLProgram(g,[f,p,m],f.dtype),b=SL({inputs:{x:y},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}};class zU{constructor(e,t,n,a){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const r="for (int i = 0; i < ".concat(Math.ceil(Math.log2(t+1)),"; ++i) { if (left >= right) break;"),s=2===hn().getNumber("WEBGL_VERSION")?"while (left < right) {":r,o="left"===a?"<":"<=";this.userCode="\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ".concat(s,"\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ").concat(o," value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     ")}}const BU={kernelName:Dr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:o}=a,i=new zU(r.shape[0],r.shape[1],s.shape[1],o),c=[[r.shape[1]]];return n.runWebGLProgram(i,[r,s],"int32",c)}};class WU{constructor(e,t,n){let a,r;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error("Where for rank ".concat(n," is not yet supported"));if(1===n)r="resRC",a="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],o=[];for(let a=0;a<t.length;a++)o.push("".concat(n[a])),a<e&&s.push("".concat(n[a]));a=s.join(),r=o.join()}const s=cD(n);this.userCode="\n      void main() {\n        ".concat(s," resRC = getOutputCoords();\n        float cVal = getC(").concat(a,");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(r,"));\n        } else {\n          setOutput(getB(").concat(r,"));\n        }\n      }\n    ")}}const UU={kernelName:Mr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t,o=new WU(a.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(o,[a,r,s],ko(r.dtype,s.dtype))}},VU=fL({opSnippet:"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ".concat(em,";\n  float scale = ").concat(tm,";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n")}),GU={kernelName:Lr,backendName:"webgl",kernelFunc:VU},jU=fL({opSnippet:pL+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:lM}),HU={kernelName:Ur,backendName:"webgl",kernelFunc:jU},KU=fL({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),qU={kernelName:Wr,backendName:"webgl",kernelFunc:KU},XU=fL({opSnippet:pL+"\n  return sin(x);\n"}),YU={kernelName:zr,backendName:"webgl",kernelFunc:XU},ZU=fL({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),QU={kernelName:Br,backendName:"webgl",kernelFunc:ZU},JU=fL({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),$U={kernelName:Vr,backendName:"webgl",kernelFunc:JU},eV={kernelName:Hr,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:o}=a;Et(r.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const i=s.reduce(((e,t)=>e*t)),c=[[0,0]];c.push(...o);for(let y=1+s.length;y<r.shape.length;++y)c.push([0,0]);const l=[],u=nU({inputs:{x:r},backend:n,attrs:{paddings:c,constantValue:0}}),h=Xf(u.shape,s,i,!1),d=Yf(h.length,s.length,!1),p=Zf(u.shape,s,i,!1),f=SL({inputs:{x:u},backend:n,attrs:{shape:h}}),m=OL({inputs:{x:f},backend:n,attrs:{perm:d}}),g=SL({inputs:{x:m},backend:n,attrs:{shape:p}});return l.push(u),l.push(f),l.push(m),l.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}};const tV={kernelName:Xr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:o}=t;if(1!==s.shape.length)throw new Error("Dense shape must be a vector, saw:\n         ".concat(s.shape));if(2!==a.shape.length)throw new Error("Indices must be a matrix, saw:\n         ".concat(a.shape));if(1!==r.shape.length)throw new Error("Values must be a vector, saw:\n         ".concat(r.shape));if(0!==o.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(o.shape));const i=n.readSync(a.dataId),c=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(o.dataId)[0],[h,d,p,f,m]=dM(i,a.shape,a.dtype,c,r.dtype,l,u);return[n.makeTensorInfo(d,a.dtype,h),n.makeTensorInfo([d[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}};const nV={kernelName:Yr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape ".concat(a.shape));if(1!==r.shape.length)throw new Error("Input shape should be a vector but received shape ".concat(r.shape));if(1!==s.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(s.shape));const o=Array.from(n.readSync(r.dataId)),i=n.readSync(a.dataId),c=Array.from(n.readSync(s.dataId)),[l,u,h]=pM(i,a.shape,a.dtype,o,c);return[n.makeTensorInfo(u,a.dtype,l),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}};const aV={kernelName:Zr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n              ".concat(r.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n              ".concat(s.shape));const o=n.readSync(a.dataId),i=n.readSync(r.dataId),c=n.readSync(s.dataId),[l,u]=fM(o,a.shape,a.dtype,i,c,!0);return n.makeTensorInfo(u,a.dtype,l)}};const rV={kernelName:Qr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n             ".concat(r.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n             ".concat(s.shape));const o=n.readSync(a.dataId),i=n.readSync(r.dataId),c=n.readSync(s.dataId),[l,u]=fM(o,a.shape,a.dtype,i,c);return n.makeTensorInfo(u,a.dtype,l)}};const sV={kernelName:Jr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:o}=t,{outputShape:i}=a,{sliceRank:c,numUpdates:l,sliceSize:u,strides:h,outputSize:d}=op(0,r,i);if("string"===s.dtype){const e=n.bufferSync(r),t=n.bufferSync(s),a=Zs(n.readSync(o.dataId)[0]),p=cM(e,t,i,d,u,l,c,h,a,false);return n.makeTensorInfo(i,p.dtype,p.values)}const p=new LU(l,c,r.shape.length,s.shape.length,h,[d,1],false),f=n.runWebGLProgram(p,[s,r,o],s.dtype),m=SL({inputs:{x:f},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(f),m}};const oV={kernelName:Kr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:o}=a,i=Bt(o,r.shape)[0],c=Cm(r,s,i),l=r.shape.length,u=new Array(l).fill(0),h=r.shape.slice();return c.map((e=>{const t=[...h];t[i]=e;const a=AP({inputs:{x:r},backend:n,attrs:{begin:u,size:t}});return u[i]+=e,a}))}},iV="return sqrt(x);",cV=fL({opSnippet:iV,packedOpSnippet:iV,cpuKernelImpl:mM}),lV={kernelName:Gr,backendName:"webgl",kernelFunc:cV},uV={kernelName:es,backendName:"webgl",kernelFunc:fL({opSnippet:"return x * x;"})},hV="return (a - b) * (a - b);",dV=mL({opSnippet:hV,packedOpSnippet:hV}),pV={kernelName:$r,backendName:"webgl",kernelFunc:dV};const fV={kernelName:gs,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,s=DM+"\n    return x > 0.0 ? 1.0 : float(".concat(n.alpha,");\n  "),o=new OM(r.shape,s);return a.runWebGLProgram(o,[r],r.dtype)}};class mV{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const a=n.length,r=cD(n.length),s=cD(n.length);let o="";if(1===a)o="coords * strides + begin";else{let e=0;o=n.map(((t,a)=>(e++,1===n.length?"coords * strides[".concat(a,"] + begin[").concat(a,"]"):"coords[".concat(e-1,"] * strides[").concat(a,"] + begin[").concat(a,"]")))).join(",")}this.userCode="\n      ".concat(r," begin = ").concat(r,"(").concat(e,");\n      ").concat(r," strides = ").concat(r,"(").concat(t,");\n\n      void main() {\n        ").concat(s," coords = getOutputCoords();\n        setOutput(getX(").concat(o,"));\n      }\n    ")}}const gV={kernelName:ts,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,end:o,strides:i,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=a,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=Uc(r.shape,s,o,i,c,l,u,h,d);let w;if(m)w=SL({inputs:{x:r},backend:n,attrs:{shape:f}});else if(g||y){Et(r.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(r.shape.length)));const e=Ec(b,v,x),t=AP({inputs:{x:r},backend:n,attrs:{begin:b,size:e}});w=SL({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([r])){const e=n.readSync(r.dataId),t=qi(r.shape,r.dtype,e),a=gM(p,t,x,b);w=n.makeTensorInfo(f,r.dtype,a.values)}else{const e=new mV(b,x,p);w=n.runWebGLProgram(e,[r],r.dtype)}}const k=SL({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}};const yV={kernelName:ns,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:o,rightPad:i,padWidth:c,preserveShortSequences:l}=a,{data:u,dataSplits:h}=t,d=n.readSync(u.dataId),p=n.readSync(h.dataId),[f,m]=yM(d,p,r,s,o,i,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};const bV={kernelName:as,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:s,delimiter:o}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error("Input must be a vector, got shape: ".concat(s.shape));if(0!==o.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(o.shape));const i=n.readSync(s.dataId),c=n.readSync(o.dataId)[0],[l,u,h]=bM(i,c,r),d=u.length;return[n.makeTensorInfo([d,2],"int32",l),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};const vV={kernelName:rs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=n.readSync(s.dataId),i=vM(o,r);return n.makeTensorInfo(s.shape,"int32",i)}},xV=fL({opSnippet:"return tan(x);"}),wV={kernelName:os,backendName:"webgl",kernelFunc:xV},kV=fL({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),SV={kernelName:is,backendName:"webgl",kernelFunc:kV};class IV{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;const a=cD(this.rank),r=function(e){const t=e.length;if(t>5)throw Error("Tile for rank ".concat(t," is not yet supported"));if(1===t)return"imod(resRC, ".concat(e[0],")");const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[];for(let r=0;r<e.length;r++)a.push("imod(".concat(n[r],", ").concat(e[r],")"));return a.join()}(e);this.userCode="\n      void main() {\n        ".concat(a," resRC = getOutputCoords();\n        setOutput(getA(").concat(r,"));\n      }\n    ")}}function NV(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;if("string"===r.dtype||r.shape.length>5){const e=n.readSync(r.dataId),t="string"===r.dtype?e.map((e=>Zs(e))):e,a=qi(r.shape,r.dtype,t),o=wM(a,s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const o=new IV(r.shape,s);return n.runWebGLProgram(o,[r],r.dtype)}const CV={kernelName:cs,backendName:"webgl",kernelFunc:NV};class TV{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class EV{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function RV(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function AV(e){let t=1;for(;t<e;)t*=2;return t}const _V={kernelName:ls,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:o}=a,i=hn().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=hn().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=r.shape,u=l[l.length-1];if(n.shouldExecuteOnCPU([r])||u<i||s>c){const e=n.readSync(r.dataId),[t,a]=kM(e,l,r.dtype,s,o);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(a.shape,a.dtype,a.values)]}if(0===s)return l[l.length-1]=0,[n.makeTensorInfo(l,r.dtype,[]),n.makeTensorInfo(l,"int32",[])];if(1===u)return[r,pB({attrs:{shape:l,dtype:"int32",value:0},backend:n})];const h=n.texData.get(r.dataId),d=null!==h&&h.isPacked,p=d?n.unpackTensor(r):r,f=Ft(l)/u,m=SL({inputs:{x:p},attrs:{shape:[f,u]},backend:n});d&&RV(n,p);const g=AV(s),y=AV(u);let b=null;const v=()=>null===b?[m,m]:[m,b],x=(e,t,a)=>{const r=v(),s=new TV(a),o=[[u],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],i=b;b=n.runWebGLProgram(s,r,"int32",o),RV(n,i)};for(let N=1;N<g;N*=2){const e=2*N;for(let t=N;t>=1;t/=2)x(e,t,[f,y])}for(let N=y;N>g;N/=2){const e=v(),t=new EV([f,N/2]),a=[[u],[null===b?1:0],[g]],r=b;b=n.runWebGLProgram(t,e,"int32",a),RV(n,r);const s=g/2,o=2*s;for(let n=s;n>=1;n/=2)x(o,n,b.shape)}let w=b;b=AP({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,s]}}),RV(n,w);let k=FB({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});RV(n,m);const S=l.slice(0,-1);S.push(s),w=b,b=SL({inputs:{x:b},attrs:{shape:S},backend:n}),RV(n,w);const I=k;return k=SL({inputs:{x:k},attrs:{shape:S},backend:n}),RV(n,I),[k,b]}};class FV{constructor(e,t,n,a,r,s){this.variableNames=["Image","Transforms"],this.outputShape=s;const o="nearest"===n?1:2;let i;switch(a){case"constant":default:i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4}this.userCode="\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(".concat(i," == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ").concat(e," && 0 <= coordX && coordX < ").concat(t,") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(").concat(r,");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(").concat(r,");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(").concat(t,"));\n                float mapY = mapCoord(inY, float(").concat(e,"));\n\n                if (").concat(o," == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ")}}const OV={kernelName:us,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,transforms:s}=t,{interpolation:o,fillMode:i,fillValue:c,outputShape:l}=a,[u,h,d,p]=r.shape,[f,m]=null!=l?l:[h,d],g=new FV(h,d,o,i,c,[u,f,m,p]);return n.runWebGLProgram(g,[r,s],"float32")}};const DV={kernelName:ds,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;jO(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=a.readSync(s.dataId),{outputValues:i,outputShape:c,indices:l}=IM(o,r,s.shape,s.dtype);return[a.makeTensorInfo(c,s.dtype,i),a.makeTensorInfo([l.length],"int32",l)]}};const MV={kernelName:ps,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:s}=a;s<0&&(s+=r.shape.length);const o=r,i=o.shape.length,c=r.shape[s],l=new Array(i-1);let u=0;for(let m=0;m<i;m++)m!==s&&(l[u++]=o.shape[m]);const h=[],d=new Array(i).fill(0),p=o.shape.slice();p[s]=1;const f=new Array(c);for(let m=0;m<f.length;m++){d[s]=m;const e=AP({inputs:{x:o},backend:n,attrs:{begin:d,size:p}}),t=SL({inputs:{x:e},backend:n,attrs:{shape:l}});f[m]=t,h.push(e)}return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class LV{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,a=e.batchSize,r=e.inSize,s=e.numSegments,o=s*Math.ceil(r/n);this.outputShape=[a,o];const i=4*Math.floor(n/4),c=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let u="";r%n>0&&(u="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return initializationValue;\n        }\n      "));let h="";r%n>0&&(h="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return -1.0;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat("0.0",";\n\n      float getValue(int batch, int inIdx) {\n        ").concat(u,"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(h,"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(s,")) * float(").concat(n,"));\n        int currentSeg = int(mod(float(outIdx), float(").concat(s,")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(i,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(l,"\n        }\n\n        int inIdx = inOffset + ").concat(i,";\n        if (").concat(1===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(l,"\n        } else if (").concat(2===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(l,"\n        } else if (").concat(3===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(l,"\n        }\n        setOutput(").concat("sumValue",");\n      }\n    ")}}const PV={kernelName:fs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:s}=t,{numSegments:o}=a,i=r.shape.length,c=[];let l=0;const u=Fu([l],i);let h=r;null!=u&&(h=OL({inputs:{x:r},backend:n,attrs:{perm:u}}),c.push(h),l=Du(1,i)[0]);const d=Wm(h.shape,l,o),p=Ft([h.shape[l]]),f=SL({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});c.push(f);const m=So(r.dtype),g=(e,t,a,r,s)=>{const o=e.shape[0],i=e.shape[1],l=Bm(i,s),u=new LV({windowSize:l,inSize:i,batchSize:o,numSegments:s},t),h=n.compileAndRun(u,[e,a],r);if(c.push(h),h.shape[1]===s)return h;const d=lU({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),p=NV({inputs:{x:d},backend:n,attrs:{reps:[i/l]}});c.push(d),c.push(p);return g(h,t,p,r,s)},y=SL({inputs:{x:g(f,"unsortedSegmentSum",s,m,o)},backend:n,attrs:{shape:d}});let b=y;if(null!=u){c.push(y);const e=Ou(u);b=OL({inputs:{x:b},backend:n,attrs:{perm:e}})}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},zV=[PL,BL,UL,GL,KL,YL,ZL,QL,aP,rP,oP,cP,uP,dP,fP,yP,bP,wP,kP,SP,CP,FP,OP,DP,WP,GP,KP,oL,YP,az,hz,gz,yz,bz,vz,xz,kz,Iz,Cz,Fz,Oz,Dz,Lz,Bz,Vz,Gz,Hz,qz,Xz,Zz,Qz,$z,tB,aB,sB,cB,hB,fB,gB,vB,wB,IB,TB,EB,AB,OB,MB,PB,rL,zB,ez,WB,VB,jB,lL,KB,XB,YB,QB,$B,tW,aW,sW,cW,uW,dW,fW,mW,gW,vW,xW,wW,kW,SW,NW,EW,AW,BW,kL,UW,GW,HW,qW,LP,YW,JW,$W,aU,sU,dL,oU,iU,cU,uU,zP,OW,dU,fU,gU,IL,vU,wU,IU,CU,RU,_U,OU,MU,PU,BU,UU,GU,HU,qU,YU,QU,_P,zW,$U,eV,tV,nV,aV,rV,sV,oV,lV,uV,pV,fV,gV,yV,bV,vV,LW,FL,wV,SV,CV,_V,OV,DL,DV,MV,PV,QW];for(const n of zV)Rs(n);var BV=n(776),WV=n.n(BV);const UV=n.p+"static/media/count.f89c5fa1380233c226e7.wav";let VV,GV=!1,jV="rgb(255,0,0)";const HV=function(){const{stopPose:e,isStartPose:t,startingTime:n,startingTimefunc:a,currentTime:r,currentTimefunc:s,poseTime:o,poseTimefunc:i,bestPerform:c,bestPerformfunc:l,currentPose:u}=(0,E.useContext)(tt);(0,E.useEffect)((()=>{const e=(r-n)/1e3;GV&&i(e),(r-n)/1e3>c&&l(e)}),[r]),(0,E.useEffect)((()=>{s(0),i(0),l(0)}),[u]);const h=(0,E.useRef)(null),d=(0,E.useRef)(null),p={Chair:0,Cobra:1,Dog:2,No_Pose:3,Shoulderstand:4,Traingle:5,Tree:6,Warrior:7};function f(e,t,n){let a=Zu(e,t,1),r=Zu(e,n,1);return sl(Ml(a,.5),Ml(r,.5))}function m(e){let t=f(e,lt.LEFT_HIP,lt.RIGHT_HIP);t=Hu(t,1),t=ql(t,[1,17,2]);let n=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2.5,n=f(e,lt.LEFT_HIP,lt.RIGHT_HIP),a=f(e,lt.LEFT_SHOULDER,lt.RIGHT_SHOULDER),r=Vu(ph(a,n)),s=f(e,lt.LEFT_HIP,lt.RIGHT_HIP);s=Hu(s,1),s=ql(s,[1,17,2]);let o=Zu(ph(e,s),0,0),i=Mu(Vu(o,"euclidean",0));return Ch(Ml(r,t),i)}(e=ph(e,t));return e=bu(e,n)}const g=async()=>{const e={modelType:cv.SINGLEPOSE_THUNDER},t=await function(e,t){return uy(this,void 0,void 0,(function(){var n,a;return hy(this,(function(r){switch(e){case ub.PoseNet:return[2,iv(t)];case ub.BlazePose:if(a=void 0,null!=(n=t)){if("tfjs"===n.runtime)return[2,cb(t)];if("mediapipe"===n.runtime)return[2,xy(t)];a=n.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got "+a);case ub.MoveNet:return[2,Nb(t)];default:throw new Error(e+" is not a supported model name.")}}))}))}(ub.MoveNet,e),n=await(a="https://models.s3.jp-tok.cloud-object-storage.appdomain.cloud/model.json",null==r&&(r={}),tI(a,r));var a,r;const s=new Audio(UV);s.loop=!0,VV=setInterval((()=>{y(t,n,s)}),100)},y=async(e,t,n)=>{if("undefined"!==typeof h.current&&null!==h.current&&4===h.current.video.readyState){let o=0;const i=h.current.video,c=await e.estimatePoses(i),l=d.current.getContext("2d");l.clearRect(0,0,d.current.width,d.current.height);try{const e=c[0].keypoints;let i=e.map((t=>{if(t.score>.4){if("left_eye"!==t.name&&"right_eye"!==t.name){!function(e,t,n,a,r){e.beginPath(),e.arc(t,n,a,0,2*Math.PI),e.fillStyle=r,e.fill()}(l,t.x,t.y,8,"rgb(255,255,255)");let n=ut[t.name];try{n.forEach((n=>{let a=n.toUpperCase();!function(e,t,n,a){let[r,s]=t,[o,i]=n;e.beginPath(),e.moveTo(r,s),e.lineTo(o,i),e.lineWidth=5,e.strokeStyle=a,e.stroke()}(l,[t.x,t.y],[e[lt[a]].x,e[lt[a]].y],jV)}))}catch(XV){}}}else o+=1;return[t.x,t.y]}));if(o>4)return void(jV="rgb(255,0,0)");const h=(r=m(Hu(r=i,0)),Al(r,[1,34]));t.predict(h).array().then((e=>{const t=p[u];console.log(e[0][t]),e[0][t]>.97?(GV||(n.play(),a(new Date(Date()).getTime()),GV=!0),s(new Date(Date()).getTime()),jV="rgb(0,255,0)"):(GV=!1,jV="rgb(255,0,0)",n.pause(),n.currentTime=0)}))}catch(XV){console.log(XV)}}var r},b=window.screen.width;if(t)return g(),(0,Je.jsxs)("div",{className:"yoga-pose-container",children:[(0,Je.jsxs)("div",{className:"performance-container",children:[(0,Je.jsx)("div",{className:"pose-performance",children:(0,Je.jsxs)("h4",{children:["Pose Time: ",o," s"]})}),(0,Je.jsx)("div",{className:"pose-performance",children:(0,Je.jsxs)("h4",{children:["Best: ",c," s"]})}),(0,Je.jsx)("button",{onClick:e,className:"secondary-btn",children:(0,Je.jsx)(Ye,{to:"/start",children:"Stop Pose"})})]}),(0,Je.jsxs)("div",{className:"pose-detection",children:[(0,Je.jsxs)("div",{className:"detection-container",children:[(0,Je.jsx)(WV(),{width:b>=480?"640px":"360px",height:b>=480?"480px":"270px",id:"webcam",className:"webcam",ref:h}),(0,Je.jsx)("canvas",{ref:d,id:"my-canvas",className:"my-canvas",width:b>=480?"640px":"360px",height:b>=480?"480px":"270px"})]}),(0,Je.jsx)("div",{className:"pose-img",children:(0,Je.jsx)("img",{src:pt[u],alt:"poses"})})]})]})};function KV(){return(0,Je.jsx)(et,{children:(0,Je.jsx)(Ke,{children:(0,Je.jsxs)(We,{children:[(0,Je.jsx)(ze,{path:"/",element:(0,Je.jsx)(st,{})}),(0,Je.jsx)(ze,{path:"/start",element:(0,Je.jsx)(yt,{})}),(0,Je.jsx)(ze,{path:"/about",element:(0,Je.jsx)(bt,{})}),(0,Je.jsx)(ze,{path:"/tutorials",element:(0,Je.jsx)(vt,{})}),(0,Je.jsx)(ze,{path:"/yoga",element:(0,Je.jsx)(HV,{})})]})})})}A.render((0,Je.jsx)(E.StrictMode,{children:(0,Je.jsx)(KV,{})}),document.getElementById("root"))})()})();
//# sourceMappingURL=main.5f1132cb.js.map